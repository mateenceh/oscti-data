<!DOCTYPE html>
<html lang="en-US">

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<title>Countering "Trusting Trust" - Schneier on Security</title>
	<meta name='robots' content='max-image-preview:large' />
<link rel='dns-prefetch' href='//s.w.org' />
<link rel='dns-prefetch' href='//c0.wp.com' />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Feed" href="https://www.schneier.com/feed/" />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Comments Feed" href="https://www.schneier.com/comments/feed/" />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Countering &quot;Trusting Trust&quot; Comments Feed" href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/feed/" />
<link rel='stylesheet' id='wp-block-library-css'  href='https://c0.wp.com/c/5.7/wp-includes/css/dist/block-library/style.min.css' type='text/css' media='all' />
<style id='wp-block-library-inline-css' type='text/css'>
.has-text-align-justify{text-align:justify;}
</style>
<style id='woocommerce-inline-inline-css' type='text/css'>
.woocommerce form .form-row .required { visibility: visible; }
</style>
<link rel='stylesheet' id='schneier-css'  href='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/style.css?ver=1.0.0' type='text/css' media='all' />
<link rel='stylesheet' id='schneier-main-css'  href='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/dist/css/style.css?ver=1.0.2' type='text/css' media='all' />
<link rel='stylesheet' id='jetpack_css-css'  href='https://c0.wp.com/p/jetpack/9.5.2/css/jetpack.css' type='text/css' media='all' />
<script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js?ver=3.5.1' id='jquery-js'></script>
<link rel="https://api.w.org/" href="https://www.schneier.com/wp-json/" /><link rel="alternate" type="application/json" href="https://www.schneier.com/wp-json/wp/v2/posts/686" /><link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://www.schneier.com/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://www.schneier.com/wp-includes/wlwmanifest.xml" /> 

<link rel="canonical" href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html" />
<link rel='shortlink' href='https://www.schneier.com/?p=686' />
<link rel="alternate" type="application/json+oembed" href="https://www.schneier.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2006%2F01%2Fcountering_trus.html" />
<link rel="alternate" type="text/xml+oembed" href="https://www.schneier.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2006%2F01%2Fcountering_trus.html&#038;format=xml" />
	<noscript><style>.woocommerce-product-gallery{ opacity: 1 !important; }</style></noscript>
	<link rel="icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-32x32.png" sizes="32x32" />
<link rel="icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-180x180.png" />
<meta name="msapplication-TileImage" content="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-270x270.png" />
		<style type="text/css" id="wp-custom-css">
			#schneier_promotion-2 img {
    max-width: 180px;
}		</style>
		</head>

<body class="post-template-default single single-post postid-686 single-format-standard theme-schneier woocommerce-no-js">

	<div id="wrapper">
		<div id="main">

			<header>
				<div id="header">
					<h1>
						<a href="https://www.schneier.com/" rel="home">
							Schneier on Security						</a>
					</h1>
				</div>
			</header>

			<nav>
				<div class="nav" id="header-nav">
					<div class="menu-main-menu-container"><ul id="menu-main-menu" class="menu"><li id="menu-item-50175" class="menu1 menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-50175 current-menu-item"><a href="https://www.schneier.com">Blog</a></li>
<li id="menu-item-50916" class="menu2 menu-item menu-item-type-post_type menu-item-object-page menu-item-50916"><a href="https://www.schneier.com/crypto-gram/">Newsletter</a></li>
<li id="menu-item-50166" class="menu3 menu-item menu-item-type-post_type menu-item-object-page menu-item-50166"><a href="https://www.schneier.com/books/">Books</a></li>
<li id="menu-item-50169" class="menu4 menu-item menu-item-type-custom menu-item-object-custom menu-item-50169"><a href="https://www.schneier.com/essays/">Essays</a></li>
<li id="menu-item-50170" class="menu5 menu-item menu-item-type-custom menu-item-object-custom menu-item-50170"><a href="https://www.schneier.com/news/">News</a></li>
<li id="menu-item-50171" class="menu6 menu-item menu-item-type-custom menu-item-object-custom menu-item-50171"><a href="https://www.schneier.com/talks/">Talks</a></li>
<li id="menu-item-50167" class="menu7 menu-item menu-item-type-post_type menu-item-object-page menu-item-50167"><a href="https://www.schneier.com/academic/">Academic</a></li>
<li id="menu-item-50174" class="menu8 menu-item menu-item-type-post_type menu-item-object-page menu-item-50174"><a href="https://www.schneier.com/blog/about/">About Me</a></li>
</ul></div>				</div>
			</nav>

			
<aside>
	<div class="sidebar" id="sidebar-one">
		<section><div class="sidesection widget widget_schneier_search" id="schneier_search-3"><h3>Search</h3>
<p class="small">
	<em>Powered by <a href="https://duckduckgo.com/">DuckDuckGo</a></em></p>

<form method="get" action="https://duckduckgo.com/">

	<input type="hidden" name="kh" value="1" /><!-- use https -->

	<input id="search" name="q" size="15" maxlength="255" />

	<input type="submit" value="Go" /><br>

	<input type="radio" name="sites" id="searchblog" value="www.schneier.com/blog" />
	<label for="searchblog">Blog</label>

	<input type="radio" name="sites" id="searchessays" value="www.schneier.com/essays" />
	<label for="searchessays">Essays</label>

	<input type="radio" name="sites" id="searchall" value="www.schneier.com" checked="" />
	<label for="searchall">Whole site</label>

</form>
</div></section><section><div class="sidesection widget widget_schneier_social" id="schneier_social-2"><h3>Subscribe</h3>
<div id="subscription-buttons">

	<a href="https://www.schneier.com/feed/atom"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/rss-32px.png" alt="Atom Feed" /></a><a href="https://www.facebook.com/bruce.schneier"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/facebook-32px.png" alt="Facebook" /></a><a href="https://twitter.com/schneierblog/"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/twitter-32px.png" alt="Twitter" /></a><a href="https://www.amazon.com/Schneier-on-Security/dp/B0053HDDWW/"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/kindle-32px.png" alt="Kindle" /></a><a href="https://www.schneier.com/crypto-gram"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/email-32px.png" alt="E-Mail Newsletter (Crypto-Gram)" /></a>
</div>
</div></section>	</div>
</aside>

			<div id="content">

				
		<p id="breadcrumbs">

			<a href="https://www.schneier.com">Home</a><a href="https://www.schneier.com/blog/archives/">Blog</a>		</p>

		
<article id="post-686" class="post-686 post type-post status-publish format-standard hentry category-uncategorized tag-computer-security tag-malware tag-trust tag-vulnerabilities">

	<div class="article">

		<h2 class="entry">Countering "Trusting Trust"</h2>
		<p>Way back in 1974, Paul Karger and Roger Schell discovered a devastating attack against computer systems.  Ken Thompson described it in his classic 1984 speech, &#8220;<a href=http://www.acm.org/classics/sep95/>Reflections on Trusting Trust</a>.&#8221;   Basically, an attacker changes a compiler binary to produce malicious versions of some programs, INCLUDING ITSELF. Once this is done, the attack perpetuates, essentially undetectably. Thompson demonstrated the attack in a devastating way: he subverted a compiler of an experimental victim, allowing Thompson to log in as root without using a password. The victim never noticed the attack, even when they disassembled the binaries &#8212; the compiler rigged the disassembler, too.</p>
<p>This attack has long been part of the lore of computer security, and everyone knows that there&#8217;s no defense.  And that makes <a href=http://www.acsa-admin.org/2005/abstracts/47.html>this paper</a> by David A. Wheeler so interesting.  It&#8217;s &#8220;Countering Trusting Trust through Diverse Double-Compiling,&#8221; and here&#8217;s the abstract:</p>
<blockquote><p>An Air Force evaluation of Multics, and Ken Thompson&#8217;s famous Turing award lecture &#8220;Reflections on Trusting Trust,&#8221; showed that compilers can be subverted to insert malicious Trojan horses into critical software, including themselves.  If this attack goes undetected, even complete analysis of a system&#8217;s source code will not find the malicious code that is running, and methods for detecting this particular attack are not widely known. This paper describes a practical technique, termed diverse double-compiling (DDC), that detects this attack and some unintended compiler defects as well. Simply recompile the purported source code twice: once with a second (trusted) compiler, and again using the result of the first compilation. If the result is bit-for-bit identical with the untrusted binary, then the source code accurately represents the binary. This technique has been mentioned informally, but its issues and ramifications have not been identified or discussed in a peer-reviewed work, nor has a public demonstration been made. This paper describes the technique, justifies it, describes how to overcome practical challenges, and demonstrates it.</p></blockquote>
<p>To see how this works, look at the attack.  In a simple form, the attacker modifies the compiler binary so that whenever some targeted security code like a password check is compiled, the compiler emits the attacker&#8217;s backdoor code in the executable.</p>
<p>Now, this would be easy to get around by just recompiling the compiler.  Since that will be done from time to time as bugs are fixed or features are added, a more robust form of of the attack adds a step:  Whenever the compiler is itself compiled, it emits the code to insert malicious code into various programs, including itself.</p>
<p>Assuming broadly that the compiler source is updated, but not completely rewritten, this attack is undetectable.</p>
<p>Wheeler explains how to defeat this more robust attack.  Suppose we have two completely independent compilers: A and T.  More specifically, we have source code S<sub>A</sub> of compiler A, and executable code E<sub>A</sub> and E<sub>T</sub>.  We want to determine if the binary of compiler A &#8212; E<sub>A</sub> &#8212; contains this trusting trust attack.</p>
<p>Here&#8217;s Wheeler&#8217;s trick:</p>
<p>Step 1: Compile S<sub>A</sub> with E<sub>A</sub>, yielding new executable X.</p>
<p>Step 2: Compile S<sub>A</sub> with E<sub>T</sub>, yielding new executable Y.</p>
<p>Since X and Y were generated by two different compilers, they should have different binary code but be functionally equivalent.  So far, so good.  Now:</p>
<p>Step 3: Compile S<sub>A</sub> with X, yielding new executable V.</p>
<p>Step 4: Compile S<sub>A</sub> with Y, yielding new executable W.</p>
<p>Since X and Y are functionally equivalent, V and W should be bit-for-bit equivalent.</p>
<p>And that&#8217;s how to detect the attack.  If E<sub>A</sub> is infected with the robust form of the attack, then X and Y will be functionally different.  And if X and Y are functionally different, then V and W will be bitwise different.  So all you have to do is to run a binary compare between V and W; if they&#8217;re different, then E<sub>A</sub> is infected.</p>
<p>Now you might read this and think: &#8220;What&#8217;s the big deal?  All I need to test if I have a trusted compiler is&#8230;another trusted compiler.  Isn&#8217;t it turtles all the way down?&#8221;</p>
<p>Not really.  You do have to trust a compiler, but you don&#8217;t have to know beforehand which one you must trust.  If you have the source code for compiler T, you can test it against compiler A.  Basically, you still have to have at least one executable compiler you trust.  But you don&#8217;t have to know which one you should start trusting.</p>
<p>And the definition of &#8220;trust&#8221; is much looser.  This countermeasure will only fail if both A and T are infected in exactly the same way.  The second compiler can be malicious; it just has to be malicious in some different way: i.e., it can&#8217;t have the same triggers and payloads of the first.  You can greatly increase the odds that the triggers/payloads are not identical by increasing diversity: using a compiler from a different era, on a different platform, without a common heritage, transforming the code, etc.</p>
<p>Also, the <i>only</i> thing compiler B has to do is compile the compiler-under-test.  It can be hideously slow, produce code that is hideously slow, or only work on a machine that hasn&#8217;t been produced in a decade.  You could create a compiler specifically for this task.  And if you&#8217;re <i>really</i> worried about &#8220;turtles all the way down,&#8221; you can write Compiler B yourself for a computer you built yourself from vacuum tubes that you made yourself.  Since Compiler B only has to occasionally recompile your &#8220;real&#8221; compiler, you can impose a lot of restrictions that you would never accept in a typical production-use compiler.  And you can periodically check Compiler B&#8217;s integrity using every other compiler out there.</p>
<p>For more detailed information, see Wheeler&#8217;s <a href="http://www.dwheeler.com/trusting-trust">website</a>.</p>
<p>Now, this technique only detects when the binary doesn&#8217;t match the source, so someone still needs to examine the compiler source code.  But now you only have to examine the source code (a much easier task), not the binary.</p>
<p>It&#8217;s interesting: the &#8220;trusting trust&#8221; attack has actually gotten easier over time, because compilers have gotten increasingly complex, giving attackers more places to hide their attacks.  Here&#8217;s how you can use a simpler compiler &#8212; that you can trust more &#8212; to act as a watchdog on the more sophisticated and more complex compiler. </p>

		
			<p class="entry-tags">
				<span class="tags-links">Tags: <a href="https://www.schneier.com/tag/computer-security/" rel="tag">computer security</a>, <a href="https://www.schneier.com/tag/malware/" rel="tag">malware</a>, <a href="https://www.schneier.com/tag/trust/" rel="tag">trust</a>, <a href="https://www.schneier.com/tag/vulnerabilities/" rel="tag">vulnerabilities</a></span>			</p>

		
		
		<p class="posted">
			<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html" rel="bookmark">Posted on January 23, 2006 at 6:19 AM</a>			•
			<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html#comments">74 Comments</a>		</p>

		<aside><div class="schneier-share share" data-uri="https://www.schneier.com/blog/archives/2006/01/countering_trus.html" data-title="Countering &quot;Trusting Trust&quot;" data-order="facebook twitter tumblr" data-social-share-privacy="true" /></aside>
	</div>

</article>


	<h3 id="comments">Comments</h3>

	
		<article class="comment even thread-even depth-1" id="comment-23057">

			<div class="comment by-gnu ">

				<p class="commentcredit">

					<span class="commenter">gnu</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23057">
						January 23, 2006 6:46 AM					</a>

				</p>

				<p>I made the experience that compiling the same source with the same compiler two times produces two diffrent binarys. That should make this test nearly impossible.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23058">

			<div class="comment by-jonathan ">

				<p class="commentcredit">

					<span class="commenter">Jonathan</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23058">
						January 23, 2006 6:49 AM					</a>

				</p>

				<p>I don&#8217;t buy it.</p>
<p>In order for the countermeasure to work, the infected compiler must be infected in such a way that it can detect the compilation of <em>any</em> other compiler.  IMO, this assumption is far too strong.</p>
<p>Isn&#8217;t it far more reasonable to make the assumption that the &#8220;trusting trust&#8221; malware can only detect the compilation of a compiler significantly similar to itself?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23059">

			<div class="comment by-jonathan ">

				<p class="commentcredit">

					<span class="commenter">Jonathan</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23059">
						January 23, 2006 6:52 AM					</a>

				</p>

				<p>@gnu: GCC&#8217;s &#8220;make bootstrap&#8221; actually does build itself with itself twice, in such a way that it can compare the two stages to be identical.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23060">

			<div class="comment by-davidg ">

				<p class="commentcredit">

					<span class="commenter">davidg</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23060">
						January 23, 2006 7:02 AM					</a>

				</p>

				<p>What if the two compilers were once (way back in their history) initially compiled with a common compiler?</p>
<p>This is quite common with bootstrapping &#8211; create an initial compiler using an off-the-shelf one.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23061">

			<div class="comment by-anonymous ">

				<p class="commentcredit">

					<span class="commenter">Anonymous</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23061">
						January 23, 2006 7:05 AM					</a>

				</p>

				<p>@gnu,</p>
<p>that&#8217;s not the point.  You are trying to check that RedHat&#8217;s GCC is correct according to the source (compiler A). The point is that compiler A compiled with compiler B should produce the same binary as compiler A delivered by RedHat.</p>
<p>or put another way</p>
<p>if</p>
<p>compilewith(compilewith(A,source),(source))<br />
== compilewith(compilewith(B,source),(source))</p>
<p>where compilewith(x,y) compiles y with compiler x,</p>
<p>Then there can only be an attack hidden in the binary A if the binary B is cooperating with A.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23062">

			<div class="comment by-aze ">

				<p class="commentcredit">

					<span class="commenter">Aze</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23062">
						January 23, 2006 7:07 AM					</a>

				</p>

				<p>anon post was me, and I should just add, of course,</p>
<p>s/Then there can only be an attack/Then there can only be a <em>trusting_trust_attack</em> /</p>
<p>It&#8217;s still possible to have lots of other direct attacks hidden in A or B.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23063">

			<div class="comment by-adam ">

				<p class="commentcredit">

					<span class="commenter">Adam</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23063">
						January 23, 2006 7:13 AM					</a>

				</p>

				<p>&#8220;Since X and Y were generated by two different compilers, they should have different source code but be functionally equivalent.&#8221;</p>
<p>Shouldn&#8217;t that be different binaries, rather than different source code?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23064">

			<div class="comment by-anonymous ">

				<p class="commentcredit">

					<span class="commenter">Anonymous</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23064">
						January 23, 2006 7:25 AM					</a>

				</p>

				<p>&#8220;Also, the only thing compiler B has to do is compile the compiler-under-test. It can be hideously slow, produce code that is hideously slow&#8221;</p>
<p>That is not correct. If B is producing a result that is &#8220;hideously slow&#8221;, as compared to A then the binary is different. You have to have the same optimizers to produce the same binary.</p>
<p>My guess is that you need to hand craft a disassembler/decompiler on trusted hardware and then test the suspect binary. The resulting source would then be hand inspected. If found to be clean it could then be used to test untrusted compilers. The new binary should match what was fed into the trusted decompiler.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23065">

			<div class="comment by-arl ">

				<p class="commentcredit">

					<span class="commenter">arl</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23065">
						January 23, 2006 7:32 AM					</a>

				</p>

				<p>Last anon was by me.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23066">

			<div class="comment by-paul-crowley ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.ciphergoth.org/' rel='external nofollow ugc' class='url'>Paul Crowley</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23066">
						January 23, 2006 7:33 AM					</a>

				</p>

				<p>This works so long as running the optimizing compiler twice over the same inputs produces the same outputs.  Sadly, this isn&#8217;t usually the case, but it can probably be arranged with suitable operating system tricks.</p>
<p>The anonymous comment &#8220;That is not correct&#8221; (<em>please</em> sign these comments, even if pseudonymously) is mistaken &#8211; read the description more carefully.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23067">

			<div class="comment by-d ">

				<p class="commentcredit">

					<span class="commenter">D</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23067">
						January 23, 2006 8:47 AM					</a>

				</p>

				<p>I&#8217;m thinking, under an Open Source UNIX (Linux, *BSD) on Intel processors, use GCC and Intel&#8217;s compilers to perform such comparisons.  The problem is that GCC&#8217;s engineers probably don&#8217;t think like Intel&#8217;s engineers and the compilers will produce different binaries anyway.</p>
<p>I suppose, however, the analyst can focus on the differences between the binaries rather than having to manually compare the entirety of both &#8212; still a daunting task.</p>
<p>I still don&#8217;t see this paper as providing a viable defense against the attack.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23068">

			<div class="comment by-ns ">

				<p class="commentcredit">

					<span class="commenter">NS</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23068">
						January 23, 2006 8:59 AM					</a>

				</p>

				<p>@ Jonathan</p>
<p>&#8220;In order for the countermeasure to work, the infected compiler must be infected in such a way that it can detect the compilation of <em>any</em> other compiler. IMO, this assumption is far too strong.</p>
<p>Isn&#8217;t it far more reasonable to make the assumption that the &#8220;trusting trust&#8221; malware can only detect the compilation of a compiler significantly similar to itself?&#8221;</p>
<p>Agreed. I&#8217;ve always thought that the significance of the &#8220;trusting trust&#8221; was perceived to be much greater than it really is.</p>
<p>I haven&#8217;t read Wheeler&#8217;s paper, but based on what others have written, it seems to have similarity to an idea I came up with in the late &#8217;90s.</p>
<p>I observed that in order for the &#8220;trusting trust&#8221; attack to work, the rigged compiler must be able to, perhaps just minimally, understand the semantics of the program under compilation. To detect the compilation of a compiler, maybe it can detect the presence of a login system call. It became obvious to me that such a compiler cannot possibly understand the semantics of all possible future programming languages, so it cannot intelligently detect and subvert programs that implement interpreted languages that have yet to be invented.</p>
<p>So if you implement a Java Virtual Machine, a P-code interpreter, or some other processor emulation, <em>and then</em> execute a compiler written in that interpreted language, I don&#8217;t see how the &#8220;trusting trust&#8221; attack could be successful.</p>
<p>I thought the idea must have been obvious to computer scientists &#8212; so much so that nobody bothered to write it up.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23069">

			<div class="comment by-fred-page ">

				<p class="commentcredit">

					<span class="commenter">Fred Page</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23069">
						January 23, 2006 9:05 AM					</a>

				</p>

				<p>@Paul<br />
  -If optimizations are a problem, turn them off. However, that does not appear to be a problem with the paper that&#8217;s referenced above; optimizations should be a non-issue.</p>
<p>@arl<br />
 &#8220;You have to have the same optimizers to produce the same binary.&#8221;<br />
 -This seems irrelevant for the above paper. Y !=X; They merely need functional equivalency.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23070">

			<div class="comment by-secure ">

				<p class="commentcredit">

					<span class="commenter">Secure</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23070">
						January 23, 2006 9:09 AM					</a>

				</p>

				<p>Another example why monocultures are bad: Imagine there would be only one compiler&#8230;</p>
<p>NS: &#8220;I thought the idea must have been obvious to computer scientists&#8221;</p>
<p>Yes, it is obvious, and it is more or less used all over the place. You compare a fingerprint over the phone to avoid man-in-the-middle attacks when exchanging public keys over a public network. You could even exchange the keys personally (write your own compiler). You can use operating systems on live-CDs to detect viruses on the harddisk without the viruses being able to interfere, and you can check the integrity of system files to detect rootkits.</p>
<p>The general pattern is: Use a second, trusted resource to check the integrity of the first.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23071">

			<div class="comment by-sul ">

				<p class="commentcredit">

					<span class="commenter">sul</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23071">
						January 23, 2006 9:10 AM					</a>

				</p>

				<p>this strikes me as a bit of a bandaid. At the end of the day should the actual executing object of the binary (kernel) be functioning as an audit point? Make the source and binary available to the kernel and have it randomly do a check on the validity of it (i.e. compile the source into a temp binary and compare)? This would also allow for the inclusion of a micro-compiler into the kernel and a check against the validity of the binary object&#8230;<br />
Step 2 would be obvious&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23072">

			<div class="comment by-fred-f ">

				<p class="commentcredit">

					<span class="commenter">Fred F.</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23072">
						January 23, 2006 9:15 AM					</a>

				</p>

				<p>I don&#8217;t agree that optimizations are a non-issue. They are a big issue. I mainly know about GCC but there are MANY options. For example one can make a binary that works on the all of the x86 processors or one optimized for the 586 family for example. There will be instructions used in this one that will not be in the first one. Then there is the obvious case of -Os optimizations where it will optimize for size, the file will be smaller than say a -O2 optimized binary. Add on top of that things like using the registers instead of the stack and you end up with very different results. I think this is more of academics not registering with the real world.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23073">

			<div class="comment by-denis-bider ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://denisbider.blogspot.com' rel='external nofollow ugc' class='url'>denis bider</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23073">
						January 23, 2006 9:18 AM					</a>

				</p>

				<p>This is a nice solution, but how can one rely on byte-wise comparison between two files on a machine that may contain a compromised compiler?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23074">

			<div class="comment by-denis-bider ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://denisbider.blogspot.com' rel='external nofollow ugc' class='url'>denis bider</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23074">
						January 23, 2006 9:30 AM					</a>

				</p>

				<p>If one plants you a rogue compiler binary, that binary doesn&#8217;t have to compile its own source code into another rogue compiler binary. Instead, it can generate a clean compiler binary as long as it has already compiled any system binaries (a) so that a vulnerability is introduced, and (b) so that the system will modify even a clean version of this compiler in-memory to repeat tasks (a) and (b) whenever compiling system binaries.</p>
<p>The rogue compiler binary can in fact be totally erased, and the compromised system will ensure it remains compromised by patching up even a clean compiler in-memory.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23075">

			<div class="comment by-paul ">

				<p class="commentcredit">

					<span class="commenter">paul</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23075">
						January 23, 2006 9:32 AM					</a>

				</p>

				<p>I&#8217;m still not sure about buying the &#8220;bit-for-bit identical&#8221; part of the argument. Even without the issue of optimization settings, it&#8217;s a given that compilers producing functionally equivalent code don&#8217;t necessarily produce bit-for-bit identical object code. Plenty of different machine-code sequences will give you the same result out the other end, either as a result of different register decisions, or of different coding of certain primitive operations, and so forth. There may be some limited language and OS choices for which this makes sense, but I don&#8217;t see how it would work in anything approaching wider practice.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23076">

			<div class="comment by-dan ">

				<p class="commentcredit">

					<span class="commenter">Dan</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23076">
						January 23, 2006 9:43 AM					</a>

				</p>

				<p>to all who think this method doesn&#8217;t work&#8230;</p>
<p>I think alot of people are missing the point.</p>
<ol>
<li>you have the source code of the compiler you don&#8217;t know whether to trust. (say GCC)</li>
<li>you have the compiler which you don&#8217;t know whether to trust (say GCC) and another compiler you don&#8217;t know whether to trust (say VC++)</li>
<li>now compile the GCC source with both GCC and visual studio. You will now have 2 new compilers, both GCC which behave in the same way but will have different binaries since they have been compiled by different compilers with different optimisations. But they will both be GCC compilers and so will create the same binaries when compiling the same source.</li>
<li>now compile the original GCC source with your two new GCC compilers, this should produce the same binary. If it produces different binaries then you know that there is a high chance that one of the original compilers (GCC or VC++) has a back door in it. If they produce the same binary, then either they are both non malicious, or they are both malicious in the exact same way (which we are guessing is relatively unlikely since they don&#8217;t share any of the same code)</li>
</ol>
<p>please say you understand now!</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23077">

			<div class="comment by-jim-hyslop ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.dreampossible.ca' rel='external nofollow ugc' class='url'>Jim Hyslop</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23077">
						January 23, 2006 9:48 AM					</a>

				</p>

				<p>Wheeler&#8217;s whole logic fails at this point: &#8220;Since X and Y are functionally equivalent, V and W should be bit-for-bit equivalent.&#8221;</p>
<p>As others have mentioned, optimizations could affect the result. Even if you turn off all optimizations, though, many C statements (assuming C is the languaged used, which seems a likely assumption) can be rendered in several different ways.</p>
<p>Suppose the compiler needs to cache a value temporarily, such as in an integer post-increment:</p>
<p>x++</p>
<p>The compiler can store the pre-incremented value of &#8216;x&#8217; in a register. Suppose compiler A uses register B, but compiler T uses register C. The two sequences are functionally identical, but the two programs fail Wheeler&#8217;s test because they are not bit-for-bit identical.</p>
<p>That&#8217;s just one example. There are dozens, if not hundreds, of areas where compiler writers have a choice of ways to generate code for a particular statement. For example, in a statement such as</p>
<p>someFunc(x++)</p>
<p>the compiler is free to choose whether to increment x before the call to someFunc, or after the call. Optimizations don&#8217;t enter the picture at all &#8211; it&#8217;s a design choice the compiler writers are allowed to make.</p>
<p>It seems to me the only way to defend against this attack is to use a generic binary editor (not a disassembler) and manually disassemble and reverse-engineer the program. You won&#8217;t have to do the whole program, just the portions vulnerable to the threat.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23078">

			<div class="comment by-philip ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.hellyer.net/' rel='external nofollow ugc' class='url'>philip</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23078">
						January 23, 2006 9:48 AM					</a>

				</p>

				<p>Aaargh!  Read the post, people.  Carefully.</p>
<p>To recap:<br />
&#8211; You have the Source for compiler A.<br />
&#8211; You compile this twice, once with compiler A, once with compiler B.<br />
&#8211; This gives you compilers X and Y, which are functionally equivalent (to each other and to A) but almost certainly not bit-for-bit identical.<br />
&#8211; Now compile the Source for A with X and with Y.<br />
&#8211; The results of <em>this second</em> round of compilation will be bit-for-bit identical <em>unless</em> A has recognized <em>its own</em> source code and inserted something special.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23079">

			<div class="comment by-nicholas-weaver ">

				<p class="commentcredit">

					<span class="commenter">Nicholas weaver</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23079">
						January 23, 2006 9:54 AM					</a>

				</p>

				<p>One possible glitch:</p>
<p>The compiler being compiled MUST BE deterministic.</p>
<p>If Simulated Annealing or another stochastic optimization technique is used anywhere, you must be able to specify a seed.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23080">

			<div class="comment by-secure ">

				<p class="commentcredit">

					<span class="commenter">Secure</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23080">
						January 23, 2006 9:56 AM					</a>

				</p>

				<p>&#8220;The results of <em>this second</em> round of compilation will be bit-for-bit identical <em>unless</em> A has recognized <em>its own</em> source code and inserted something special.&#8221;</p>
<p>And unless the compiler is non-deterministic and selects equivalent code-sequences based on a random number generator. Then you should drop it anyhow, no matter if it is manipulated or not.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23081">

			<div class="comment by-jim-hyslop ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.dreampossible.ca' rel='external nofollow ugc' class='url'>Jim Hyslop</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23081">
						January 23, 2006 9:59 AM					</a>

				</p>

				<p>@Dan: &#8220;3. now compile the GCC source with both GCC and visual studio. You will now have 2 new compilers, both GCC which behave in the same way but will have different binaries since they have been compiled by different compilers with different optimisations. But they will both be GCC compilers and so will create the same binaries when compiling the same source.&#8221;</p>
<p>Ah, that&#8217;s the step I missed. OK, I can see how Wheeler&#8217;s defense works now.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23082">

			<div class="comment by-markw ">

				<p class="commentcredit">

					<span class="commenter">MarkW</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23082">
						January 23, 2006 10:03 AM					</a>

				</p>

				<p>Very simple and clever. I&#8217;m astonished Ken Thompson didn&#8217;t know of this.</p>
<p>There is a small typo.</p>
<p>So all you have to do is to run a binary compare between U and V; if they&#8217;re different, then EA is infected.</p>
<p>should be</p>
<p>So all you have to do is to run a binary compare between V and W; if they&#8217;re different, then EA is infected.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23083">

			<div class="comment by-carlo-graziani ">

				<p class="commentcredit">

					<span class="commenter">Carlo Graziani</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23083">
						January 23, 2006 10:04 AM					</a>

				</p>

				<p>Two bits of evasive action which should also be checked concomitantly with Wheeler&#8217;s procedure:</p>
<p>(1) cmp, ls, stat, diff and friends are also very likely compromised on any machine that has been attacked with this level of meticulousness.  The bit-by-bit comparison should be carried out on another machine with known-good utilities, and if the files are transfered by ftp, scp, or NFS, those systems should be scrutinized with the greatest suspicion.  Probably the safest thing would be to disconnect the hard drive and connect it to the known-good machine.  Alternatively, a boot disk with a live cd (Knoppix, for example) would do nicely, and defend against the possibility that the kernel was also compromised.</p>
<p>(2) Compile and install are two different phases of the build.  A naive implementation of the Wheeler procedure would compare binaries built in the build directory.</p>
<p>It would be straightforward for the malicious code to build <em>two</em> binaries (which would, after all, only differ by a few modules containing the malicious payload), and present the innocent one for inspection in a Wheeler test.</p>
<p>When the system administrator is satisfied that the test is passed and types &#8220;make install&#8221;, the Makefile proceeds to install the infected binary, which was built in some obscure sub-directory with a misleading name.</p>
<p>Anyone who has ever had to read through a bowl of autoconf/automake/make spaghetti can imagine how easy it would be to obscure this additional layer of sneakiness.  Detection would require either an extremely experienced and clinically paranoid sysadmin, or some kind of automatic makefile analyzer imported from another machine.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23084">

			<div class="comment by-fred-page ">

				<p class="commentcredit">

					<span class="commenter">Fred Page</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23084">
						January 23, 2006 10:15 AM					</a>

				</p>

				<p>@Nicholas<br />
&#8220;The compiler being compiled MUST BE deterministic.&#8221;<br />
&#8211; Correct. The paper mentions this issue (briefly). In my personal opinion, a compiler that you intend to verify that can&#8217;t be made to be deterministic is one that you can&#8217;t trust.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23085">

			<div class="comment by-ari-heikkinen ">

				<p class="commentcredit">

					<span class="commenter">Ari Heikkinen</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23085">
						January 23, 2006 10:31 AM					</a>

				</p>

				<p>I&#8217;m just not sure what&#8217;s the point. If the attacker already has root access to your system he can do whatever he wants with the system. It&#8217;s just one possible attack (using &#8220;terrorists&#8221; analogy, it&#8217;s actually similar to trying to protect against certain &#8220;movie plot threats&#8221; as you put it).</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23086">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23086">
						January 23, 2006 10:40 AM					</a>

				</p>

				<p>@Dan</p>
<p>No, they might still be different&#8230;</p>
<p>The way GCC and MS compilers optomise will affect the way the GCC compilers are compiled (which you agree with).</p>
<p>This gets passed down to the way the CPU registers etc are used. I suspect that even though the resulting code compiled with the two GCCs may be functionaly equivalent, I suspect that they might still not be bit for bit equivalent, when optimisations are applied, as the optomised compilers could take a diferent paths based on their own register optimisations.</p>
<p>So I suspect you need to do a functional test not a diff on the binary, that&#8217;s going to be a whole lot harder but not impossible 🙂</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23087">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23087">
						January 23, 2006 10:40 AM					</a>

				</p>

				<p>Someone may have already said this&#8230;</p>
<p>&#8220;Since X and Y were generated by two different compilers, they should have different source code but be functionally equivalent.&#8221;</p>
<p>I think you mean &#8220;they should have binary differences&#8221;, since X and Y are binaries.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23088">

			<div class="comment by-andrew-prock ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://headsupclub.com/aprock' rel='external nofollow ugc' class='url'>Andrew Prock</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23088">
						January 23, 2006 10:41 AM					</a>

				</p>

				<p>I saw it mentioned in the text of the explanation, and alluded to in some of the comments, but the real problem with this method is that it assumes independence of compilers.</p>
<p>Given that you&#8217;ve been compromised, and that you&#8217;ve been compromised by an attack with this level of sophistocation, you may have a hard time getting your hands on an independent compiler.  That is, a compiler which doesn&#8217;t have the same backdoor.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23089">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23089">
						January 23, 2006 10:51 AM					</a>

				</p>

				<p>Clive, let&#8217;s be clear. Are you saying that X and Y will not be bit-for-bit equivalent, or are you saying that V and W will not be? Since X and Y are functionally equivalent (let&#8217;s say they&#8217;re deterministic), they should produce the same output given the same input, period. X and Y are both given the same source to produce V and W, so V and W should be the same.</p>
<p>No differences in the way that CPU registers are used in X and Y could affect their output such that V and W would have different binaries, unless one of the compilers that produced X and Y had a bug.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23090">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23090">
						January 23, 2006 11:30 AM					</a>

				</p>

				<p>@pdf23ds</p>
<p>As far as the compiler goes they should produce functionaly identical intermediate code.</p>
<p>When you move to producing the machine code output (ASM / GAS) it can order any number of asembler instructions in different orders and make no difference what so ever to the functionality of the code or for that mater it&#8217;s execution speed under most circumstances. However occasionaly it will affect the use of a branch or jump statment. This is a given with asembler level programers who can had optomise different branch/jump instructions etc. and can often save quite a few bytes in loops etc.</p>
<p>Also with the Intel platform it is also known that various differnet assembler instructions produce the same results. It is up to the compiler which it picks (it is known that atleast one asembler developer used this to put a watermark on code produced by his assembler).</p>
<p>However the use of the registers can and does affect the way the code executes and unless the original source code nails it all down then the usage may well be different in your two end GCC tool chains. You can see this by looking at the different ways the MS and GCC compilers deal with setting up the stack frame etc..</p>
<p>This then affects what happens at the asembler, which may well optomise to differnet instructions that are functionaly equivalent.</p>
<p>The result is functionaly identical code but with different bit patterns.</p>
<p>If this will happen in practice I do not know but there is sufficient degrees of fredom to allow it to happen.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23091">

			<div class="comment by-arl ">

				<p class="commentcredit">

					<span class="commenter">arl</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23091">
						January 23, 2006 11:48 AM					</a>

				</p>

				<p>@Paul Crowley</p>
<p>We cross posted after I noticed I forgot to include my sig on the first post.</p>
<p>I see my mistake now, I thought &#8220;slow&#8221; was talking about the object emitted from B, not B itself.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23092">

			<div class="comment by-eric-blom ">

				<p class="commentcredit">

					<span class="commenter">Eric Blom</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23092">
						January 23, 2006 12:10 PM					</a>

				</p>

				<p>Ari,</p>
<p>I&#8217;d say you&#8217;re right this would not be a worthwile exercise for most people; presumably someone has already done this, for instance, with the OpenBSD compiler binaries. But I&#8217;d imagine it would be a very important exercise for programmers compiling security-critical code, like encryption programs. There is still the problem that a very clever and motivated person could affect the compiler binaries of multiple compilers to affect output the same way, but this seems unlikely.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23093">

			<div class="comment by-gauss ">

				<p class="commentcredit">

					<span class="commenter">Gauss</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23093">
						January 23, 2006 12:26 PM					</a>

				</p>

				<p>@Clive</p>
<p>All the optimizations and instruction options you describe are still done deterministically.  If they were done non-deterministically, then identical input to that compiler would not produce the same output twice in a row.  By &#8220;identical input&#8221; I mean both the source code AND the command-line options AND any other state-representing config-files the compiler program is using.</p>
<p>If a compiler, or more properly a compilation process, uses additional programs, such as an external assembler program, then those also have to be included in the double-compilation trust-checks.  Presumably, the same criteria apply: the assembler (or linker or whatever) is deterministic and produces the same output for a given set of inputs (and &#8220;inputs&#8221; again includes source, options, and all other configurable state).</p>
<p>Under those deterministic conditions, if there is any difference in the final binaries, compared bit-for-bit, then there is no alternative explanation for that difference than that one compiler is changing the code.  Whether it&#8217;s doing it because it&#8217;s malicious or because it&#8217;s picking register assignments, binary instructions, etc. using a non-deterministic algorithm doesn&#8217;t matter.  The factual outcome is that two outputs that should be identical are not, and at least one of the compilation chains is defective.</p>
<p>I am, of course, assuming that non-deterministic algorithms are considered to be a defect in this situation.  Although the algorithms for choosing registers, instructions, etc. do vary across tools, I know of no tools that actually use non-deterministic algorithms in order to assign registers, pick binary instructions, etc.  Furthermore, I know of no reason to use such algorithms in those cases, so the chance of them appearing as some future optimization is slim.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23094">

			<div class="comment by-fortinbras ">

				<p class="commentcredit">

					<span class="commenter">Fortinbras</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23094">
						January 23, 2006 12:37 PM					</a>

				</p>

				<p>@NS</p>
<p>I recall similar strategies from even earlier.  Forth, in particular, is a very small language with a very small set of trusted op-codes (words).  So small, that in many cases the assembler or even the native binary is auditable.  Given that small trusted base, other words are defined, which either refer to the trusted words or create new native words.  The source for the native code is known, auditable, and presumably trusted.</p>
<p>I mention Forth in particular because it has been used off and on over the years in creating systems that can be audited &#8220;all the way down&#8221;.</p>
<p>What this double-compilation is doing is basically using a series of compilers as a simple &#8220;virtual machine&#8221;, or more specifically, two virtual machines, and confirming they produce identical outputs.  The &#8220;instruction set&#8221; of the virtual machine is limited to compiling a source language and options, but the arrangement is still confirming that two virtual machines have identical outputs.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23095">

			<div class="comment by-ryan-russell ">

				<p class="commentcredit">

					<span class="commenter">Ryan Russell</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23095">
						January 23, 2006 12:39 PM					</a>

				</p>

				<p>I think the disassembler bit was glossed over a bit too quickly.  If one were suspicious of one&#8217;s compiler output, I don&#8217;t think the change would survive unnoticed for long.  I&#8217;ve probably got half a dozen disassembler lying around, and that&#8217;s not counting any I write myself, or doing it by hand.</p>
<p>I believe much of the original idea was from a time when you were in a captive environment on a single system.  I believe rootkits have obsoleted this attack in that situation some time ago.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23096">

			<div class="comment by-secure ">

				<p class="commentcredit">

					<span class="commenter">Secure</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23096">
						January 23, 2006 12:43 PM					</a>

				</p>

				<p>The only difference that could occur even for deterministic compilers are timestamps  derived from the current system time &#8211; even if you modify the timer it should be hard to catch the exact millisecond the timer is accessed. Thus there could be some small differences &#8211; just not big enough to contain a complete infection engine including a compile-myself detection system.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23097">

			<div class="comment by-nyarly ">

				<p class="commentcredit">

					<span class="commenter">Nyarly</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23097">
						January 23, 2006 12:53 PM					</a>

				</p>

				<p>This is quite an interesting procedural suggestion, as well as valid as far as it goes.</p>
<p>In terms of practical application, complexity rapidly abounds.  Ultimately, you can only trust the compilation mode that you test.  So each unique set of optimization techniques should essentially be treated as it&#8217;s own compiler.  Likewise each possible seed for a non-deterministic compiler needs to be treated as a it&#8217;s own compiler.  Likewise each compilation platform.  A malicious compiler might be rigged only to insert it&#8217;s backdoors under certain circumstances &#8211; like -O3, or in non-deterministic mode without a chosen seed.</p>
<p>It seems that if one were to want to use Wheeler&#8217;s method in securing a system, then a) you&#8217;d want two clean-room-level unrelated compilers that you have source to.  b) Subject both compilers to Wheeler&#8217;s test.  c) Perform all comparisons of result binaries with two unrelated programs compiled from source with  both compilers under test &#8211; total of 8 compares.  d)Perform the whole test under unrelated (hah!) OSes &#8211; because if the kernel is rigged, nothing is trustworthy.</p>
<p>Now, if both compilers, both comparators, and both kernels are all benign or all malicious in the same way, the ultimate result will be a pass.  If any are differently malicious, the result will fail.  Once you have a pass, though, keep in mind that each compiler is only trustworthy in the mode it was used in the tests.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23098">

			<div class="comment by-joe-buck ">

				<p class="commentcredit">

					<span class="commenter">Joe Buck</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23098">
						January 23, 2006 1:02 PM					</a>

				</p>

				<p>It&#8217;s not difficult to determine whether or not Red Hat&#8217;s compiler has been subverted.</p>
<p>During the bootstrap process GCC is built three times.  In stage 1, it is built by some arbitrary compiler.  In stage 2, the compiler is built again, this time with optimization enabled, by the compiler built from stage 1.  Finally, in stage 3, the compiler is built a third time, using the compiler built from stage 2.  Now the generated object files are compared, and the object code produced in stage 2 must be bit-for-bit identical with the object code produced in stage 3. This is to test that the compiler correctly builds itself.</p>
<p>First, to test that Red Hat builds their compiler from the supplied source, download their source RPM package, build it, and compare the object code to their binary RPM package.</p>
<p>Next, download the free-30-day-trial version of Intel&#8217;s ICC and repeat. When again everything works, you know that either Red Hat is clean or Intel has been subverted. Then you can build a cross-compiler starting from Sun Solaris, and test their compiler.  Or you could use a 7-year-old GCC version. You will quickly conclude that either there is no Thompson hack, or every compiler in the known universe has been corrupted.</p>
<p>Then, when you think about the problem of creating a Thompson hack that can affect every known compiler, you&#8217;ll quickly see the difficulty; the code that the compiler must recognize to do its magic has changed radically over time.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23099">

			<div class="comment by-nevin ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://bitsowit.blogspot.com' rel='external nofollow ugc' class='url'>Nevin &quot;:-)&quot;</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23099">
						January 23, 2006 1:54 PM					</a>

				</p>

				<p>One of the underlying assumptions is that the same compiler run over the same source code will result in a reproducible build.</p>
<p>There are language features which make this impossible.  As an example, here is a trivial case in C:</p>
<p>#include<br />
int main() {<br />
    printf(&#8220;I was compiled on %s\n&#8221;, <strong>DATE</strong>);<br />
}</p>
<p>And that is one of the easy cases to find&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23100">

			<div class="comment by-nevin ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://bitsowit.blogspot.com' rel='external nofollow ugc' class='url'>Nevin &quot;:-)&quot;</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23100">
						January 23, 2006 1:58 PM					</a>

				</p>

				<p>In my above posting, I stated &#8220;the same compiler run over the same source code&#8221;.  A compiler built by two separate compilers also exhibits this issue.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23101">

			<div class="comment by-nevin ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://bitsowit.blogspot.com' rel='external nofollow ugc' class='url'>Nevin &quot;:-)&quot;</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23101">
						January 23, 2006 1:58 PM					</a>

				</p>

				<p>In my above posting, I stated &#8220;the same compiler run over the same source code&#8221;.  Two versions of the same compiler (themselves built by two separate compilers) also exhibits this issue.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23102">

			<div class="comment by-anonymous ">

				<p class="commentcredit">

					<span class="commenter">Anonymous</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23102">
						January 23, 2006 2:22 PM					</a>

				</p>

				<p>Is there any evidence that such an attack has ever been realized?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23103">

			<div class="comment by-secure ">

				<p class="commentcredit">

					<span class="commenter">Secure</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23103">
						January 23, 2006 3:33 PM					</a>

				</p>

				<p>&#8220;Is there any evidence that such an attack has ever been realized?&#8221;</p>
<p>If there is no evidence it could either mean that there never was such an attack &#8211; or it could mean the attack was successful and is still undiscovered.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23104">

			<div class="comment by-smoke ">

				<p class="commentcredit">

					<span class="commenter">Smoke</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23104">
						January 23, 2006 7:15 PM					</a>

				</p>

				<p>@Secure</p>
<p>&#8220;If there is no evidence it could either mean that there never was such an attack &#8211; or it could mean the attack was successful and is still undiscovered.&#8221;</p>
<p>Or it could mean there was an attack, it was discovered and remedied, but it was felt better not to reveal that such an attack had been discovered.</p>
<p>Discretion is the better part of valor.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23105">

			<div class="comment by-anonymous-coward ">

				<p class="commentcredit">

					<span class="commenter">Anonymous Coward</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23105">
						January 24, 2006 12:19 AM					</a>

				</p>

				<p>I know I&#8217;m picky, but wow! Such a long<br />
article for laying out such a simple<br />
concept.</p>
<p>Maybe it is newsworthy that someone<br />
took this idea and formalized it. But<br />
then on the other hand, finding the<br />
&#8220;bad ones&#8221; by compaing it against<br />
the &#8220;other/good ones&#8221; is what I do<br />
each week in the supermarket to get<br />
the good fruits. The &#8220;trusted&#8221; or &#8220;good&#8221;<br />
fruit is then in my mental picture.</p>
<p>just my 2 cents</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23106">

			<div class="comment by-false-data ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://dsgazette.blogspot.com' rel='external nofollow ugc' class='url'>False Data</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23106">
						January 24, 2006 12:41 AM					</a>

				</p>

				<p>Interesting technique. From a practical standpoint, though, has anyone tried to compile, say, GCC using a non-GCC compiler and non-GNU toolset? I would not be too surprised to learn that compilers drift from strict language standards over time, especially given a compiler&#8217;s greater-than-normal need to work with the underlying hardware.</p>
<p>Since file comparison tools would be a natural target to compromise, you might need to use a non-standard comparison tool that&#8217;s simple enough to audit, and compile a copy with each compiler. Presumably the tool would also know enough about the binary&#8217;s format to skip obvious red herrings like embedded timestamps.</p>
<p>Finally, given the size and complexity of a modern compiler, the risk of the compromise being buried somewhere in the sources rather than the binary is probably increasing over time. We&#8217;ve come a long way from the smallc compiler.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23107">

			<div class="comment by-richard-veryard ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.dontpanic-ii.org/trustblog/blogger.html' rel='external nofollow ugc' class='url'>Richard Veryard</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23107">
						January 24, 2006 2:59 AM					</a>

				</p>

				<p>A similar pattern arises in social trust. A relies on the &#8220;fact&#8221; that B and C are unable to collaborate against A. This pattern is often found in international relations, where A, B and C are countries.</p>
<p>Even if the pattern isn&#8217;t absolutely reliable, it may still be worth having if it increases the level of trust.</p>
<p>This raises the question of the algebra of trust &#8211; how do we get higher levels of trust by composing heterogeneous elements &#8211; the opposite of the &#8220;weakest link&#8221; principle?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23108">

			<div class="comment by-ari-heikkinen ">

				<p class="commentcredit">

					<span class="commenter">Ari Heikkinen</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23108">
						January 24, 2006 3:23 AM					</a>

				</p>

				<p>I think this whole discussion is also wrong from the standpoint that a compiler don&#8217;t generate binaries. A compiler generates assembly. An assembler generates objects. A linker generates the final binary (this is how it&#8217;s generally done). Now, even though you use how many compilers as you like from whatever sources or where-ever systems, if you run them on the compromised system and the linker (which the compiler binaries then run on the compromised system) always adds the attack code at the same place (say at the beginning with the startup) this check proposed would be useless. All the binaries and all the compiled (and assembled) objects would always match even with the attack code inserted.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23109">

			<div class="comment by-nix ">

				<p class="commentcredit">

					<span class="commenter">Nix</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23109">
						January 24, 2006 4:30 AM					</a>

				</p>

				<p>The ability to compile GCC using a non-GCC ISO C compiler and non-GNU toolset is part of the release criteria for GCC, and is regularly tested. (You <em>do</em> need GNU make, but you can build that using whatever compiler you like, as well.)</p>
<p>If this property wasn&#8217;t maintained (and wasn&#8217;t maintained for GNU binutils, GNU make, and GNU sed as well) then it would be impossible to bootstrap the GNU toolchain from a foreign system. This is obviously undesirable.</p>
<p>Ari: Wheeler discusses the &#8216;compromised other binaries&#8217; point, and the fix is trivial: consider the assembler, linker et al part of the &#8216;compiler&#8217; whose integrity you must test. (This means that you&#8217;d need a trusted assembler, linker et al, too.)</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23110">

			<div class="comment by-aikimark ">

				<p class="commentcredit">

					<span class="commenter">aikimark</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23110">
						January 24, 2006 5:58 AM					</a>

				</p>

				<p>Wheeler&#8217;s technique seems like a lot more work than is necessary.  It would be MUCH SIMPLER for the trusted source to produce a decent hash (SHA-512) for folks to use as a comparison against their compiler executables.</p>
<p>One could also compare hash values at the source code level.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23111">

			<div class="comment by-david-thomas ">

				<p class="commentcredit">

					<span class="commenter">David Thomas</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23111">
						January 24, 2006 6:03 AM					</a>

				</p>

				<p>The only thing here that I could see being a problem is if any part of compiler in question is nondeterministic to the source-code, either using poorly defined language constructs or pseudo-randomness.  Of course, differences produced may well be limited enough that they can themselves be examined by hand&#8230;</p>
<p>To those who have a problem with the &#8220;bit for bit identical&#8221; (and, perhaps, reading comprehension&#8230;), you are not producing code to be compared on two different compilers, but on two different compiles of the same compiler.  Modulo what was mentioned above, the functional equivalence of these two compiles establishes the bitwise equivalence of their output.</p>
<p>And point the last, most interestingly this countermeasure <em>does not</em> require a trusted compiler &#8211; two compilers can be checked against each other assuming you can reasonably trust that there was no cross-contamination.  Two attacks are quite unlikely to take precisely the same form, and will otherwise be found.  Of course, you cannot then tell which of the tested compilers is bad without inspecting the code produced.  It does require a trusted diff, but it is significantly easier to verify the bytecode of a simplistic diff program than of a compiler.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23112">

			<div class="comment by-nix ">

				<p class="commentcredit">

					<span class="commenter">Nix</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23112">
						January 24, 2006 6:08 AM					</a>

				</p>

				<p>The trusted source can&#8217;t do that, because it isn&#8217;t a known non-malicious version of the compiler under test: it&#8217;s a <em>completely different program</em>. Its <em>only</em> necessary property is that it takes the source of the compiler under test (which is, remember, innocuous: it&#8217;s the <em>binary</em> that&#8217;s been subverted), and produces a compiler from it which has the same <em>semantic</em> effects as the original.</p>
<p>Again: the trusted compiler is not necessarily a version of the compiler under test (in fact, it&#8217;s better that it isn&#8217;t). It is not a program that produces the same bitwise output for any input that the compiler under test does. It <em>just</em> has to be able to produce a working compiler binary with the same semantics as those of the compiler under test given the source of the compiler under test. That compiler binary will not contain the trusting-trust attack, because it wasn&#8217;t produced by the subverted binary: but it won&#8217;t be bitwise identical to the original compiler, because it was produced by a different compiler with different optimizers (or none!)</p>
<p>The trick is to recompile the source of the compiler under test <em>with the binary which was itself produced by the trusted compiler</em>. As long as the compiler under test is deterministic and nonsubverted, you&#8217;ll get exactly the same output from that step as you do from compiling the trusted compiler with itself.</p>
<p>And <em>that</em> is what we&#8217;re checking for. (And Wheeler puts it more clearly than that in his paper. Read it!)</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23113">

			<div class="comment by-david-thomas ">

				<p class="commentcredit">

					<span class="commenter">David Thomas</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23113">
						January 24, 2006 6:16 AM					</a>

				</p>

				<p>&#8220;In terms of practical application, complexity rapidly abounds. Ultimately, you can only trust the compilation mode that you test. So each unique set of optimization techniques should essentially be treated as it&#8217;s own compiler. Likewise each possible seed for a non-deterministic compiler needs to be treated as a it&#8217;s own compiler. Likewise each compilation platform. A malicious compiler might be rigged only to insert it&#8217;s backdoors under certain circumstances &#8211; like -O3, or in non-deterministic mode without a chosen seed.&#8221;</p>
<p>Think of it as a method of obtaining a compiler that you are certain is built from the source.  Presuming  you can be sufficiently certain that the source itself is correct, the final result here is now a functioning compiler in all it&#8217;s glory, and does not require further testing or examination regarding whether it conforms to the source &#8211; doesn&#8217;t matter the options or architecture it is then applied to.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23114">

			<div class="comment by-marko ">

				<p class="commentcredit">

					<span class="commenter">Marko</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23114">
						January 24, 2006 6:59 AM					</a>

				</p>

				<p>My comment. If crack are able to crack exe files of several programs without ever knowing the siurcecode, then it would be possible to detect anomalies in the behaviour of a program, which was compiled using a malicious compiler.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23115">

			<div class="comment by-andy ">

				<p class="commentcredit">

					<span class="commenter">Andy</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23115">
						January 24, 2006 7:27 AM					</a>

				</p>

				<p>So, we&#8217;ve verified the compiler. Now we need to verify the linker and the loader, to make sure they&#8217;re not adding their own little bits. And the filesystem drivers, too.</p>
<p>Next comes the microcode in the processors. Makes a good argument for RISC, no?</p>
<p>What about the firmware in the disk interfaces? The BIOS or equivalent?</p>
<p>Oh-oh. What did Apple put in my iPod? RIM? Palm? The printer manufacturers? And, what&#8217;s really running in that router, proxy, and firewall?</p>
<p>Can&#8217;t we just all switch from MD5 to SHA1 and pretend it&#8217;s all okay?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23116">

			<div class="comment by-ari-heikkinen ">

				<p class="commentcredit">

					<span class="commenter">Ari Heikkinen</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23116">
						January 24, 2006 7:47 AM					</a>

				</p>

				<p>As my final comment, as far as practicality goes, this just seems too much hassle to me. Like someone else already suggested, taking sums (pick anything considered reasonably secure) of the system files you&#8217;re concerned with and checking them would seem much more practical to me.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23117">

			<div class="comment by-aze ">

				<p class="commentcredit">

					<span class="commenter">Aze</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23117">
						January 24, 2006 10:15 AM					</a>

				</p>

				<p>@Nevin &#8220;:-)&#8221;</p>
<p>by manipulating system call results, it&#8217;s also possible to allow this.  For example, we could replace time(2) with a call that always returns 42 or returns a monotonically increasing sequence of integers increasing by one for each call.</p>
<p>@Ari</p>
<p>Check sums are completely useless against such an attack.  Your checksums will be against an already compromised binary.   You are lucky, however, all you need to know is that <em>someone</em> does this on your compiler and you can know that you are safer..   In fact, the mere threat that they might is a deterrent.</p>
<p>On your earlier post; the word &#8220;compiler&#8221; is being used in a simplified form.  The compiler is (should be) really a complete system including computer and all programs needed and a CDR drive.</p>
<p>You create a big bunch of CDR(not W)s with source code.  You compile on the &#8220;compiler&#8221; and generate a CDR with your binary.  Really paranoid people build an entire minimalist operating system and treat that as the &#8220;compiler&#8221;</p>
<p>@ALL</p>
<p>I don&#8217;t think anyone has stated the )really (<em>really_REALLY</em>) important point about this.</p>
<p>Until now, us Free Software fanatics claim to be &#8220;fundamentally more secure&#8221; could be laughed at by saying that, somewhere in their history, they used a proprietary compiler and so it&#8217;s possible that all their systems were compromised.  The &#8220;only&#8221; difference was the amount of proprietary code that we trusted.  KT himself said &#8220;No amount of source-level verification or scrutiny will protect you from using untrusted code.&#8221;</p>
<p>Now it&#8217;s possible to say that we have a higher level of trust.  The source code really can tell you what the system does&#8230;  Note that this benefit only really applies to 100% clean, no proprietry software, systems.  It also only applies as long as you fully audit the hardware or use multiple different, independently produced computers for each calculatoin.  :-).</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23118">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23118">
						January 25, 2006 4:38 AM					</a>

				</p>

				<p>@Gauss  @pdf23ds</p>
<p>Gauss, you are correct in that if all inputs are identical, and all algorithums are determanistic (and probably also single threaded) then the output should be the same.</p>
<p>THe exception to this is unless some one writing part of the tool chain has deliberatly decided to put some kind of watermark in the system which can identify the machine etc. I know this might sound paranoid but it is known that a shareware asembler did indead watermark the binary output, and it is also known that MS Word in Office 97 put the MAC address of the machine in it&#8217;s files.</p>
<p>However it was a posting about the use of the MS compiler that reminded me of a company I was working at some time ago.</p>
<p>Basically they developed embeded controler devices using Arm processors and various applications running on them.</p>
<p>They used the GNU tool-chain on Intel desktops to do the cross compiling. The toolchain was compiled from scratch on the desktops as it was being used for cross compiling.</p>
<p>Some of the engineers used MS desktops and others used GNU/linux, therfore some used the MS product for the tool-chain compile others used the GCC. As development progressed more of the tool chain was moved onto the target proccessor.</p>
<p>During regression testing they did indead find that binaries did differ depending on the desktop used. Which obviously caused some concern at the time. From what I was told the differences where small and appeared to be a re-ordering of code segments, where functionalty was not effected.</p>
<p>They used VMware as a tempory work around,I know they where investigating the problem however as I was on contract on another project that finished I did not find out if they fully got to the bottom of it.</p>
<p>The lesson I took from it at the time was &#8220;everybody on a project should use the same tool chain&#8221;. Which is the oposit advice of David Wheeler&#8217;s work.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23119">

			<div class="comment by-david-a-wheeler ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.dwheeler.com' rel='external nofollow ugc' class='url'>David A. Wheeler</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23119">
						January 27, 2006 12:18 PM					</a>

				</p>

				<p>Hi, I&#8217;m the author of the &#8220;Countering Trusting Trust&#8230;&#8221; paper, and I&#8217;m delighted to see so many people discussing it!!  Some of the questions or comments are answered by the paper or my website, so let me point you to some of the answers.</p>
<p>gnu said: &#8220;I made the experience that compiling the same source with the same compiler two times produces two diffrent binarys. That should make this test nearly impossible.&#8221;</p>
<p>This is nondeterminism, which can be easily handled or not depending on WHY the nondeterminism happens.  Timestamps are usually handled easily.  If the variation depends on a random number generator, you need control of the random number generator&#8217;s seed, but that&#8217;s not weird &#8212; gcc ALREADY has an option to control the random number seed, for example.    Some compilers, like gcc, include the check for determinism as one of their tests for validity.  In gcc it&#8217;s &#8220;make bootstrap&#8221;, and Fedora Core&#8217;s rpmbuild routinely does a &#8220;make bootstrap&#8221; as part of the compiler build &#8212; so having a deterministic compiler is NOT an unusual circumstance. See the start of section 7 of the paper &#8211; many people believe uncontrolled nondeterminism is a bug ANYWAY, because it makes testing nearly impossible.</p>
<p>Clive Robinson observed:  &#8220;The exception to this is unless some one writing part of the tool chain has deliberatly decided to put some kind of watermark in the system which can identify the machine etc&#8230; a shareware asembler did indead watermark the binary output&#8230;&#8221; and later on noted some differences based on environments in some cases.</p>
<p>Yes, clearly if the toolchain is INTENTIONALLY inserting variations then they won&#8217;t have the same result.  But the process will detect that, in most cases in stage 0&#8230;. and you can see exactly what varies.  You might want to know that!</p>
<p>An Anon asked, &#8220;Is there any evidence that such an attack has ever been realized?&#8221;</p>
<p>Well, Thompson implemented it in 1984 and sent his malicious compiler to a sister Bell Labs unit.  His malicious compiler subverted the compiler, login program, and disassembler.  The victim even looked at disassemblies and never saw the attack!  Now it&#8217;s true that Thompson wasn&#8217;t malicious, but there&#8217;s every reason to believe that someone has tried it or will try it someday.  There are more people who like to attack computers (and have the technical skill to pull this off), the money value of attacking computers is much greater, and compilers are larger (making this easier to hide).  Section 3.1 discusses attacker motivations &#8212; with this attack, you could 0wn every computer in the world: the entire banking system, infrastructures, whatever you want.  And until now, it was undetectable. Think that might be worth something?  I don&#8217;t think people appreciate just how POWERFUL this attack is&#8230; you can subvert whole classes of systems, undetectably, and they stay subverted.</p>
<p>Smoke said: &#8220;finding the &#8220;bad ones&#8221; by comparing it against the &#8220;other/good ones&#8221; is what I do each week in the supermarket to get the good fruits.&#8221;</p>
<p>But how would you do that with a compiler?  Let&#8217;s say that you have a gcc binary and a Microsoft C compiler binary.  Which one has malicious code in it &#8211; do either of them?  How do you prove it?  In theory, you could read every object code byte &#8211; but they&#8217;d release a new version before you were done.  Trying to directly compare two different binaries created by two different compilers has been tried, but it&#8217;s a hairy-hard research project with no REAL solution.  This process finds the malicious code without requiring that.</p>
<p>Jonathan said:  &#8220;In order for the countermeasure to work, the infected compiler must be infected in such a way that it can detect the compilation of <em>any</em> other compiler. IMO, this assumption is far too strong. Isn&#8217;t it far more reasonable to make the assumption that the &#8220;trusting trust&#8221; malware can only detect the compilation of a compiler significantly similar to itself?&#8221;</p>
<p>Er, that&#8217;s backwards, if I understand you correctly.  The countermeasure will succeed UNLESS the trusted compiler is infected the same way.  The compiler under test doesn&#8217;t NEED to be infected in a way that it can detect the compilation of any other compiler, though it certainly could be, and it&#8217;s not even hard to do.  And as far as being &#8220;significantly similar&#8221;, there&#8217;s absolutely no reason that has to be true.  If you stood to make a billion dollars by controlling the worldwide banking system, you could probably find time to insert attacks against 5 compilers instead of just one.  The hardest part of the attack is getting started&#8230; once you&#8217;ve figured out how to attack one compiler, it&#8217;s all to easy to add more attacks :-(.</p>
<p>NS said: &#8220;in order for the &#8220;trusting trust&#8221; attack to work, the rigged compiler must be able to, perhaps just minimally, understand the semantics of the program under compilation&#8230;. such a compiler cannot possibly understand the semantics of all possible future programming languages, so it cannot intelligently detect and subvert programs that implement interpreted languages that have yet to be invented. So if you implement a Java Virtual Machine, a P-code interpreter, or some other processor emulation, <em>and then</em> execute a compiler written in that interpreted language, I don&#8217;t see how the &#8220;trusting trust&#8221; attack could be successful. I thought the idea must have been obvious to computer scientists &#8212; so much so that nobody bothered to write it up.&#8221;</p>
<p>That&#8217;s been written up; I cited the papers in the 1980s that suggest that very thing.  It&#8217;s not that the malicious code &#8220;understands&#8221;, they just need to match a pattern.  The idea is sound, but doesn&#8217;t help as much you might think.  So you execute a compiler in the interpreted language&#8230; every time? Not likely.  When you&#8217;re all done, you&#8217;ll compile it&#8230; and then I subvert THAT.  The problem is that you have no DETECTION technique, so you have no way to know when you need to try to counter it.  See section 2.2.  The idea of using interpreters is good though.. and in fact I suggest doing that very thing as part of the process.</p>
<p>Andy said: &#8220;So, we&#8217;ve verified the compiler. Now we need to verify the linker and the loader, to make sure they&#8217;re not adding their own little bits. And the filesystem drivers, too.&#8221;</p>
<p>Right.  And you do that by&#8230; compiling.  That&#8217;s all.  Sure, it&#8217;s millions of lines of code, but you don&#8217;t need to UNDERSTAND it, you just need to compile it twice and see if you get the original answer.  It might take overnight or longer to do the recompile twice, but so what, it&#8217;s just compute time &amp; compute time is cheap.  And when there&#8217;s a new binary release, you can do the double-recompile again.  Once you have a working setup, it should be fairly straightforward.  As long as it&#8217;s software (any level), AND you have the source code, you&#8217;re fine.</p>
<p>Several folks thought I meant that two different compilers would produce the same binaries.  Not so, that practically never happens.  It&#8217;s a common misperception, which I try to counter in both my paper and my website.</p>
<p>Aze said: &#8220;KT himself said &#8220;No amount of source-level verification or scrutiny will protect you from using untrusted code.&#8221;&#8230; Now it&#8217;s possible to say that we [Free-Libre software developers] have a higher level of trust. The source code really can tell you what the system does&#8230; Note that this benefit only really applies to 100% clean, no proprietry software, systems.&#8221;</p>
<p>You&#8217;ve got it: this is the only known test for the Trusting Trust attack, and it is only beneficial to people who have the source code.  With only a binary, you can&#8217;t use this test.</p>
<p>Aze said, &#8220;It also only applies as long as you fully audit the hardware&#8230;&#8221;</p>
<p>True, malicious hardware can subvert you even if the software is fine.  See my website at <a href="http://www.dwheeler.com/trusting-trust" rel="nofollow ugc">http://www.dwheeler.com/trusting-trust</a> &#8212; I believe you could even apply DDC to hardware.  Countering hardware is still hard, but I think countering the software problem is still an improvmenet.</p>
<p>One impossible problem at a time, okay :-)?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23120">

			<div class="comment by-digilife ">

				<p class="commentcredit">

					<span class="commenter">DigiLife</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23120">
						February 17, 2006 9:07 PM					</a>

				</p>

				<p>honeypots<br />
honeynets<br />
and coming soon &#8230;.<br />
honeycode!</p>
<p>a source code containing security code like password checks. it&#8217;s kept small and includes only what is necessary to cause itself to be infected. it doesnt actually have to be <em>usefully</em> functional&#8230;</p>
<p>and to analyze it, a live-cd with a decompiler and debugger. which of course have to be determined to be clean. still need a standalone computer for all this.</p>
<p>some pen-testing of any computer os compiled with an untrusted compiler may also be helpful if done from a computer os that can be trusted in it&#8217;s binary form.</p>
<p>seems the only way to stay clean is by starting clean. to do that a standalone that&#8217;s compiles the source for your compiler with a compiler you wrote in binary (ouch!!) could be needed&#8230;..think about it. which came first? the compiler or the source (was the source created by a binary editor program that was compiled?)? gotta start somewhere. can you be sure that where you are starting from is clean? (assuming you go back to a day prior to any recorded use of such an attack but after there were binary compilers already done).</p>
<p>if i  remember what i read somewhere else correctly, the first such attack was discovered with a clean compiler/decompiler/debugger that was obtained externally (compared to where the infected compiler came from). with that in mind there are archives of clean dev. env. on the internet as well as enough different compilers as to be able to detect such attacks in the future.</p>
<p>hopefully there will never be a worm that infects them all. something i doubt possible considerring the variety of platforms and operating systems (OS) and languages and compilers available in all thier versions with copies somewhere (old cd laying around?) in addition to being archived on the internet. this and some of those operating systems are more secure and harder to infect than others. this makes no mention of using hashes of course (due to off chance that hashes are not an accurate way of determining infection because either no 2 compiles are <em>that</em> identical or the infection doesnt have a &#8220;virus definition&#8221; yet or whatever theory you choose.)</p>
<p>i do suppose that the day may come when &#8220;trusted computing&#8221; advocates will make any computer that isn&#8217;t trusted computing compliant to become illegal to use or even posses. they would then buyout (as a hostile takeover of sorts) or shutdown everyone who produces a secure platform that doesn&#8217;t include trusted computing. ie: OpenBSD. that will be a sorry day for us all indeed. an Orwellian nightmare for sure. harder to prevent worm infection in your computer if your computer does not follow your orders and additionally tells on you.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23121">

			<div class="comment by-aikimark ">

				<p class="commentcredit">

					<span class="commenter">aikimark</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23121">
						February 23, 2006 3:49 PM					</a>

				</p>

				<p>Related paper on trusting and verifying executables.</p>
<p>WYSINWYX: What You See Is Not What You eXecute</p>
<p><a href="http://www.cs.wisc.edu/wpis/papers/wysinwyx05.pdf" rel="nofollow ugc">http://www.cs.wisc.edu/wpis/papers/wysinwyx05.pdf</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23123">

			<div class="comment by-opitezext ">

				<p class="commentcredit">

					<span class="commenter">OPITEZEXT</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23123">
						March 17, 2010 8:12 AM					</a>

				</p>

				<p>Todd Cowle Municipal Bond Credit Report synthesizes, analyzes and presents aggregate credit information and trends in the municipal bond market. The report includes municipal bond rating information from the three major rating agencies – Moody’s Investor Services, Standard and Poor’s and Fitch Ratings.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23126">

			<div class="comment by-paul ">

				<p class="commentcredit">

					<span class="commenter">Paul</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23126">
						November 30, 2015 9:41 PM					</a>

				</p>

				<p>So what if you also backdoor &#8220;cp&#8221; into recognizing when it&#8217;s working on one of the given utilities in the rootkit?</p>
<p>At a fundamental level, if you can&#8217;t trust your core toolset, the only option is a full nuke and reload from a trusted source.  And if you don&#8217;t trust your hardware isn&#8217;t lying to you, you need to nuke that too (down to the firmware level).</p>
<p>You can take mitigation steps like this one, but they don&#8217;t eliminate the threat, they only elevate it to the level of BadBios-style paranoia.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23127">

			<div class="comment by-fedes ">

				<p class="commentcredit">

					<span class="commenter">fedes</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23127">
						May 20, 2016 2:02 PM					</a>

				</p>

				<p>Sorry, this is a very old post, still I think I didn&#8217;t see this approach ever mentioned.<br />
This is what I&#8217;d call a <i>stochastic approach</i>:</p>
<ol>
<li>Make a sufficiently big number of copies of the binary compiler to check.</li>
<li>Randomly change a big enough number of bits on all of them. (All will be different)</li>
<li>Disasemble with your regular disassembler. The mutations of step 2 should make it hard for the disassembler+trojan recognize the trojan parts.</li>
<li>Statistically determine the disassembled shape of the original binary (I&#8217;m guessing this should be easy).</li>
</ol>
<p>The biggest problem is with disassembly of a <i>corrupt</i> binary. I&#8217;m not sure how that part works, but I&#8217;ve read somewhere how disassembling tends to &#8220;self-heal&#8221; (meaning that the disassembler may output trash for some bytes, but it ends up finding the right thing after a while).</p>
<p>If you ever try this and works, you can buy me a beer!</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23128">

			<div class="comment by-chad-m ">

				<p class="commentcredit">

					<span class="commenter">Chad M</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23128">
						June 10, 2016 9:57 AM					</a>

				</p>

				<p>Today it&#8217;s telemetry, tomorrow it&#8217;s&#8230;  what, exactly?</p>
<p><a href="https://www.infoq.com/news/2016/06/visual-cpp-telemetry" rel="nofollow ugc">Reviewing Microsoft&#8217;s Automatic Insertion of Telemetry into C++ Binaries&lt;/&gt;</p>
<p></a><a href="https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/" rel="nofollow ugc">Reddit</a></p>
<blockquote><p>
Recently Reddit user &#8220;sammiesdog&#8221; posted claims that Visual Studio&#8217;s C++ compiler was automatically adding function calls to Microsoft&#8217;s telemetry services.  The screenshot accompanying their post showed how a simple 5 line CPP file produced an assembly language file that included a function call titled  “telemetry_main_invoke_trigger”.
</p></blockquote>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23129">

			<div class="comment by-ianf ">

				<p class="commentcredit">

					<span class="commenter">ianf</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23129">
						June 10, 2016 2:08 PM					</a>

				</p>

				<p>@ fedes,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interesting multi-step <a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html#c6724652" rel="nofollow ugc"><cite>stochastic approach</cite></a> of yours for validating purity of binaries [love then grown-up words]. You forgot to add an estimate of the time the outlined procedure is expected to take per stochastic validation session per kilobyte of decompiled binary. Calculate it, post here, I&#8217;ll think about it – no promises but, hey! you ought to know by now that expecting &#8220;the Internet&#8221; to test your hypotheses without a sexy Indiegogo/ equiv. video and AT LEAST bumper stickers in a tiered reward setup, is a non-starter.</p>
<p>@ Chad M ruminates on Microsoft&#8217;s plans for insertion into C++ binaries… “<cite><a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html#c6725981" rel="nofollow ugc">today it&#8217;s telemetry, tomorrow it&#8217;s&#8230; what, exactly</a>?</cite>”</p>
<p>Assuming they&#8217;ve already been there done that, there&#8217;d but be one avenue still open to them: grafting of <b>telepathometry</b> of course — that is, provided that boffins have ironed the self-reinserting randomly intermittent GOTCHACK::NOACK errors in the TTCP/IP Telepax® suite (sadly, the lead dev died last year, some say not entirely unassisted by those who&#8217;d rather keep this tech under wraps).</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23130">

			<div class="comment by-jim-dines ">

				<p class="commentcredit">

					<span class="commenter"><a href='https://jdines.net' rel='external nofollow ugc' class='url'>Jim Dines</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23130">
						May 27, 2017 5:23 AM					</a>

				</p>

				<p>There is <b>at least</b> one major flaw in this that nobody else seems to see. You need two compilers that can both compile the same source code successfully.  That is NEVER going to happen for anything as non-trivial as a compiler. One often can&#8217;t even get code to compile successfully with different versions of gcc! <i>(for example)</i> Thinking you will get Microsoft&#8217;s and GNU&#8217;s compilers to be able to do it simultaneously is a major cognitive distortion! 🙂</p>
<p>This is the problem with computer security today in my not so humble opinion. There is a boatload of this kind of <i>Trust us, this is possible because it happens in my mind</i> kind of security. If Wheeler or anyone else can provide some exploit code in the form of a Ken Thompson Reflections on Trust style compiler and actual <i>anti-exploit tools and procedures that prove it empirically when followed</i> then it is all just meaningless mental masturbation.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23131">

			<div class="comment by-russian-typewriters ">

				<p class="commentcredit">

					<span class="commenter">russian typewriters</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23131">
						September 11, 2017 3:18 AM					</a>

				</p>

				<p>Consider what Mr Thompson said:</p>
<p>&#8220;The moral is obvious. You can&#8217;t trust code that you did not totally create yourself. (Especially code from companies that employ people like me.) No amount of source-level verification or scrutiny will protect you from using untrusted code. In demonstrating the possibility of this kind of attack, I picked on the C compiler. I could have picked on any program-handling program such as an assembler, a loader, or even hardware microcode. As the level of program gets lower, these bugs will be harder and harder to detect. A well-installed microcode bug will be almost impossible to detect.&#8221;</p>
<p>Even a hardware CPU can be described as &#8220;code&#8221;. It really is turtles all the way down.</p>
<p>How are you going to trust your two compilers when you can&#8217;t really trust the hardware they run on? The hardware is all imported and could have multiple backdoors in it.</p>
<p>Pretty much no organization, company, or govt in the world takes software and data security seriously. They all say it is their top priority after they get cracked open but who can believe that.</p>
<p>Once the next war starts, all the computers and internets might suddenly become &#8220;enemy&#8221; and have to be turned off. This would have a drastic effect on most modern countries.</p>
<p>Russian govt now uses typewriters for stuff they don&#8217;t want other people to know. They simply don&#8217;t trust computers that much any more.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-23132">

			<div class="comment by-mos-ano-ni-mos ">

				<p class="commentcredit">

					<span class="commenter">mos ano ni mos</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23132">
						October 13, 2017 4:47 AM					</a>

				</p>

				<p>I remember this Russian typewriters news . This propagated in English language  news  mention they get set of &#8220;electric typewriters&#8221; . Why electric ? With possible backdoor? Perhaps because nobody manufacture mechanical ? Or it was kind of planted in news message (hope) we can get them either-way. It does not make sense and is just kind of wash like most of above discussion.</p>
<p>There is a way of having secure system &#8211; just abort parasites sucking people veins &#8211; to have trust by trusted sagacious society. But for this, in a country on his knees during the anthem is perhaps long way to dawn.</p>
<p>ps( see also Elbrus ru.made computers, chips &#8230; sand for silicon cant carry info viruses, at least not in my universe )</p>
<p>b) most probably the Thomson virus is more probably implemented in go golan g stolen land ,  mostsad as ziombie spook zbuk who promised to &#8220;Don&#8217;t be evil&#8221; and with growing bigger thour creed simply retrieved.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-23134">

			<div class="comment by-tim ">

				<p class="commentcredit">

					<span class="commenter">Tim</span> •

					<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/#comment-23134">
						February 12, 2020 1:35 PM					</a>

				</p>

				<p>I could not help but think of this article while reading this Washington Post article today.</p>
<p><a href="https://www.washingtonpost.com/graphics/2020/world/national-security/cia-crypto-encryption-machines-espionage/" rel="nofollow ugc">https://www.washingtonpost.com/graphics/2020/world/national-security/cia-crypto-encryption-machines-espionage/</a></p>
<p>I would guess this is still happening with software based crypto, and that there really isn&#8217;t unbroken crypto.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

	<p class="subscribe-comments">
		<a href="https://www.schneier.com/blog/archives/2006/01/countering_trus.html/feed/">
			<img alt="Atom Feed" src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/rss.png">
			Subscribe to comments on this entry		</a>
	</p>

		<div id="respond" class="comment-respond">
		<h2 class="comments-open-header">Leave a comment <small><a rel="nofollow" id="cancel-comment-reply-link" href="/blog/archives/2006/01/countering_trus.html#respond" style="display:none;">Cancel reply</a></small></h2><form action="https://www.schneier.com/wp-comments-post.php" method="post" id="commentform" class="comment-form" novalidate><a href="https://www.schneier.com/wp-login.php?redirect_to=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2006%2F01%2Fcountering_trus.html" title="Login">Login</a><p class="comment-form-author"><label for="author">Name</label> <input id="author" name="author" type="text" value="" size="30" maxlength="245" /></p>
<p class="comment-form-email"><label for="email">Email</label> <input id="email" name="email" type="email" value="" size="30" maxlength="100" /></p>
<p class="comment-form-url"><label for="url">URL:</label> <input id="url" name="url" type="url" value="" size="30" maxlength="200" /></p>
<p class="comment-form-cookies-consent"><input id="wp-comment-cookies-consent" name="wp-comment-cookies-consent" type="checkbox" value="yes" /> <label for="wp-comment-cookies-consent">Remember personal info?</label></p>

<p class="comment-form-author">

	<label for="comm_capt_challenge">
		Fill in the blank: the name of this blog is Schneier on ___________ (required):	</label>

	<input id="comm_capt_challenge" name="comm_capt_challenge" size="30" type="text" />
</p>

<div class="comment-form-comment">

	<label for="comment">Comments:</label>

	<textarea id="comment" name="comment" cols="45" rows="8" maxlength="65525" required="required"></textarea>

	<div id="preview-box" class="preview-box hide"></div>
	<img class="comment-loading hide" src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/loader.gif" />

</div>

<p id="allowed">

	<strong>Allowed HTML</strong>
	&lt;a href=&quot;URL&quot;&gt; &bull; &lt;em&gt; &lt;cite&gt; &lt;i&gt; &bull; &lt;strong&gt; &lt;b&gt; &bull; &lt;sub&gt; &lt;sup&gt; &bull; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &bull; &lt;blockquote&gt; &lt;pre&gt;
	<strong>Markdown Extra</strong> syntax via <a href="https://michelf.ca/projects/php-markdown/extra/">https://michelf.ca/projects/php-markdown/extra/</a>
</p>

<input type="hidden" id="wp_comment_nonce" name="wp_comment_nonce" value="4b1534b792" /><input type="hidden" name="_wp_http_referer" value="/blog/archives/2006/01/countering_trus.html" />
<input type="button" id="comment-preview" class="comment-preview comment-actions" value="Preview" />
<input type="button" id="comment-write" class="comment-write comment-actions hide" value="Edit" />

<p class="form-submit"><input name="submit" type="submit" id="submit" class="submit" value="Submit" /> <input type='hidden' name='comment_post_ID' value='686' id='comment_post_ID' />
<input type='hidden' name='comment_parent' id='comment_parent' value='0' />
</p></form>	</div><!-- #respond -->
	
	<div class="stepthrough">
		<a href="https://www.schneier.com/blog/archives/2006/01/friday_squid_bl_4.html" rel="prev">← Friday Squid Blogging: Poetry</a>		<a href="https://www.schneier.com/blog/archives/2006/01/reading_rfid_ca.html" rel="next">Reading RFID Cards at Yards Away →</a>	</div>

	
<p id="powered">Sidebar photo of Bruce Schneier by Joe MacInnis.</p>
		</div>

		
<aside>
	<div class="sidebar" id="sidebar-two">
		<section><div class="sidesection widget widget_schneier_about" id="schneier_about-2"><h3>About Bruce Schneier</h3><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/Bruce-Schneier.jpg" /><p><p class="small">I am a <a href="https://public-interest-tech.com/">public-interest technologist</a>, working at the intersection of security, technology, and people. I've been writing about security issues on my <a href="/">blog</a> since 2004, and in my monthly <a href="/crypto-gram/">newsletter</a> since 1998. I'm a fellow and lecturer at Harvard's <a href="https://www.hks.harvard.edu/faculty/bruce-schneier">Kennedy School</a>, a board member of <a href="https://www.eff.org/">EFF</a>, and the Chief of Security Architecture at <a href="https://inrupt.com/">Inrupt, Inc.</a> This personal website expresses the opinions of none of those organizations.</p>
</p></div></section><section><div class="sidesection widget widget_schneier_related_posts" id="schneier_related_posts-2"><h3>Related Entries</h3>
<ul>

	<li><a href="https://www.schneier.com/blog/archives/2021/03/illegal-content-and-the-blockchain.html">Illegal Content and the Blockchain</a></li><li><a href="https://www.schneier.com/blog/archives/2021/03/national-security-risks-of-late-stage-capitalism.html">National Security Risks of Late-Stage Capitalism</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/weis-2021-call-for-papers.html">WEIS 2021 Call for Papers</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/ransomware-profitability.html">Ransomware Profitability</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/presidential-cybersecurity-and-pelotons.html">Presidential Cybersecurity and Pelotons</a></li><li><a href="https://www.schneier.com/blog/archives/2021/01/police-have-disrupted-the-emotet-botnet.html">Police Have Disrupted the Emotet Botnet</a></li>
</ul>
</div></section><section><div class="sidesection widget widget_schneier_featured_essays" id="schneier_featured_essays-2"><h3>Featured Essays</h3>
	<ul>
		<li><a href="https://www.schneier.com/essays/archives/2016/04/the_value_of_encrypt.html">The Value of Encryption</a></li><li><a href="https://www.schneier.com/essays/archives/2016/03/data_is_a_toxic_asse.html">Data Is a Toxic Asset, So Why Not Throw It Out?</a></li><li><a href="https://www.schneier.com/essays/archives/2014/01/how_the_nsa_threaten.html">How the NSA Threatens National Security</a></li><li><a href="https://www.schneier.com/essays/archives/2009/01/terrorists_may_use_g.html">Terrorists May Use Google Earth, But Fear Is No Reason to Ban It</a></li><li><a href="https://www.schneier.com/essays/archives/2007/01/in_praise_of_securit.html">In Praise of Security Theater</a></li><li><a href="https://www.schneier.com/essays/archives/2006/08/refuse_to_be_terrori.html">Refuse to be Terrorized</a></li><li><a href="https://www.schneier.com/essays/archives/2006/05/the_eternal_value_of.html">The Eternal Value of Privacy</a></li><li><a href="https://www.schneier.com/essays/archives/2005/09/terrorists_dont_do_m.html">Terrorists Don&#039;t Do Movie Plots</a></li>	</ul>

	<p><a href="https://www.schneier.com/essays/">More Essays</a></p></div></section><section><div class="sidesection widget widget_schneier_archives" id="schneier_archives-2"><h3>Blog Archives</h3>
<ul>

	<li><a href="https://www.schneier.com/blog/calendar.html/">Archive by Month</a></li><li><a href="https://www.schneier.com/blog/newcomments.html/">100 Latest Comments</a></li></ul>

<h4>Blog Tags</h4><ul class="top-tags"><li><a href="https://www.schneier.com/tag/3d-printers/">3d printers</a></li><li><a href="https://www.schneier.com/tag/9-11/">9/11</a></li><li><a href="https://www.schneier.com/tag/aaron-swartz/">Aaron Swartz</a></li><li><a href="https://www.schneier.com/tag/academic/">academic</a></li><li><a href="https://www.schneier.com/tag/academic-papers/">academic papers</a></li><li><a href="https://www.schneier.com/tag/accountability/">accountability</a></li><li><a href="https://www.schneier.com/tag/aclu/">ACLU</a></li><li><a href="https://www.schneier.com/tag/activism/">activism</a></li><li><a href="https://www.schneier.com/tag/adobe/">Adobe</a></li><li><a href="https://www.schneier.com/tag/advanced-persistent-threats/">advanced persistent threats</a></li><li><a href="https://www.schneier.com/tag/adware/">adware</a></li><li><a href="https://www.schneier.com/tag/aes/">AES</a></li><li><a href="https://www.schneier.com/tag/afghanistan/">Afghanistan</a></li><li><a href="https://www.schneier.com/tag/air-marshals/">air marshals</a></li><li><a href="https://www.schneier.com/tag/air-travel/">air travel</a></li><li><a href="https://www.schneier.com/tag/airgaps/">airgaps</a></li><li><a href="https://www.schneier.com/tag/al-qaeda/">al Qaeda</a></li><li><a href="https://www.schneier.com/tag/alarms/">alarms</a></li><li><a href="https://www.schneier.com/tag/algorithms/">algorithms</a></li><li><a href="https://www.schneier.com/tag/alibis/">alibis</a></li><li><a href="https://www.schneier.com/tag/amazon/">Amazon</a></li><li><a href="https://www.schneier.com/tag/android/">Android</a></li><li><a href="https://www.schneier.com/tag/anonymity/">anonymity</a></li><li><a href="https://www.schneier.com/tag/anonymous/">Anonymous</a></li><li><a href="https://www.schneier.com/tag/antivirus/">antivirus</a></li><li><a href="https://www.schneier.com/tag/apache/">Apache</a></li><li><a href="https://www.schneier.com/tag/apple/">Apple</a></li><li><a href="https://www.schneier.com/tag/applied-cryptography/">Applied Cryptography</a></li><li><a href="https://www.schneier.com/tag/artificial-intelligence/">artificial intelligence</a></li><li><a href="https://www.schneier.com/tag/assassinations/">assassinations</a></li></ul><p><a href="https://www.schneier.com/blog/tags.html/">More Tags</a></p></div></section><section><div class="sidesection widget widget_schneier_latest_book" id="schneier_latest_book-3"><h3>Latest Book</h3><a href="https://www.schneier.com/books/click-here/"><img class="sidepic" alt="Click Here to Kill Everybody" src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2018/07/book-ch2-200w.png" /></a><p><a href="https://www.schneier.com/books/">More Books</a></p></div></section><section><div class="sidesection widget widget_schneier_promotion" id="schneier_promotion-2">
<a href="https://www.eff.org/issues/bloggers/legal/join">
	<img src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/join-eff@2x.png" id="effbutton" alt="Support Bloggers' Rights!" title="Support Bloggers' Rights!" /></a>

<a href="https://npo.networkforgood.org/Donate/Donate.aspx?npoSubscriptionId=8252">
	<img src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/support-epic@2x.png" alt="Defend Privacy--Support Epic" title="Defend Privacy--Support Epic" /></a>
</div></section>	</div>
</aside>

		<footer>
			<nav>
				<div class="nav" id="footer-nav">
					<div class="menu-main-menu-container"><ul id="menu-main-menu-1" class="menu"><li class="menu1 menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-50175 current-menu-item"><a href="https://www.schneier.com">Blog</a></li>
<li class="menu2 menu-item menu-item-type-post_type menu-item-object-page menu-item-50916"><a href="https://www.schneier.com/crypto-gram/">Newsletter</a></li>
<li class="menu3 menu-item menu-item-type-post_type menu-item-object-page menu-item-50166"><a href="https://www.schneier.com/books/">Books</a></li>
<li class="menu4 menu-item menu-item-type-custom menu-item-object-custom menu-item-50169"><a href="https://www.schneier.com/essays/">Essays</a></li>
<li class="menu5 menu-item menu-item-type-custom menu-item-object-custom menu-item-50170"><a href="https://www.schneier.com/news/">News</a></li>
<li class="menu6 menu-item menu-item-type-custom menu-item-object-custom menu-item-50171"><a href="https://www.schneier.com/talks/">Talks</a></li>
<li class="menu7 menu-item menu-item-type-post_type menu-item-object-page menu-item-50167"><a href="https://www.schneier.com/academic/">Academic</a></li>
<li class="menu8 menu-item menu-item-type-post_type menu-item-object-page menu-item-50174"><a href="https://www.schneier.com/blog/about/">About Me</a></li>
</ul></div>				</div>
			</nav>
		</footer>

		</div><!--#main-->
	</div><!--#wrapper-->

		<script type="text/javascript">
		(function () {
			var c = document.body.className;
			c = c.replace(/woocommerce-no-js/, 'woocommerce-js');
			document.body.className = c;
		})();
	</script>
	<script type='text/javascript' src='https://c0.wp.com/p/woocommerce/5.1.0/assets/js/jquery-cookie/jquery.cookie.min.js' id='jquery-cookie-js'></script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/vendor/socialshareprivacy/js/socialshareprivacy.js?ver=1.0.1' id='social-share-privacy-js'></script>
<script type='text/javascript' id='social-share-privacy-icons-js-extra'>
/* <![CDATA[ */
var schneierSocial = {"path":"https:\/\/www.schneier.com\/wp-content\/themes\/schneier\/assets\/vendor\/socialshareprivacy\/"};
/* ]]> */
</script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/vendor/socialshareprivacy/js/icons.js?ver=1.0.0' id='social-share-privacy-icons-js'></script>
<script type='text/javascript' id='schneier-comment-js-extra'>
/* <![CDATA[ */
var schneierComment = {"translateErrorSecurityAnswerWrong":"Your response to the challenge question ('The name of this blog is Schneier on ____') was not correct. Please try again.","ajax_url":"https:\/\/www.schneier.com\/wp-admin\/admin-ajax.php"};
/* ]]> */
</script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/js/comment.js?ver=1.0.1' id='schneier-comment-js'></script>
<script type='text/javascript' src='https://c0.wp.com/c/5.7/wp-includes/js/wp-embed.min.js' id='wp-embed-js'></script>

</body>

</html>
