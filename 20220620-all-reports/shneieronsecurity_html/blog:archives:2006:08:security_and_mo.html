<!DOCTYPE html>
<html lang="en-US">

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<title>Security and Monoculture - Schneier on Security</title>
	<meta name='robots' content='max-image-preview:large' />
<link rel='dns-prefetch' href='//s.w.org' />
<link rel='dns-prefetch' href='//c0.wp.com' />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Feed" href="https://www.schneier.com/feed/" />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Comments Feed" href="https://www.schneier.com/comments/feed/" />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Security and Monoculture Comments Feed" href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/feed/" />
<link rel='stylesheet' id='wp-block-library-css'  href='https://c0.wp.com/c/5.7/wp-includes/css/dist/block-library/style.min.css' type='text/css' media='all' />
<style id='wp-block-library-inline-css' type='text/css'>
.has-text-align-justify{text-align:justify;}
</style>
<style id='woocommerce-inline-inline-css' type='text/css'>
.woocommerce form .form-row .required { visibility: visible; }
</style>
<link rel='stylesheet' id='schneier-css'  href='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/style.css?ver=1.0.0' type='text/css' media='all' />
<link rel='stylesheet' id='schneier-main-css'  href='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/dist/css/style.css?ver=1.0.2' type='text/css' media='all' />
<link rel='stylesheet' id='jetpack_css-css'  href='https://c0.wp.com/p/jetpack/9.5.2/css/jetpack.css' type='text/css' media='all' />
<script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js?ver=3.5.1' id='jquery-js'></script>
<link rel="https://api.w.org/" href="https://www.schneier.com/wp-json/" /><link rel="alternate" type="application/json" href="https://www.schneier.com/wp-json/wp/v2/posts/1045" /><link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://www.schneier.com/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://www.schneier.com/wp-includes/wlwmanifest.xml" /> 

<link rel="canonical" href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html" />
<link rel='shortlink' href='https://www.schneier.com/?p=1045' />
<link rel="alternate" type="application/json+oembed" href="https://www.schneier.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2006%2F08%2Fsecurity_and_mo.html" />
<link rel="alternate" type="text/xml+oembed" href="https://www.schneier.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2006%2F08%2Fsecurity_and_mo.html&#038;format=xml" />
	<noscript><style>.woocommerce-product-gallery{ opacity: 1 !important; }</style></noscript>
	<link rel="icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-32x32.png" sizes="32x32" />
<link rel="icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-180x180.png" />
<meta name="msapplication-TileImage" content="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-270x270.png" />
		<style type="text/css" id="wp-custom-css">
			#schneier_promotion-2 img {
    max-width: 180px;
}		</style>
		</head>

<body class="post-template-default single single-post postid-1045 single-format-standard theme-schneier woocommerce-no-js">

	<div id="wrapper">
		<div id="main">

			<header>
				<div id="header">
					<h1>
						<a href="https://www.schneier.com/" rel="home">
							Schneier on Security						</a>
					</h1>
				</div>
			</header>

			<nav>
				<div class="nav" id="header-nav">
					<div class="menu-main-menu-container"><ul id="menu-main-menu" class="menu"><li id="menu-item-50175" class="menu1 menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-50175 current-menu-item"><a href="https://www.schneier.com">Blog</a></li>
<li id="menu-item-50916" class="menu2 menu-item menu-item-type-post_type menu-item-object-page menu-item-50916"><a href="https://www.schneier.com/crypto-gram/">Newsletter</a></li>
<li id="menu-item-50166" class="menu3 menu-item menu-item-type-post_type menu-item-object-page menu-item-50166"><a href="https://www.schneier.com/books/">Books</a></li>
<li id="menu-item-50169" class="menu4 menu-item menu-item-type-custom menu-item-object-custom menu-item-50169"><a href="https://www.schneier.com/essays/">Essays</a></li>
<li id="menu-item-50170" class="menu5 menu-item menu-item-type-custom menu-item-object-custom menu-item-50170"><a href="https://www.schneier.com/news/">News</a></li>
<li id="menu-item-50171" class="menu6 menu-item menu-item-type-custom menu-item-object-custom menu-item-50171"><a href="https://www.schneier.com/talks/">Talks</a></li>
<li id="menu-item-50167" class="menu7 menu-item menu-item-type-post_type menu-item-object-page menu-item-50167"><a href="https://www.schneier.com/academic/">Academic</a></li>
<li id="menu-item-50174" class="menu8 menu-item menu-item-type-post_type menu-item-object-page menu-item-50174"><a href="https://www.schneier.com/blog/about/">About Me</a></li>
</ul></div>				</div>
			</nav>

			
<aside>
	<div class="sidebar" id="sidebar-one">
		<section><div class="sidesection widget widget_schneier_search" id="schneier_search-3"><h3>Search</h3>
<p class="small">
	<em>Powered by <a href="https://duckduckgo.com/">DuckDuckGo</a></em></p>

<form method="get" action="https://duckduckgo.com/">

	<input type="hidden" name="kh" value="1" /><!-- use https -->

	<input id="search" name="q" size="15" maxlength="255" />

	<input type="submit" value="Go" /><br>

	<input type="radio" name="sites" id="searchblog" value="www.schneier.com/blog" />
	<label for="searchblog">Blog</label>

	<input type="radio" name="sites" id="searchessays" value="www.schneier.com/essays" />
	<label for="searchessays">Essays</label>

	<input type="radio" name="sites" id="searchall" value="www.schneier.com" checked="" />
	<label for="searchall">Whole site</label>

</form>
</div></section><section><div class="sidesection widget widget_schneier_social" id="schneier_social-2"><h3>Subscribe</h3>
<div id="subscription-buttons">

	<a href="https://www.schneier.com/feed/atom"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/rss-32px.png" alt="Atom Feed" /></a><a href="https://www.facebook.com/bruce.schneier"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/facebook-32px.png" alt="Facebook" /></a><a href="https://twitter.com/schneierblog/"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/twitter-32px.png" alt="Twitter" /></a><a href="https://www.amazon.com/Schneier-on-Security/dp/B0053HDDWW/"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/kindle-32px.png" alt="Kindle" /></a><a href="https://www.schneier.com/crypto-gram"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/email-32px.png" alt="E-Mail Newsletter (Crypto-Gram)" /></a>
</div>
</div></section>	</div>
</aside>

			<div id="content">

				
		<p id="breadcrumbs">

			<a href="https://www.schneier.com">Home</a><a href="https://www.schneier.com/blog/archives/">Blog</a>		</p>

		
<article id="post-1045" class="post-1045 post type-post status-publish format-standard hentry category-uncategorized tag-academic-papers tag-hacking tag-monoculture tag-vulnerabilities">

	<div class="article">

		<h2 class="entry">Security and Monoculture</h2>
		<p><a href="http://www.newscientisttech.com/article/mg19125611.700.html">Interesting research.</a></p>
<p>EDITED TO ADD (8/1):  The paper is only viewable by subscribers. Here are some excerpts:</p>
<blockquote><p>Fortunately, buffer-overflow attacks have a weakness: the intruder must know precisely what part of the computer&#8217;s memory to target. In 1996, Forrest realised that these attacks could be foiled by scrambling the way a program uses a computer&#8217;s memory. When you launch a program, the operating system normally allocates the same locations in a computer&#8217;s random access memory (RAM) each time. Forrest wondered whether she could rewrite the operating system to force the program to use different memory locations that are picked randomly every time, thus flummoxing buffer-overflow attacks.</p>
<p>To test her concept, Forrest experimented with a version of the open-source operating system Linux. She altered the system to force programs to assign data to memory locations at random. Then she subjected the computer to several well-known attacks that used the buffer-overflow technique. None could get through. Instead, they targeted the wrong area of memory. Although part of the software would often crash, Linux would quickly restart it, and get rid of the virus in the process. In rare situations it would crash the entire operating system, a short-lived annoyance, certainly, but not bad considering the intruder had failed to take control of the machine.</p>
<p>Linux computer-security experts quickly picked up on Forrest&#8217;s idea. In 2003 Red Hat, the maker of a popular version of Linux, began including memory-space randomisation in its products. &#8220;We had several vulnerabilities which we could downgrade in severity,&#8221; says Marc J. Cox, a Red Hat security expert.</p>
<p>[&#8230;]</p>
<p>Memory scrambling isn&#8217;t the only way to add diversity to operating systems. Even more sophisticated techniques are in the works. Forrest has tried altering &#8220;instruction sets&#8221;, commands that programs use to communicate with a computer&#8217;s hardware, such as its processor chip or memory.</p>
<p>Her trick was to replace the &#8220;translator&#8221; program that interprets these instruction sets with a specially modified one. Every time the computer boots up, Forrest&#8217;s software loads into memory and encrypts the instruction sets in the hardware using a randomised encoding key. When a program wants to send a command to the computer, Forrest&#8217;s translator decrypts the command on the fly so the computer can understand it.</p>
<p>This produces an elegant form of protection. If an attacker manages to insert malicious code into a running program, that code will also be decrypted by the translator when it is passed to the hardware. However, since the attacker&#8217;s code is not encrypted in the first place, the decryption process turns it into digital gibberish so the computer hardware cannot understand it. Since it exists only in the computer&#8217;s memory and has not been written to the computer&#8217;s hard disc, it will vanish upon reboot.</p>
<p>Forrest has tested the process on several versions of Linux while launching buffer-overflow attacks. None were able to penetrate. As with memory randomisation, the failed attacks would, at worst, temporarily crash part of Linux &#8211; a small price to pay. Her translator program was a success. &#8220;It seemed like a crazy idea at first,&#8221; says Gabriel Barrantes, who worked with Forrest on the project. &#8220;But it turned out to be sound.&#8221;</p>
<p>[&#8230;]</p>
<p>In 2004, a group of researchers led by Hovav Shacham at Stanford University in California tried this trick against a copy of the popular web-server application Apache that was running on Linux, protected with memory randomisation. It took them 216 seconds per attack to break into it. They concluded that this protection is not sufficient to stop the most persistent viruses or a single, dedicated attacker.</p>
<p>Last year, a group of researchers at the University of Virginia, Charlottesville, performed a similar attack on a copy of Linux whose instruction set was protected by randomised encryption. They used a slightly more complex approach, making a series of guesses about different parts of the randomisation key. This time it took over 6 minutes to force a way in: the system was tougher, but hardly invulnerable.</p>
<p>[&#8230;]</p>
<p>Knight says that randomising the encryption on the instruction set is a more powerful technique because it can use larger and more complex forms of encryption. The only limitation is that as the encryption becomes more complicated, it takes the computer longer to decrypt each instruction, and this can slow the machine down. Barrantes found that instruction-set randomisation more than doubled the length of time an instruction took to execute. Make the encryption too robust, and computer users could find themselves drumming their fingers as they wait for a web page to load.</p>
<p>So he thinks the best approach is to combine different types of randomisation. Where one fails, another picks up. Last year, he took a variant of Linux and randomised both its memory-space allocation and its instruction sets. In December, he put 100 copies of the software online and hired a computer-security firm to try and penetrate them.  The attacks failed. In May, he repeated the experiment but this time he provided the attackers with extra information about the randomised software. Their assault still failed.</p>
<p>The idea was to simulate what would happen if an adversary had a phenomenal amount of money, and secret information from an inside collaborator, says Knight. The results pleased him and, he hopes, will also please DARPA when he presents them to the agency. &#8220;We aren&#8217;t claiming we can do everything, but for broad classes of attack, these techniques appear to work very well. We have no reason to believe that  there would be any change if we were to try to apply this to the real world.&#8221;</p></blockquote>
<p>EDITED TO ADD (8/2):  The article is <a href="http://www.tmcnet.com/usubmit/2006/07/21/1725091.htm">online here</a>.</p>

		
			<p class="entry-tags">
				<span class="tags-links">Tags: <a href="https://www.schneier.com/tag/academic-papers/" rel="tag">academic papers</a>, <a href="https://www.schneier.com/tag/hacking/" rel="tag">hacking</a>, <a href="https://www.schneier.com/tag/monoculture/" rel="tag">monoculture</a>, <a href="https://www.schneier.com/tag/vulnerabilities/" rel="tag">vulnerabilities</a></span>			</p>

		
		
		<p class="posted">
			<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html" rel="bookmark">Posted on August 1, 2006 at 6:26 AM</a>			•
			<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html#comments">47 Comments</a>		</p>

		<aside><div class="schneier-share share" data-uri="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html" data-title="Security and Monoculture" data-order="facebook twitter tumblr" data-social-share-privacy="true" /></aside>
	</div>

</article>


	<h3 id="comments">Comments</h3>

	
		<article class="comment even thread-even depth-1" id="comment-38889">

			<div class="comment by-jakes ">

				<p class="commentcredit">

					<span class="commenter">JakeS</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38889">
						August 1, 2006 7:41 AM					</a>

				</p>

				<p>May be interesting, but only New Scientist subscribers can read it.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38890">

			<div class="comment by-mack ">

				<p class="commentcredit">

					<span class="commenter">Mack</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38890">
						August 1, 2006 7:56 AM					</a>

				</p>

				<p>Bruce,</p>
<p>Only New Scientist subscribers can read that article, which is a shame cause it seems interesting.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38891">

			<div class="comment by-ashok ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://ashok.videdot.com/' rel='external nofollow ugc' class='url'>Ashok</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38891">
						August 1, 2006 8:03 AM					</a>

				</p>

				<p>It&#8217;s a shame they&#8217;re using domains like newscientisttech.com and newscientistjobs.com, rather than jobs.newscientist.com and so forth.<br />
It becomes pretty easy to pick a new, credible-looking domain to fish from when companies do this kind of thing &#8211; and I broadly respect NewSci, so would expect them to do better than most.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38892">

			<div class="comment by-dewey ">

				<p class="commentcredit">

					<span class="commenter">Dewey</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38892">
						August 1, 2006 9:18 AM					</a>

				</p>

				<p>Would someone care to summarize the content for us non-subscribers?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38893">

			<div class="comment by-bruce-schneier ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://http:/www.schneier.com/blog' rel='external nofollow ugc' class='url'>Bruce Schneier</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38893">
						August 1, 2006 10:28 AM					</a>

				</p>

				<p>Sorry about linking to a subscriber-only article.  I didn&#8217;t realize it.</p>
<p>I posted some excerpts above.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38894">

			<div class="comment by-schemer ">

				<p class="commentcredit">

					<span class="commenter">Schemer</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38894">
						August 1, 2006 11:20 AM					</a>

				</p>

				<p>This seems like an excellent example of focusing on the symptom instead of the cause.  It seems like most effort is spent keeping buffer overflow exploits from causing damage, when we should be putting far more effort into getting developers to use safe languages, safe libraries, heap-based allocation, static type-checkers, etc. in order to prevent the possibility of buffer overflows to begin with.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38895">

			<div class="comment by-christoph-zurnieden ">

				<p class="commentcredit">

					<span class="commenter">Christoph Zurnieden</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38895">
						August 1, 2006 11:20 AM					</a>

				</p>

				<p>&#8220;Fortunately, buffer-overflow attacks have a weakness [&#8230;]&#8221;</p>
<p>Let me guess what it isn&#8217;t: the ability to change the line(s) of code causeing the buffer overflow in the first place.</p>
<p>Oh, my &#8230; <em>sigh</em></p>
<p>Why, for joves sake, do you want to treat the symptoms only instead of healing the desease?</p>
<p>The anti-virus companies do nearly the same, yes, but they earn some money with it at least and it is very difficult and therefore very expensive to repair a closed-source-system you don&#8217;t own any rights for.</p>
<p>There are much better ways like e.g.separating executables from data at the hardwarelevel.<br />
Or place automatic checks for buffer overflows with the compiler (e.g. <a href="http://www.trl.ibm.com/projects/security/ssp/" rel="nofollow ugc">http://www.trl.ibm.com/projects/security/ssp/</a>).</p>
<p>And it&#8217;s of cause much simpler to persuade the user to execute your malign code.</p>
<p>CZ</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38896">

			<div class="comment by-mdf ">

				<p class="commentcredit">

					<span class="commenter">mdf</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38896">
						August 1, 2006 11:27 AM					</a>

				</p>

				<p>Perhaps unmentioned (or at least, unquoted here) is that these randomization defences can lead to the expression of extremely bizzare bugs/problems that can be very difficult to reproduce.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38897">

			<div class="comment by-joe ">

				<p class="commentcredit">

					<span class="commenter">Joe</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38897">
						August 1, 2006 11:37 AM					</a>

				</p>

				<p>Anyone who&#8217;s programmed on the late great VAX/VMS and OpenVMS systems should be familiar with the old %SYSTEM-F-ACCVIO or &#8220;Access Violation&#8221; error messages. Memory protection was one of the design principles of those operating systems and it forced programmers to do extensive input validation to prevent these errors. I remember a debate with a Windows PC programmer on whether memory protection was important and one of the arguments I made was that you could have someone execute code that you had not intended. The response I got was &#8220;Why would anyone want to do something like that?&#8221;</p>
<p>Years later, we dumped VAX VMS for Windows 2000 and I had to move on and learn more about Wild West programming on x86 and Windows. There is a sense of bitter irony when you see the last VAX or Alpha decommissioned in the same room where a bunch of sysadmins are busy patching and rebooting Windows 2003 machines.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38898">

			<div class="comment by-michael-ash ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://mikeash.com' rel='external nofollow ugc' class='url'>Michael Ash</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38898">
						August 1, 2006 11:55 AM					</a>

				</p>

				<p>@ Christoph Zurnieden</p>
<p>You want to treat the symptoms instead of the disease because curing the disease 100% is impossible. It is impossible to write bug-free code. That means there will always be vulnerabilities in software*. Given that, it is a good idea to have defense in depth by not only trying to write good software, but also making it more difficult to exploit the inevitable bugs. This is a compliment, not a replacement, for writing good code.</p>
<ul>
<li>These particular sorts of buffer overflows are much harder to have in programs written in higher level languages, but that just means these languages will have other sorts of bugs and vulnerabilities. They may well have fewer, but they won&#8217;t have zero.</li>
</ul>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38899">

			<div class="comment by-xyz ">

				<p class="commentcredit">

					<span class="commenter">Xyz</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38899">
						August 1, 2006 12:31 PM					</a>

				</p>

				<p>In response to CZ:</p>
<p>This doesn&#8217;t seem to be about &#8220;treating the symptom and not the disease&#8221;. It sounds like they&#8217;re looking for ways to stop buffer overflow vulnerabilities right where they hit&#8211; at the insertion. Though I&#8217;ll concede that the encrypted instruction set idea seems gimmicky and probably isn&#8217;t practical.</p>
<p>If there&#8217;s a good way, it seems to make sense to make arbitrary code execution protection an OS level defense&#8211; it&#8217;s better than the alternative of relying on application code to be infallible.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38900">

			<div class="comment by-davi-ottenheimer ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://davi.poetry.org/' rel='external nofollow ugc' class='url'>Davi Ottenheimer</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38900">
						August 1, 2006 1:44 PM					</a>

				</p>

				<p>@ Joe</p>
<p>&#8220;There is a sense of bitter irony when you see the last VAX or Alpha decommissioned in the same room where a bunch of sysadmins are busy patching and rebooting Windows 2003 machines.&#8221;</p>
<p>Ha! Sorry, but when I worked with DEC in the early-mid 1990s we were told Windows would be the next evolution. OSF/1 was treated like a step-child. So your comment is even more ironic when you consider that the predecessor of today&#8217;s Windows OS was in fact VMS. And wasn&#8217;t the Alpha supposed to be the preferrred platform for Microsoft OS? Perhaps the hardware market was a little more open&#8230;</p>
<p>Mark Russinovich (now working for Microsoft) wrote about it in 1998:</p>
<p><a href="http://www.windowsitpro.com/Articles/Index.cfm?IssueID=97&#038;ArticleID=4494" rel="nofollow ugc">http://www.windowsitpro.com/Articles/Index.cfm?IssueID=97&#038;ArticleID=4494</a></p>
<p>&#8220;And now&#8230;the rest of the story: I&#8217;ll take you on a short tour of NT&#8217;s lineage, which leads back to Digital and its VMS OS. Most of NT&#8217;s lead developers, including VMS&#8217;s chief architect, came from Digital, and their background heavily influenced NT&#8217;s development. After I talk about NT&#8217;s roots, I&#8217;ll discuss the more-than-coincidental similarities between NT and VMS, and how Digital reacted to NT&#8217;s release. . . .&#8221;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38901">

			<div class="comment by-christoph-zurnieden ">

				<p class="commentcredit">

					<span class="commenter">Christoph Zurnieden</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38901">
						August 1, 2006 2:06 PM					</a>

				</p>

				<p>Thank you, Joe, for the reminiscence. It seems as if it is carefully forgotten that the PC-architecture was meant to be cheap and cheap only. It had to be able to run a single-user single-threaded OS and that was all it had to do.<br />
There are some affords lastly by Intel, AMD and some others to reinstall the separation between executables and data but it is not used by many software writers.</p>
<blockquote><p>
  You want to treat the symptoms instead of the disease because curing the disease 100% is impossible.
</p></blockquote>
<p>The desease is &#8220;buffer overflow and related&#8221; (related are e.g. integer over/undeflows and so on) and is 100% curable simply by bounds checking. You do not need to do it yourself, your compiler can do it for you.</p>
<blockquote><p>
  It is impossible to write bug-free code.
</p></blockquote>
<p>That depends on the time of use of that particular software[BishBloom] 😉</p>
<blockquote><p>
  That means there will always be vulnerabilities in software.
</p></blockquote>
<p>I can&#8217;t see your conclusion. Yes, all software has bugs, but why <em>must</em> these bugs include vulnerabilities?</p>
<p>CZ</p>
<p>(A bibliography in a blog comment? Good God!)<br />
[BishBloom] P. Bishop, R. Bloomfield, &#8220;A Conservative Theory for Long-Term Reliability/Growth Prediction&#8221;, IEEE Transactions on Reliability v. 45 no. 4 (Dec 96) pp 550<br />
­560.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38902">

			<div class="comment by-samh ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://optimist.sdf-eu.org/ssp' rel='external nofollow ugc' class='url'>Samh</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38902">
						August 1, 2006 2:09 PM					</a>

				</p>

				<p>Haven&#8217;t these people heard of OpenBSD ?</p>
<p><a href="http://cvs.openbsd.org/papers/ven05-deraadt/index.html" rel="nofollow ugc">http://cvs.openbsd.org/papers/ven05-deraadt/index.html</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38903">

			<div class="comment by-samh ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://optimist.sdf-eu.org/ssp' rel='external nofollow ugc' class='url'>Samh</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38903">
						August 1, 2006 2:12 PM					</a>

				</p>

				<p>&#8220;It is impossible to write bug-free code&#8221;</p>
<p>It&#8217;s a special case of &#8220;the halting problem&#8221;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38904">

			<div class="comment by-samh ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://optimist.sdf-eu.org/ssp' rel='external nofollow ugc' class='url'>Samh</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38904">
						August 1, 2006 2:16 PM					</a>

				</p>

				<p>CZ wrote</p>
<p>&#8220;The desease is &#8220;buffer overflow and related&#8221; (related are e.g. integer over/undeflows and so on) and is 100% curable simply by bounds checking. You do not need to do it yourself, your compiler can do it for you.&#8221;</p>
<p>I would be very surprised if you can get a compiler to protect against every single type of integer overflow without false positives.</p>
<p>I await your solution</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38905">

			<div class="comment by-joe ">

				<p class="commentcredit">

					<span class="commenter">Joe</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38905">
						August 1, 2006 3:09 PM					</a>

				</p>

				<p>@Davi</p>
<p>I&#8217;m familiar with NT&#8217;s development roots and Cutler&#8217;s leadership in building NT. In fact, there are some urban legends that say that WNT is VMS 1 letter shifted&#8211;as HAL (as in HAL 9000) is 1 letter shifted from IBM.</p>
<p>The point is that NT development had compromised some of the original design principles of VMS. For example, I remember when the GDI or graphics display subsystem moved from Ring 3 (user mode) to Ring 0 (kernel mode) for performance reasons. There was talk about moving it back in Vista&#8211;but I don&#8217;t think that went anywhere.</p>
<p>The point is that good design principles went out the Windows when Bill Gates picked and chose only those that sold better going forward. I remember programmers complaining why they had to work extra hard on input validation when, on the Windows PC platform, it let them do whatever they want.</p>
<p>The lack of memory protection let the bad guys do whatever they want, too.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38906">

			<div class="comment by-roy ">

				<p class="commentcredit">

					<span class="commenter">roy</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38906">
						August 1, 2006 3:19 PM					</a>

				</p>

				<p>Compilers do not seem to understand buffer overflow problems.</p>
<p>The solution is idiot-simple in assembly language.</p>
<p>What&#8217;s missing?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38907">

			<div class="comment by-samh ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://optimist.sdf-eu.org/ssp' rel='external nofollow ugc' class='url'>Samh</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38907">
						August 1, 2006 3:28 PM					</a>

				</p>

				<p>No, compilers such as GCC can handle stack overflows without issue, handling integer overflows 100% of the time without false positives is nigh on impossible. What could appear to the compiler as in integer overflow could actually be a legitimate operation which would not cause a problem.</p>
<p>Idiot-simple ? try writing it.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38908">

			<div class="comment by-tim ">

				<p class="commentcredit">

					<span class="commenter">Tim</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38908">
						August 1, 2006 4:04 PM					</a>

				</p>

				<p>If you were suffering from a terrible disease, which would you prefer:<br />
1)Only the underlying cause was treated, leaving you in agony while you waited for a cure.<br />
2)They worked on the cure, but gave you some painkiller.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38909">

			<div class="comment by-christoph-zurnieden ">

				<p class="commentcredit">

					<span class="commenter">Christoph Zurnieden</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38909">
						August 1, 2006 4:19 PM					</a>

				</p>

				<blockquote><p>
  &#8220;It is impossible to write bug-free code&#8221;<br />
  It&#8217;s a special case of &#8220;the halting problem&#8221;
</p></blockquote>
<p>It is indeed possible to write bug-free code, you just can&#8217;t proof the code to be bug-free. That&#8217;s no special case of the Halting-Problem it is the Halting-Problem.</p>
<blockquote><p>
  I would be very surprised if you can get a compiler to protect against every single type of integer overflow without false positives.
</p></blockquote>
<p>It might surprise you, but a modern Ada-compiler does such things quite well.</p>
<p>CZ</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38910">

			<div class="comment by-samh ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://optimist.sdf-eu.org/ssp' rel='external nofollow ugc' class='url'>Samh</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38910">
						August 1, 2006 4:26 PM					</a>

				</p>

				<p>CZ, If you cannot prove your code is bug free, then how can you say it is possible to write bug free code ?</p>
<p>I am indeed surprised to hear Ada compilers are capable of preventing ALL possible integer overflows, I would have thought it would have more to do with the language symantics than the actual compiler. How about in C ?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38911">

			<div class="comment by-stiennon ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://blogs.zdnet.com/threatchaos' rel='external nofollow ugc' class='url'>Stiennon</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38911">
						August 1, 2006 4:49 PM					</a>

				</p>

				<p>This paper describes exactly how SolidCore&#8217;s product works. Been around for about three years.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38912">

			<div class="comment by-ex-deccie ">

				<p class="commentcredit">

					<span class="commenter">ex-deccie</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38912">
						August 1, 2006 5:08 PM					</a>

				</p>

				<p>@Davi Ottenheimer: &#8220;Ha! Sorry, but when I worked with DEC in the early-mid 1990s we were told Windows would be the next evolution. OSF/1 was treated like a step-child. So your comment is even more ironic when you consider that the predecessor of today&#8217;s Windows OS was in fact VMS.&#8221;</p>
<p>The fact that people at the helm of the company were so misguided as to take that evangelical position isnt really the point. Digital had a long history of either hedging bets or making the wrong bet on desktop computing (however great or advanced their technology was) &#8211; decmate, rainbow et al, the macintosh marriage; windows was just the last in a line of vague attempts at &#8216;me too&#8217;. The fact that they were eventually bought by a PC company once the vast IP assets had been sold in various fire sales to companies who have gone on to make a fortune from them is a tribute to Palmer&#8217;s leadership, foresight and vision (note the dripping sarcasm).</p>
<p>And to call VMS the predecessor of Windows is a huge compliment to Windows and a huge insult to VMS. Just because something more recent is based on similar concepts and principles (some parts a direct ripoff) to something that preceded it doesnt mean that the people responsible for the more recent &#8216;technology&#8217; didnt totally screw it up in the process.</p>
<p>Shame the linked article is another &#8216;subsciber only&#8217; article, it would have been nice to read it and reflect more on how a good thing can be made rotten at the core.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38913">

			<div class="comment by-christoph-zurnieden ">

				<p class="commentcredit">

					<span class="commenter">Christoph Zurnieden</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38913">
						August 1, 2006 5:09 PM					</a>

				</p>

				<blockquote><p>
  If you cannot prove your code is bug free, then how can you say it is possible to write bug free code ?
</p></blockquote>
<p>Asume the (countable?) infinite set of all possible code includes bug-free code.<br />
Let&#8217;s take the simplest one: x = x, what goes in comes out, a virtual short piece of wire so to say. How can you prove that? You can&#8217;t even test it, because you would have to test all possible values for x which are more than you can test.</p>
<p>Now let&#8217;s assume the set of all code doesn&#8217;t inlude any bug-free code.</p>
<p>Then even $x = x$ is wrong, which you can easily prove because, well, there is no bug-free code in the set.<br />
But you still can&#8217;t test it because of the same reasons as described above.</p>
<p>(It&#8217;s not fully correct because of the width of the margin^W^W^W^Wsmall textarea, but I hope you are able to get the direction)</p>
<blockquote><p>
  How about in C ?
</p></blockquote>
<p>How is C different from Ada? According to Church et al. it&#8217;s all the same.</p>
<p>CZ</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38914">

			<div class="comment by-samh ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://optimist.sdf-eu.org/ssp' rel='external nofollow ugc' class='url'>Samh</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38914">
						August 1, 2006 6:32 PM					</a>

				</p>

				<p>CZ, you&#8217;re point proves nothing, if you cannot prove that any piece of code is bug free, then you cannot say that it is possible to have bug free code because you cannot prove it. To believe it is possible to have bug free code is just that, a belief, it doesn&#8217;t mean bug free code does not exist.</p>
<p>How does C differ from Ada ?</p>
<p>Under the hood of the compiler it does not, in language symantics it does, in what way they differ I cannot tell you, I can tell you that from a GCC point of view it is nigh on impossible to remove all possibility of integer overflows with 100% accuracy. If it cannot be done under the hood, it must be a question of the language itself.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38915">

			<div class="comment by-alan-de-smet ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.highprogrammer.com/alan/' rel='external nofollow ugc' class='url'>Alan De Smet</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38915">
						August 1, 2006 10:05 PM					</a>

				</p>

				<p>While there are arguments to be made for more software to move to using managed languages that handle many of these attacks, it&#8217;s not a complete.  It takes a long time to reimplement major pieces of software; time that companies are hesistant to spend as it costs money with no direct increase in profit.   Users aren&#8217;t willing to pay for small security updates, let alone complete overhauls.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38916">

			<div class="comment by-follow-this-link-for-the-full-article ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.tmcnet.com/usubmit/2006/07/21/1725091.htm' rel='external nofollow ugc' class='url'>Follow this link for the full article</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38916">
						August 1, 2006 10:08 PM					</a>

				</p>

				<p>The complete article appears to be online here: <a href="http://www.tmcnet.com/usubmit/2006/07/21/1725091.htm" rel="nofollow ugc">http://www.tmcnet.com/usubmit/2006/07/21/1725091.htm</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38917">

			<div class="comment by-davi-ottenheimer ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://davi.poetry.org/' rel='external nofollow ugc' class='url'>Davi Ottenheimer</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38917">
						August 1, 2006 10:31 PM					</a>

				</p>

				<p>&#8220;And to call VMS the predecessor of Windows is a huge compliment to Windows and a huge insult to VMS&#8221;</p>
<p>Really? I&#8217;d see it the other way around. It&#8217;s a compliment to VMS that Microsoft cherry-picked the lead developers to create their future OS. DEC certainly was a leader in the 1980s. Makes me wonder if the Itanium architects perhaps included some of the original Alpha 21&#215;64 team. Anyway, in the end unix and x86, today both evolving through many &#8220;cultures&#8221;, look like they will actually be far more successful and stable than most alternatives. Perhaps if UNIX had remained &#8220;proprietary&#8221;, as Ken Olsen complained in 1988, and its supporters had not capitalized on the fact that it is easily extendable, simple and adaptive (hallmarks of multiculturalism), then it might have never have escaped his infamous &#8220;snake oil&#8221; gibe:</p>
<p><a href="http://groups.google.com/group/comp.unix.wizards/msg/7bd1b3805722aeb2" rel="nofollow ugc">http://groups.google.com/group/comp.unix.wizards/msg/7bd1b3805722aeb2</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38918">

			<div class="comment by-taneli-huuskonen ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.helsinki.fi/~huuskone/' rel='external nofollow ugc' class='url'>Taneli Huuskonen</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38918">
						August 2, 2006 2:12 AM					</a>

				</p>

				<p>@Christoph Zurnieden:</p>
<p>I&#8217;m afraid your understanding of the Halting Problem and related issues is not quite accurate.</p>
<p>The Halting Problem is a special case of the more general problem of checking whether a given program meets given specifications.  Its unsolvability implies that no matter how sophisticated proof methods you choose, there&#8217;s always some spaghetti code that you can&#8217;t handle with those methods  &#8211;  you can neither prove nor disprove that it&#8217;ll eventually halt.  However, it&#8217;s trivial to write a one-liner that does nothing but halts, and another one that does nothing but goes into an infinite loop.  It&#8217;s equally easy to prove, in any halfway reasonable proof system, that the former will halt but the latter won&#8217;t.</p>
<p>So, there&#8217;s some code that you can prove to be bug-free, some that you can prove to be buggy, and some that you can&#8217;t prove to be either, even for performing the extremely simple task of halting sooner or later.  The same applies to a very wide class of specifications.  Some software companies even use formal proofs of correctness in production.  However, there&#8217;s a catch.  Such a proof can show that the program does what you told you wanted, not that it does what you actually want.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38919">

			<div class="comment by-matt-warren ">

				<p class="commentcredit">

					<span class="commenter">Matt Warren</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38919">
						August 2, 2006 4:11 AM					</a>

				</p>

				<p>How far does Data Execution Prevention (DEP) go to solving these problems?</p>
<p>From my understanding, DEP works at the hardware level and prevents memory that hasn&#8217;t been marked as executable from being run, so buffer overflows are stopped as they can only overwrite data memory, is this correct?</p>
<p>Are their buffer overflow attacks that DEP won&#8217;t ever be able to stop?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38920">

			<div class="comment by-christoph-zurnieden ">

				<p class="commentcredit">

					<span class="commenter">Christoph Zurnieden</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38920">
						August 2, 2006 6:34 AM					</a>

				</p>

				<blockquote><p>
  I&#8217;m afraid your understanding of the Halting Problem and related issues is not quite accurate.
</p></blockquote>
<p>I do understand it, but english is not my native language and &#8220;Movable Type 3.2&#8221; does not have any kind of support for formulas, not even a tex2img or something similar.</p>
<p>I probably should have made it more clear that I wanted to show that you don&#8217;t even need the halting problem to falsify the hypothesis &#8220;there is only buggy code&#8221;.</p>
<blockquote><p>
  So, there&#8217;s some code that you can prove to be bug-free, some that you can prove to be buggy, and some that you can&#8217;t prove to be either, even for performing the extremely simple task of halting sooner or later.
</p></blockquote>
<p>The run doesn&#8217;t halt if either the code is of infinite length which is not practically possible or it runs a piece of code with length &gt;0 infinite times. (please don&#8217;t kick me for that simplification immediatly, you will get your chance later, thank you) There is no halting problem if you don&#8217;t allow infinite runtimes. It wouldn&#8217;t be a turing complete language anymore, so you  are free to do what you want and set for example arbitrary limits<br />
for(i=0;i&lt;10;i++){}<br />
or set exit points<br />
for(;;){<br />
  &#8230;<br />
  if(0&gt;accept(&#8230;))<br />
    if(EAGAIN == errno || &#8230;<br />
      continue;<br />
    else<br />
      &#8230;<br />
      exit(EXIT_FAILURE)<br />
}<br />
These problems are well known and solved, but with the advent of real multithreading (multiprocessor systems) others arose, the most famous is probably the deadlock, another incarnation of the halting problem. Arbitrary limits won&#8217;t help in this case because of the simultaneousness of the locking attempts, you have to kill the simultaneousness, e.g. by adding different numbers of no-op&#8217;s per thread after each failed locking attempt. Sleeping a random length of time, adding a random number of no-op&#8217;s or releasing your time slice of the scheduler (e.g. with sched_yield() or similar) does not really solve it, btw!<br />
Some deadlocks are even detectable at runtime, see for example fcntl(2) which can throw the error EDEADLK to give the programer the option to act accordingly.</p>
<p>So, most of the problems are known, there are solutions for them or workarounds; sometimes ugly band-aids and also try-another-way&#8217;s of course if there is not even a mere band-aid known (in most cases a shiny sign of an error in the application logic). All of these solutions kill the turing completeness in one way or the other and that&#8217;s one of two ways to handle the halting problem. The other way is with a shotgun. At least according to Larry Wall.</p>
<blockquote><p>
  Some software companies even use formal proofs of correctness in production.
</p></blockquote>
<p>Yes, I know, I have one of these 😉</p>
<p>But a full proof is rarely done and needed. It would need a very expensive professional mathematician because you have to do that by hand. It&#8217;s only done for easy to prove and small parts like the design and queries of an relational database or the like.<br />
But it is quite common[1] here in Europe to use formal languages (mostly based on first-order predicate logic, like e.g. Z (ISO/IEC 13568:2002)) to describe the application logic exactly. It&#8217;s even a mandatory 101 course in the UK, as far as I know.<br />
The formal description together with a supportive language like SPARK-Ada (Ada without all of the bloat[2]) enables us to give the clients a warranty for fitness of purpose and that the applicaton is free of bugs[3].<br />
With roughly the same development costs and -time as the &#8220;classic&#8221; approach and you can sell it for a much higher price too.<br />
You can&#8217;t solve all problems with that approach (The language is not turing complete anymore as described above) but all common daily problems like bookkeeping, inventory control systems and so on. You can even handle the german taxation system with it and that is a really hard problem every year[4].</p>
<blockquote><p>
  However, there&#8217;s a catch. Such a proof can show that the program does what you told you wanted, not that it does what you actually want.
</p></blockquote>
<p>If you do not know what you actually want, well, that&#8217;s your problem not the problem of the formal language, isn&#8217;t it? 😉</p>
<p>But it is more than sufficient if the program does what it&#8217;s told to do. That&#8217;s what the formal description is good for: an exact and unambiguous description of the application logic so you can write tests for it.</p>
<p>A simple example:</p>
<p>Description:<br />
The application must put out &#8220;Hello world!&#8221;</p>
<p>Program 1:<br />
cat /dev/random|grep &#8220;Hello world!&#8221;</p>
<p>Program 2:<br />
head -c 1000m &lt;  /dev/random &gt; hi;<br />
echo -n &#8220;Hello world!&#8221; &gt;&gt; hi;<br />
head -c 1000m &lt;  /dev/random &gt;&gt; hi;<br />
cat hi;</p>
<p>Program 3:<br />
echo -n &#8220;Goodbye world!&#8221;</p>
<p>Program 4:<br />
echo -n &#8220;Hello world!&#8221;</p>
<p>Program 5:<br />
echo &#8220;Hello world!&#8221;</p>
<p>Program 6:<br />
#include &lt;stdio.h&gt;<br />
int main(void){<br />
putchar(&#8216;H&#8217;);putchar(&#8216;e&#8217;);putchar(&#8216;l&#8217;);putchar(&#8216;l&#8217;);putchar(&#8216;o&#8217;);<br />
putchar(&#8216; &#8216;);putchar(&#8216;W&#8217;);putchar(&#8216;o&#8217;);putchar(&#8216;r&#8217;);putchar(&#8216;l&#8217;);putchar(&#8216;d&#8217;);putchar(&#8216;!&#8217;);<br />
exit(EXIT_SUCCESS);<br />
}</p>
<p>So, please tell me: which one is correctly implementing the description?</p>
<p>As said above: it&#8217;s not the solution for all problems but it&#8217;s a really good tool to avoid a lot of them and should be a mandatory 101 class for every IT engineer because formal descriptions are the blueprints of computer engineers.</p>
<p>CZ</p>
<p>[1] OK, yes, you cannot call it &#8220;common&#8221;  but it is in contrast to the USA. The only company I know to offer it there is IBM.</p>
<p>[2] Something for a start: <a href="http://www.praxis-his.com/sparkada/downloads.asp" rel="nofollow ugc">http://www.praxis-his.com/sparkada/downloads.asp</a></p>
<p>[3] &#8220;bug-free&#8221; has only a legal meaning here: if a bug is found I have to repair it or give the money back and I&#8217;m also liable inside some legal and financial limits.</p>
<p>[4] some say that would prove P=NP. It doesn&#8217;t of course but it&#8217;s damn close.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38921">

			<div class="comment by-exdeccie-2 ">

				<p class="commentcredit">

					<span class="commenter">exdeccie-2</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38921">
						August 2, 2006 12:50 PM					</a>

				</p>

				<p>The postings by &#8220;exdeccie&#8221; [August 1, 2006 05:08 PM] and “Joe??? [August 1, 2006 03:09 PM] are more correct than that of Davi Ottenheimer when discussing the relationship between NT and VMS. I was involved with, amongst other projects, low-level memory management software while at DEC in the 80s/90s. As soon as Gates overrode Cutler when Cutler tried to design a true OS, that is, a ring architecture OS using hardware-based support for different privilege levels, which includes not doing dumb things like architecting the software to run app level code (level or ring 3) with kernel privs (level 0), where level 0 code could see and manipulate non-virtualized address spaces (the real hardware), Gates perpetuating all the problems associated with DOS where all code was put in the position of being trusted code (had to be trusted).  Put differently, in the Gatesian view of the world all code was simply presumed to act nicely.  Once that was done, all protection is gone, period.  Systems can, and have been, designed that do not allow app level code (untrusted code) to do anything but destroy itself and perhaps others using that app.  Untrusted code cannot bring down the whole system or even other users not using the untrusted code (too long a discussion to explain in detail here).  Finding an occasion code bug in a system designed this way is not the same as trying to make an inherently unsecure design “secure???.  That latter can’t be done.  All of us are now forced to live with that Gatesian legacy.  And yes, the management at DEC was absolutely terrible about all this as correctly pointed out by exdeccie, much to many, many people’s  great sadness.  We watched Olsen completely misread the small computer market, and then bring in the idiot Palmer to “save??? DEC (ha!).  Anyway, the point is that Gates overrode the talent he hired away from DEC, and in that sense NT is NOT any kind of successor to VMS.  NT is really a sort-of improved DOS, as influenced by people like Culter but as primarily controlled by Gates.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38922">

			<div class="comment by-samh ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://optimist.sdf-eu.org/ssp' rel='external nofollow ugc' class='url'>Samh</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38922">
						August 2, 2006 1:20 PM					</a>

				</p>

				<p>CZ wrote :<br />
&#8220;These problems are well known and solved, but with the advent of real multithreading (multiprocessor systems) others arose, the most famous is probably the deadlock, another incarnation of the halting problem.&#8221;</p>
<p>No, it&#8217;s not. There are 4 conditions that create a situation that can cause deadlock, if you remove these, deadlock does not happen.</p>
<p>But we are getting away from the point, which is prevention of integer overflows by a compiler, unless everyone concedes, at least for the time being, that it isn&#8217;t possible.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38923">

			<div class="comment by-benny ">

				<p class="commentcredit">

					<span class="commenter">Benny</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38923">
						August 2, 2006 3:56 PM					</a>

				</p>

				<p>Samh, you&#8217;re right, there are 4 conditions that lead to deadlock, and removing one of the four prevents deadlocks from happening (though often it is difficult or infeasible to remove one of the 4).  But CZ is also right, that deadlock is an instance of the halting problem.  More specifically, detecting a deadlock BEFORE it occurs is an instance of the halting problem.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38924">

			<div class="comment by-mike ">

				<p class="commentcredit">

					<span class="commenter">Mike</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38924">
						August 2, 2006 8:05 PM					</a>

				</p>

				<p>Samh,</p>
<p>You solution to buffer overflow is here:</p>
<p>java.sun.com</p>
<p>🙂</p>
<p>Oh my I know I know, but the fact remains, there are no buffer overlows in the language only in various implementaions of the runtime &#8211; easly fixed with proper C\C++ bounds checking.</p>
<p>Frankly, buffer overflows out to remain an problem until software quality improves. And that won&#8217;t happen until software companies are liable for these flaws.</p>
<p>All of this other stuff is just a high tech way to let companies continue to write bad code.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38925">

			<div class="comment by-davi-ottenheimer ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://davi.poetry.org/' rel='external nofollow ugc' class='url'>Davi Ottenheimer</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38925">
						August 2, 2006 9:00 PM					</a>

				</p>

				<p>@ exdeccie-2</p>
<p>We may be in violent agreement. My understanding was that Gates called Cutler at the end of the 80s and actually proposed the idea of a more stable &#8220;mission critical&#8221; version of Windows.</p>
<p>Gates managed to hire Cutler away from DEC even though he handed him an incredibly tight time-frame (three years to production?) and demanded a 16-bit Windows API and native support for Windows 3.x applications. Those were held up as <em>the</em> paramount goals by Gates but I think Cutler held on to a different view.</p>
<p>Here&#8217;s an excerpt from Cutler in the forward of &#8220;Inside Windows NT&#8221; by Helen Custer, 1993:</p>
<p>&#8220;Our goals for the system included portability, security, POSIX compliance, compatibility, scalable performance (multi processor support), extensibility, and the ease of internationalization. Of all these goals, by far the one that was hardest to achieve and that had the most profound effect in the structure of the system was compatibility.&#8221;</p>
<p>In that sense perhaps it was Cutler&#8217;s mistake for believing that he could achieve stability in an OS that could achieve Gates&#8217; time and functionality requirements, no?</p>
<p>So while I agree with you that Gates&#8217; directives sacrificed the long-term quality of the product for short-term sales, but I do not think that dissolves the nature of NT&#8217;s origins. From another perspective the initial platforms &#8212;  MIPS (DECstation) and Alpha &#8212; were changed to x86 but that doesn&#8217;t mean that Cutler did not try to support DEC hardware. He did&#8230;but it just didn&#8217;t turn out that way.</p>
<p>So perhaps &#8220;predecessor&#8221; was too strong/precise a word but you can at least agree that Cutler was hired by Microsoft to build a new Windows OS based on principles and experiences from his prior creation, VMS for the VAX-11. Things just went awry from there.</p>
<p>Back to the main thread, those who said symptoms are not the best place to address exploits are correct technically, but decisions are not always just technical. In fact, if Cutler&#8217;s original values had been honored by Microsoft from the start, it is very possible that the Windows platform might actually have been somewhat stable and resistant to attack. But on the other hand Gates&#8217; sacrifices have meant that the cost of mitigation, downtime and recovery from attacks on the Windows OS are burdens that consumers seem to continue to accept as the cost of doing business.</p>
<p>You may note that in the same book cited above, Cutler talks about the origins of VMS and concludes:</p>
<p>&#8220;Moral: The right thing to do technically isn&#8217;t always the best thing to do financially.&#8221;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38926">

			<div class="comment by-anonymous ">

				<p class="commentcredit">

					<span class="commenter">Anonymous</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38926">
						August 3, 2006 9:05 AM					</a>

				</p>

				<blockquote><p>
  But we are getting away from the point,
</p></blockquote>
<p>We are already quite away from the topic, which is something in the line of &#8220;preventing usage of buffer overflows by obfuscating memory adresses&#8221;, but as long as we don&#8217;t get kicked by the moderators &#8230;</p>
<blockquote><p>
  which is prevention of integer overflows by a compiler, unless everyone concedes, at least for the time being, that it isn&#8217;t possible.
</p></blockquote>
<p>If it is possible in one turing compatible language (e.g. Ada) it is possible in every turing compatible language e.g. in C[1]. Main difference between C and Ada is that all the bounds-checking in Ada is done by the compiler (you have to switch them off explicitly. But be carefull with that off-switching: your rocket might explode) but must be done by hand within C. It&#8217;s a repetitive task, so it&#8217;s errorprone if done by humans, so it&#8217;s a well suited task for a computer. Such scripts have been written several times, see for example the GCC patch I mentioned in an earlier post.</p>
<p>CZ</p>
<p>[1] this is not true of course for all of the arbitrary limits which kills the turing completeness needed for Church&#8217;s thesis in general. It goes down to an individual similarity tests: if it is possible to describe on algorithm in all of the involved languages and one of these languages has a build-in bounds-checker it is also possible to build bounds-checking in all other languages.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38927">

			<div class="comment by-christoph-zurnieden ">

				<p class="commentcredit">

					<span class="commenter">Christoph Zurnieden</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38927">
						August 3, 2006 9:11 AM					</a>

				</p>

				<p>Oops, forgot to sign my posting about &#8220;signing&#8221;, how embarrasing 😉</p>
<p>CZ</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38928">

			<div class="comment by-exdeccie-2 ">

				<p class="commentcredit">

					<span class="commenter">exdeccie-2</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38928">
						August 3, 2006 12:18 PM					</a>

				</p>

				<p>@  Davi Ottenheimer</p>
<p>I agreed, we are in violent agreement. I mistook the short description of the VMS-NT relationship for what I thought may have been a deeper misunderstanding, but I can see now actually wasn&#8217;t.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38929">

			<div class="comment by-rvnphnx ">

				<p class="commentcredit">

					<span class="commenter">RvnPhnx</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38929">
						August 3, 2006 2:34 PM					</a>

				</p>

				<p>Ok, I guess most of the folks here are software types&#8211;I&#8217;m more from the hardware end of things in my interests myself and therefore noticed a few things about this article and its purported fixes.<br />
Re: Memory Randomization<br />
True memory randomization cannot be done in protected mode on x86 hardware in an &#8220;on the fly&#8221; manner. This is due to the whole basic idea of protected mode: that memory belongs to one specific application and only to that application. Therefore it is worth noting that in improving performance in applications by multithreading we can easily introduce potentially exploitable code into our applications. Using separate processes uses more resources, but can be considered more secure in that one respect.<br />
That said, what is really going on with these &#8220;memory randomization&#8221; technologies is really that the base address of various segments becomes randomized. This does make cracking more difficult, but should not be confused with true randomization or even partial randomization (within the process&#8217; own address spaces&#8211;which can be a real nasty performance hit).<br />
Re: Instruction Munging<br />
I quote from the article: &#8220;Memory scrambling isn&#8217;t the only way to add diversity to operating systems. Even more sophisticated techniques are in the works. Forrest has tried altering &#8220;instruction sets&#8221;, commands that programs use to communicate with a computer&#8217;s hardware, such as its processor chip or memory.</p>
<p>Her trick was to replace the &#8220;translator&#8221; program that interprets these instruction sets with a specially modified one. Every time the computer boots up, Forrest&#8217;s software loads into memory and encrypts the instruction sets in the hardware using a randomised encoding key. When a program wants to send a command to the computer, Forrest&#8217;s translator decrypts the command on the fly so the computer can understand it.&#8221;<br />
Umm What?! An applications or OS programmer can obscure the data being passed about between hardware and software or can run the whole danged thing in a VM if he wants, but he cannot actually encrypt the actual physical instructions. Either somebody is smoking something, selling snake oil, or frankly just has no idea what the hey they are talking about here. Frankly, running an &#8220;encrypted&#8221; instruction set in a vm is little different from running that vm (or more aptly emulator) with an undisclosed instruction set.<br />
There is another problem with what is being stated in this article: If a new key is used on every boot then an unencrypted version of the original code must be made available at least once per boot cycle. This does not prevent code from being saved to the machine by a malicious third party and run at a later date. A problem like this can be mitigated by the use of some vm technologies, but bare (conventional) hardware is not (and cannot be as far as I know) up to this take alone.<br />
As has been stated all too many times already there is a fix for the buffer attack: true and even physical separation between data (not executable) and (executable) program memory.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38930">

			<div class="comment by-solinym ">

				<p class="commentcredit">

					<span class="commenter">solinym</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38930">
						August 4, 2006 9:09 AM					</a>

				</p>

				<p>@CZ:</p>
<p>&#8220;It is indeed possible to write bug-free code, you just can&#8217;t proof the code to be bug-free. That&#8217;s no special case of the Halting-Problem it is the Halting-Problem.&#8221;</p>
<p>Actually, you can&#8217;t prove that arbitrary programs are bug-free.  The null program is provably bug-free, albeit trivially.  Of course writing a proof (one often writes the code around the proof, since the latter is more terse) takes skill, and yes due to Godel&#8217;s Incompleteness Theorem, there is no perfect rule-based system for writing those proofs.</p>
<p>Provably correct code exists, there&#8217;s just not very much of it.  There may be bugs in the proof, in which case it&#8217;s almost considered a design error, since the proofs are much more terse than most programming languages.  One can only hope to write them in a language that is close to the problem domain, so that they aren&#8217;t unnecessarily complex.</p>
<p>However, writing network daemons in a buffer-safe language (e.g., python, Perl, ruby, ocaml, java, just about anything written since C) would eliminate 50% of the remote root vulnerabilities (by volume).  Not only that, but it&#8217;s more efficient in terms of programmer time, most of the time.  I go to great lengths to use the highest level tool for the job that I can get away with performance-wise; and I don&#8217;t ratchet down until I&#8217;ve written the smaller, higher-level program and profiled it and found why it wasn&#8217;t performing well enough.  Then the HLL version serves as a template, so my C code can end up looking like, say, procmail, which has an excellent security history.</p>
<p>@RvnPhnx: I&#8217;m with you, I don&#8217;t know how you&#8217;d encrypt your instructions, unless it&#8217;s the program loader which decrypts them when loading them from disk into memory, or you&#8217;ve done something really damn crazy with the silicon that I won&#8217;t be able to do at home.  Can someone please clarify what they mean by encrypting the instructions?  Are they by chance referring to the system calls, because that would be easy (and done before)?  Basically if you change the system call number for execve(2) in libc, and recompile everything, then a foreign binary or exploit that pops a shell is pretty unlikely to work.  You could even alarm that system call number so that it sets off klaxons, terminates the program, and kicks the person offline&#8230;.</p>
<p>I concur with the general drift that worrying about the mechanics of buffer overflows is wrong-headed; just don&#8217;t write in C!  We&#8217;ve known about buffer overflows since ALGOL, join the last three decades of programming language design&#8230; if Unix wasn&#8217;t so deeply wedded to C maybe people wouldn&#8217;t start writing in it so often&#8230; some things are hard to do in HLLs, like privilege manipulation (setuid), ioctls, decently fast crypto&#8230; very little else.  And even that stuff can be wrapped up in a library, and you can write the rest of the program in a HLL.  Really, the python-to-C and ruby-to-C bindings are a snap.</p>
<p>BTW, threads are less secure yet more efficient than seperate processes because they don&#8217;t cross a protection boundary; changing virtual memory mappings from one processes address space to another has a performance penalty of flushing the TLB, implementing new VM maps, reloading the segment registers (optionally, not done on Unix), reloading FP registers, etc.  Actually that&#8217;s done almost twice, since IPC has to be mediated by the kernel most of the time (mmap and SysV IPC excluded).  There are research OSes like L5 and others that focus on trying to minimize the cost of IPC&#8230; see the archive.org version of Patrick Bridge&#8217;s OS page.</p>
<p>If I had to name one thing that would improve Internet security that one coder could do, it would be to re-write the core Internet service daemons in a HLL.  Then we&#8217;d be virtually guaranteed of no buffer overflows, and errors would probably be easier to find.  Computers are fast, spend some cycles implementing defensive practices.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38931">

			<div class="comment by-christoph-zurnieden ">

				<p class="commentcredit">

					<span class="commenter">Christoph Zurnieden</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38931">
						August 4, 2006 3:49 PM					</a>

				</p>

				<p>@solinyn<br />
I really should be much more carefull with my writings here, especially in the details 😉</p>
<blockquote><p>
  [&#8230;] I don&#8217;t ratchet down until I&#8217;ve written the smaller, higher-level program and profiled it and found why it wasn&#8217;t performing well enough.
</p></blockquote>
<p>It is in most cases usefull to consider the acquisition of a bigger machine.<br />
A good programer wants to see more than US$25/h but let&#8217;s calculate with it. Including associated employer outlay it&#8217;s probably around US$35-40/h and if he needs 100 hours for the port (inclusive testing and documenting!) it sums up to US$3,500-4,000.<br />
It must be really slow or a very easy to port script before it&#8217;s worth that money.<br />
I guess that&#8217;s one of the main reasons for ruby-on-rails and the like.</p>
<p>CZ</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38932">

			<div class="comment by-spanneritwks ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://forum.sysinternals.com/' rel='external nofollow ugc' class='url'>SpannerITWks</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38932">
						August 22, 2006 9:12 PM					</a>

				</p>

				<p>If all it takes for a Buffer-Overflow to occurr, is to have a string of more than eight digits, why can&#8217;t the allocated space in the computer&#8217;s memory be restricted &#8221; somehow &#8221; to only allow an 8 digit string, to prevent this from ever happening ?</p>
<p>Only asking !</p>
<p>Spanner</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38933">

			<div class="comment by-roger ">

				<p class="commentcredit">

					<span class="commenter">Roger</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38933">
						August 23, 2006 3:34 AM					</a>

				</p>

				<p>@SpannerITWks:</p>
<blockquote><p>
  why can&#8217;t the allocated space in the computer&#8217;s memory be restricted &#8221; somehow &#8221; to only allow an 8 digit string,
</p></blockquote>
<p>It can be, and in good programming, usually is. (It&#8217;s not necessarily 8, by the way, it depends how much space the programmer thought would be needed.)</p>
<p>Buffer overflows are made possible by errors or oversights in programming, in particular memory management errors. They are nonexistent, or at least extremely rare, in languages which automatically manage memory for the programmer instead of requiring explicit coding for it (however this may be at the cost of reduced performance). In other languages they can be greatly reduced by good programming discipline and use of safer libraries. They frequently come from legacy code written before the problem was as widely appreciated; in new code, it is generally a sign of sloppiness.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-38934">

			<div class="comment by-spanneritwks ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://forum.sysinternals.com/' rel='external nofollow ugc' class='url'>SpannerITWks</a></span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38934">
						August 23, 2006 4:46 PM					</a>

				</p>

				<p>Rodger</p>
<p>Aha, so it&#8217;s the Programmers fault, and reliance on legacy sloppy code too !</p>
<p>So apart from the above, it sounds like they trade off good memory management etc for speed etc.</p>
<p>I wonder just much % trade off is involved, and these days with billy whiz bang GHz brains + Gbyte RAM and Fast HD&#8217;s etc how much &#8221; noticable &#8221; difference there would actually be, if they did it properly ?</p>
<p>Maybe another factor could be using languages other than for eg C and it&#8217;s variants and the like, and going for &#8221; easier &#8221; quicker fixes ? More room for more inbuilt errors/sloppiness etc !</p>
<p>I say &#8221; easier &#8221; not that i can programme, so i acknowledge even &#8221; easy &#8221; isn&#8217;t all that easy, not to me anyway lol.</p>
<p>Thanx</p>
<p>Regards</p>
<p>Spanner</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-38935">

			<div class="comment by-phred14 ">

				<p class="commentcredit">

					<span class="commenter">phred14</span> •

					<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/#comment-38935">
						October 20, 2006 7:51 AM					</a>

				</p>

				<p>@solinym</p>
<blockquote><p>
  Actually, you can&#8217;t prove that arbitrary programs are bug-free. The null program is provably bug-free, albeit trivially.
</p></blockquote>
<p>There&#8217;s actually a chunk of humor behind this one&#8230; The classic &#8220;null program&#8221; was IBM&#8217;s IEFBR14 that ran on mainframes. The name contained the program, it was &#8220;branch R14&#8221;, where R14 contained the return address. One line of code, yet it managed to have something like 3 APARs against it. The APARs weren&#8217;t actually with the one line of code, but the gobbledegook that had to surround it. Still, at something like 300%, it was the highest bug rate ever.</p>
<p>IEFBR14 was generally used in JCL in order to get side-effects. With JCL you attached files to a job step, with dispositions. The dispositions could be used to create, delete, etc files. The job step was typically IEFBR14, and all your really cared about was the disposition.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

	<p class="subscribe-comments">
		<a href="https://www.schneier.com/blog/archives/2006/08/security_and_mo.html/feed/">
			<img alt="Atom Feed" src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/rss.png">
			Subscribe to comments on this entry		</a>
	</p>

		<div id="respond" class="comment-respond">
		<h2 class="comments-open-header">Leave a comment <small><a rel="nofollow" id="cancel-comment-reply-link" href="/blog/archives/2006/08/security_and_mo.html#respond" style="display:none;">Cancel reply</a></small></h2><form action="https://www.schneier.com/wp-comments-post.php" method="post" id="commentform" class="comment-form" novalidate><a href="https://www.schneier.com/wp-login.php?redirect_to=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2006%2F08%2Fsecurity_and_mo.html" title="Login">Login</a><p class="comment-form-author"><label for="author">Name</label> <input id="author" name="author" type="text" value="" size="30" maxlength="245" /></p>
<p class="comment-form-email"><label for="email">Email</label> <input id="email" name="email" type="email" value="" size="30" maxlength="100" /></p>
<p class="comment-form-url"><label for="url">URL:</label> <input id="url" name="url" type="url" value="" size="30" maxlength="200" /></p>
<p class="comment-form-cookies-consent"><input id="wp-comment-cookies-consent" name="wp-comment-cookies-consent" type="checkbox" value="yes" /> <label for="wp-comment-cookies-consent">Remember personal info?</label></p>

<p class="comment-form-author">

	<label for="comm_capt_challenge">
		Fill in the blank: the name of this blog is Schneier on ___________ (required):	</label>

	<input id="comm_capt_challenge" name="comm_capt_challenge" size="30" type="text" />
</p>

<div class="comment-form-comment">

	<label for="comment">Comments:</label>

	<textarea id="comment" name="comment" cols="45" rows="8" maxlength="65525" required="required"></textarea>

	<div id="preview-box" class="preview-box hide"></div>
	<img class="comment-loading hide" src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/loader.gif" />

</div>

<p id="allowed">

	<strong>Allowed HTML</strong>
	&lt;a href=&quot;URL&quot;&gt; &bull; &lt;em&gt; &lt;cite&gt; &lt;i&gt; &bull; &lt;strong&gt; &lt;b&gt; &bull; &lt;sub&gt; &lt;sup&gt; &bull; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &bull; &lt;blockquote&gt; &lt;pre&gt;
	<strong>Markdown Extra</strong> syntax via <a href="https://michelf.ca/projects/php-markdown/extra/">https://michelf.ca/projects/php-markdown/extra/</a>
</p>

<input type="hidden" id="wp_comment_nonce" name="wp_comment_nonce" value="4b1534b792" /><input type="hidden" name="_wp_http_referer" value="/blog/archives/2006/08/security_and_mo.html" />
<input type="button" id="comment-preview" class="comment-preview comment-actions" value="Preview" />
<input type="button" id="comment-write" class="comment-write comment-actions hide" value="Edit" />

<p class="form-submit"><input name="submit" type="submit" id="submit" class="submit" value="Submit" /> <input type='hidden' name='comment_post_ID' value='1045' id='comment_post_ID' />
<input type='hidden' name='comment_parent' id='comment_parent' value='0' />
</p></form>	</div><!-- #respond -->
	
	<div class="stepthrough">
		<a href="https://www.schneier.com/blog/archives/2006/07/scatterchat.html" rel="prev">← ScatterChat</a>		<a href="https://www.schneier.com/blog/archives/2006/08/updating_the_tr.html" rel="next">Updating the Traditional Security Model →</a>	</div>

	
<p id="powered">Sidebar photo of Bruce Schneier by Joe MacInnis.</p>
		</div>

		
<aside>
	<div class="sidebar" id="sidebar-two">
		<section><div class="sidesection widget widget_schneier_about" id="schneier_about-2"><h3>About Bruce Schneier</h3><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/Bruce-Schneier.jpg" /><p><p class="small">I am a <a href="https://public-interest-tech.com/">public-interest technologist</a>, working at the intersection of security, technology, and people. I've been writing about security issues on my <a href="/">blog</a> since 2004, and in my monthly <a href="/crypto-gram/">newsletter</a> since 1998. I'm a fellow and lecturer at Harvard's <a href="https://www.hks.harvard.edu/faculty/bruce-schneier">Kennedy School</a>, a board member of <a href="https://www.eff.org/">EFF</a>, and the Chief of Security Architecture at <a href="https://inrupt.com/">Inrupt, Inc.</a> This personal website expresses the opinions of none of those organizations.</p>
</p></div></section><section><div class="sidesection widget widget_schneier_related_posts" id="schneier_related_posts-2"><h3>Related Entries</h3>
<ul>

	<li><a href="https://www.schneier.com/blog/archives/2021/03/illegal-content-and-the-blockchain.html">Illegal Content and the Blockchain</a></li><li><a href="https://www.schneier.com/blog/archives/2021/03/national-security-risks-of-late-stage-capitalism.html">National Security Risks of Late-Stage Capitalism</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/weis-2021-call-for-papers.html">WEIS 2021 Call for Papers</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/ransomware-profitability.html">Ransomware Profitability</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/presidential-cybersecurity-and-pelotons.html">Presidential Cybersecurity and Pelotons</a></li><li><a href="https://www.schneier.com/blog/archives/2021/01/police-have-disrupted-the-emotet-botnet.html">Police Have Disrupted the Emotet Botnet</a></li>
</ul>
</div></section><section><div class="sidesection widget widget_schneier_featured_essays" id="schneier_featured_essays-2"><h3>Featured Essays</h3>
	<ul>
		<li><a href="https://www.schneier.com/essays/archives/2016/04/the_value_of_encrypt.html">The Value of Encryption</a></li><li><a href="https://www.schneier.com/essays/archives/2016/03/data_is_a_toxic_asse.html">Data Is a Toxic Asset, So Why Not Throw It Out?</a></li><li><a href="https://www.schneier.com/essays/archives/2014/01/how_the_nsa_threaten.html">How the NSA Threatens National Security</a></li><li><a href="https://www.schneier.com/essays/archives/2009/01/terrorists_may_use_g.html">Terrorists May Use Google Earth, But Fear Is No Reason to Ban It</a></li><li><a href="https://www.schneier.com/essays/archives/2007/01/in_praise_of_securit.html">In Praise of Security Theater</a></li><li><a href="https://www.schneier.com/essays/archives/2006/08/refuse_to_be_terrori.html">Refuse to be Terrorized</a></li><li><a href="https://www.schneier.com/essays/archives/2006/05/the_eternal_value_of.html">The Eternal Value of Privacy</a></li><li><a href="https://www.schneier.com/essays/archives/2005/09/terrorists_dont_do_m.html">Terrorists Don&#039;t Do Movie Plots</a></li>	</ul>

	<p><a href="https://www.schneier.com/essays/">More Essays</a></p></div></section><section><div class="sidesection widget widget_schneier_archives" id="schneier_archives-2"><h3>Blog Archives</h3>
<ul>

	<li><a href="https://www.schneier.com/blog/calendar.html/">Archive by Month</a></li><li><a href="https://www.schneier.com/blog/newcomments.html/">100 Latest Comments</a></li></ul>

<h4>Blog Tags</h4><ul class="top-tags"><li><a href="https://www.schneier.com/tag/3d-printers/">3d printers</a></li><li><a href="https://www.schneier.com/tag/9-11/">9/11</a></li><li><a href="https://www.schneier.com/tag/aaron-swartz/">Aaron Swartz</a></li><li><a href="https://www.schneier.com/tag/academic/">academic</a></li><li><a href="https://www.schneier.com/tag/academic-papers/">academic papers</a></li><li><a href="https://www.schneier.com/tag/accountability/">accountability</a></li><li><a href="https://www.schneier.com/tag/aclu/">ACLU</a></li><li><a href="https://www.schneier.com/tag/activism/">activism</a></li><li><a href="https://www.schneier.com/tag/adobe/">Adobe</a></li><li><a href="https://www.schneier.com/tag/advanced-persistent-threats/">advanced persistent threats</a></li><li><a href="https://www.schneier.com/tag/adware/">adware</a></li><li><a href="https://www.schneier.com/tag/aes/">AES</a></li><li><a href="https://www.schneier.com/tag/afghanistan/">Afghanistan</a></li><li><a href="https://www.schneier.com/tag/air-marshals/">air marshals</a></li><li><a href="https://www.schneier.com/tag/air-travel/">air travel</a></li><li><a href="https://www.schneier.com/tag/airgaps/">airgaps</a></li><li><a href="https://www.schneier.com/tag/al-qaeda/">al Qaeda</a></li><li><a href="https://www.schneier.com/tag/alarms/">alarms</a></li><li><a href="https://www.schneier.com/tag/algorithms/">algorithms</a></li><li><a href="https://www.schneier.com/tag/alibis/">alibis</a></li><li><a href="https://www.schneier.com/tag/amazon/">Amazon</a></li><li><a href="https://www.schneier.com/tag/android/">Android</a></li><li><a href="https://www.schneier.com/tag/anonymity/">anonymity</a></li><li><a href="https://www.schneier.com/tag/anonymous/">Anonymous</a></li><li><a href="https://www.schneier.com/tag/antivirus/">antivirus</a></li><li><a href="https://www.schneier.com/tag/apache/">Apache</a></li><li><a href="https://www.schneier.com/tag/apple/">Apple</a></li><li><a href="https://www.schneier.com/tag/applied-cryptography/">Applied Cryptography</a></li><li><a href="https://www.schneier.com/tag/artificial-intelligence/">artificial intelligence</a></li><li><a href="https://www.schneier.com/tag/assassinations/">assassinations</a></li></ul><p><a href="https://www.schneier.com/blog/tags.html/">More Tags</a></p></div></section><section><div class="sidesection widget widget_schneier_latest_book" id="schneier_latest_book-3"><h3>Latest Book</h3><a href="https://www.schneier.com/books/click-here/"><img class="sidepic" alt="Click Here to Kill Everybody" src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2018/07/book-ch2-200w.png" /></a><p><a href="https://www.schneier.com/books/">More Books</a></p></div></section><section><div class="sidesection widget widget_schneier_promotion" id="schneier_promotion-2">
<a href="https://www.eff.org/issues/bloggers/legal/join">
	<img src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/join-eff@2x.png" id="effbutton" alt="Support Bloggers' Rights!" title="Support Bloggers' Rights!" /></a>

<a href="https://npo.networkforgood.org/Donate/Donate.aspx?npoSubscriptionId=8252">
	<img src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/support-epic@2x.png" alt="Defend Privacy--Support Epic" title="Defend Privacy--Support Epic" /></a>
</div></section>	</div>
</aside>

		<footer>
			<nav>
				<div class="nav" id="footer-nav">
					<div class="menu-main-menu-container"><ul id="menu-main-menu-1" class="menu"><li class="menu1 menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-50175 current-menu-item"><a href="https://www.schneier.com">Blog</a></li>
<li class="menu2 menu-item menu-item-type-post_type menu-item-object-page menu-item-50916"><a href="https://www.schneier.com/crypto-gram/">Newsletter</a></li>
<li class="menu3 menu-item menu-item-type-post_type menu-item-object-page menu-item-50166"><a href="https://www.schneier.com/books/">Books</a></li>
<li class="menu4 menu-item menu-item-type-custom menu-item-object-custom menu-item-50169"><a href="https://www.schneier.com/essays/">Essays</a></li>
<li class="menu5 menu-item menu-item-type-custom menu-item-object-custom menu-item-50170"><a href="https://www.schneier.com/news/">News</a></li>
<li class="menu6 menu-item menu-item-type-custom menu-item-object-custom menu-item-50171"><a href="https://www.schneier.com/talks/">Talks</a></li>
<li class="menu7 menu-item menu-item-type-post_type menu-item-object-page menu-item-50167"><a href="https://www.schneier.com/academic/">Academic</a></li>
<li class="menu8 menu-item menu-item-type-post_type menu-item-object-page menu-item-50174"><a href="https://www.schneier.com/blog/about/">About Me</a></li>
</ul></div>				</div>
			</nav>
		</footer>

		</div><!--#main-->
	</div><!--#wrapper-->

		<script type="text/javascript">
		(function () {
			var c = document.body.className;
			c = c.replace(/woocommerce-no-js/, 'woocommerce-js');
			document.body.className = c;
		})();
	</script>
	<script type='text/javascript' src='https://c0.wp.com/p/woocommerce/5.1.0/assets/js/jquery-cookie/jquery.cookie.min.js' id='jquery-cookie-js'></script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/vendor/socialshareprivacy/js/socialshareprivacy.js?ver=1.0.1' id='social-share-privacy-js'></script>
<script type='text/javascript' id='social-share-privacy-icons-js-extra'>
/* <![CDATA[ */
var schneierSocial = {"path":"https:\/\/www.schneier.com\/wp-content\/themes\/schneier\/assets\/vendor\/socialshareprivacy\/"};
/* ]]> */
</script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/vendor/socialshareprivacy/js/icons.js?ver=1.0.0' id='social-share-privacy-icons-js'></script>
<script type='text/javascript' id='schneier-comment-js-extra'>
/* <![CDATA[ */
var schneierComment = {"translateErrorSecurityAnswerWrong":"Your response to the challenge question ('The name of this blog is Schneier on ____') was not correct. Please try again.","ajax_url":"https:\/\/www.schneier.com\/wp-admin\/admin-ajax.php"};
/* ]]> */
</script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/js/comment.js?ver=1.0.1' id='schneier-comment-js'></script>
<script type='text/javascript' src='https://c0.wp.com/c/5.7/wp-includes/js/wp-embed.min.js' id='wp-embed-js'></script>

</body>

</html>
