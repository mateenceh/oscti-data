<!DOCTYPE html>
<html lang="en-US">

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<title>Microsoft Bans Memcopy() - Schneier on Security</title>
	<meta name='robots' content='max-image-preview:large' />
<link rel='dns-prefetch' href='//s.w.org' />
<link rel='dns-prefetch' href='//c0.wp.com' />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Feed" href="https://www.schneier.com/feed/" />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Comments Feed" href="https://www.schneier.com/comments/feed/" />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Microsoft Bans Memcopy() Comments Feed" href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/feed/" />
<link rel='stylesheet' id='wp-block-library-css'  href='https://c0.wp.com/c/5.7/wp-includes/css/dist/block-library/style.min.css' type='text/css' media='all' />
<style id='wp-block-library-inline-css' type='text/css'>
.has-text-align-justify{text-align:justify;}
</style>
<style id='woocommerce-inline-inline-css' type='text/css'>
.woocommerce form .form-row .required { visibility: visible; }
</style>
<link rel='stylesheet' id='schneier-css'  href='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/style.css?ver=1.0.0' type='text/css' media='all' />
<link rel='stylesheet' id='schneier-main-css'  href='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/dist/css/style.css?ver=1.0.2' type='text/css' media='all' />
<link rel='stylesheet' id='jetpack_css-css'  href='https://c0.wp.com/p/jetpack/9.5.2/css/jetpack.css' type='text/css' media='all' />
<script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js?ver=3.5.1' id='jquery-js'></script>
<link rel="https://api.w.org/" href="https://www.schneier.com/wp-json/" /><link rel="alternate" type="application/json" href="https://www.schneier.com/wp-json/wp/v2/posts/2849" /><link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://www.schneier.com/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://www.schneier.com/wp-includes/wlwmanifest.xml" /> 

<link rel="canonical" href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html" />
<link rel='shortlink' href='https://www.schneier.com/?p=2849' />
<link rel="alternate" type="application/json+oembed" href="https://www.schneier.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2009%2F05%2Fmicrosoft_bans.html" />
<link rel="alternate" type="text/xml+oembed" href="https://www.schneier.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2009%2F05%2Fmicrosoft_bans.html&#038;format=xml" />
	<noscript><style>.woocommerce-product-gallery{ opacity: 1 !important; }</style></noscript>
	<link rel="icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-32x32.png" sizes="32x32" />
<link rel="icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-180x180.png" />
<meta name="msapplication-TileImage" content="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-270x270.png" />
		<style type="text/css" id="wp-custom-css">
			#schneier_promotion-2 img {
    max-width: 180px;
}		</style>
		</head>

<body class="post-template-default single single-post postid-2849 single-format-standard theme-schneier woocommerce-no-js">

	<div id="wrapper">
		<div id="main">

			<header>
				<div id="header">
					<h1>
						<a href="https://www.schneier.com/" rel="home">
							Schneier on Security						</a>
					</h1>
				</div>
			</header>

			<nav>
				<div class="nav" id="header-nav">
					<div class="menu-main-menu-container"><ul id="menu-main-menu" class="menu"><li id="menu-item-50175" class="menu1 menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-50175 current-menu-item"><a href="https://www.schneier.com">Blog</a></li>
<li id="menu-item-50916" class="menu2 menu-item menu-item-type-post_type menu-item-object-page menu-item-50916"><a href="https://www.schneier.com/crypto-gram/">Newsletter</a></li>
<li id="menu-item-50166" class="menu3 menu-item menu-item-type-post_type menu-item-object-page menu-item-50166"><a href="https://www.schneier.com/books/">Books</a></li>
<li id="menu-item-50169" class="menu4 menu-item menu-item-type-custom menu-item-object-custom menu-item-50169"><a href="https://www.schneier.com/essays/">Essays</a></li>
<li id="menu-item-50170" class="menu5 menu-item menu-item-type-custom menu-item-object-custom menu-item-50170"><a href="https://www.schneier.com/news/">News</a></li>
<li id="menu-item-50171" class="menu6 menu-item menu-item-type-custom menu-item-object-custom menu-item-50171"><a href="https://www.schneier.com/talks/">Talks</a></li>
<li id="menu-item-50167" class="menu7 menu-item menu-item-type-post_type menu-item-object-page menu-item-50167"><a href="https://www.schneier.com/academic/">Academic</a></li>
<li id="menu-item-50174" class="menu8 menu-item menu-item-type-post_type menu-item-object-page menu-item-50174"><a href="https://www.schneier.com/blog/about/">About Me</a></li>
</ul></div>				</div>
			</nav>

			
<aside>
	<div class="sidebar" id="sidebar-one">
		<section><div class="sidesection widget widget_schneier_search" id="schneier_search-3"><h3>Search</h3>
<p class="small">
	<em>Powered by <a href="https://duckduckgo.com/">DuckDuckGo</a></em></p>

<form method="get" action="https://duckduckgo.com/">

	<input type="hidden" name="kh" value="1" /><!-- use https -->

	<input id="search" name="q" size="15" maxlength="255" />

	<input type="submit" value="Go" /><br>

	<input type="radio" name="sites" id="searchblog" value="www.schneier.com/blog" />
	<label for="searchblog">Blog</label>

	<input type="radio" name="sites" id="searchessays" value="www.schneier.com/essays" />
	<label for="searchessays">Essays</label>

	<input type="radio" name="sites" id="searchall" value="www.schneier.com" checked="" />
	<label for="searchall">Whole site</label>

</form>
</div></section><section><div class="sidesection widget widget_schneier_social" id="schneier_social-2"><h3>Subscribe</h3>
<div id="subscription-buttons">

	<a href="https://www.schneier.com/feed/atom"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/rss-32px.png" alt="Atom Feed" /></a><a href="https://www.facebook.com/bruce.schneier"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/facebook-32px.png" alt="Facebook" /></a><a href="https://twitter.com/schneierblog/"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/twitter-32px.png" alt="Twitter" /></a><a href="https://www.amazon.com/Schneier-on-Security/dp/B0053HDDWW/"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/kindle-32px.png" alt="Kindle" /></a><a href="https://www.schneier.com/crypto-gram"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/email-32px.png" alt="E-Mail Newsletter (Crypto-Gram)" /></a>
</div>
</div></section>	</div>
</aside>

			<div id="content">

				
		<p id="breadcrumbs">

			<a href="https://www.schneier.com">Home</a><a href="https://www.schneier.com/blog/archives/">Blog</a>		</p>

		
<article id="post-2849" class="post-2849 post type-post status-publish format-standard hentry category-uncategorized tag-microsoft tag-operating-systems tag-windows">

	<div class="article">

		<h2 class="entry">Microsoft Bans Memcopy()</h2>
		<p><a href="http://www.theregister.co.uk/2009/05/15/microsoft_banishes_memcpy/">This</a> seems smart:</p>
<blockquote><p>Microsoft plans to formally banish the popular programming function that&#8217;s been responsible for an untold number of security vulnerabilities over the years, not just in Windows but in countless other applications based on the C language. Effective later this year, Microsoft will add memcpy(), CopyMemory(), and RtlCopyMemory() to its list of function calls <a href="http://s.msdn.com/sdl/archive/2008/10/22/good-hygiene-and-banned-apis.aspx">banned under its secure development lifecycle</a>.</p></blockquote>
<p>Here&#8217;s the <a href="http://msdn.microsoft.com/en-us/library/bb288454.aspx">list of banned function calls</a>.  This doesn&#8217;t help secure legacy code, of course, but you have to start somewhere.</p>

		
			<p class="entry-tags">
				<span class="tags-links">Tags: <a href="https://www.schneier.com/tag/microsoft/" rel="tag">Microsoft</a>, <a href="https://www.schneier.com/tag/operating-systems/" rel="tag">operating systems</a>, <a href="https://www.schneier.com/tag/windows/" rel="tag">Windows</a></span>			</p>

		
		
		<p class="posted">
			<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html" rel="bookmark">Posted on May 20, 2009 at 6:17 AM</a>			•
			<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html#comments">85 Comments</a>		</p>

		<aside><div class="schneier-share share" data-uri="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html" data-title="Microsoft Bans Memcopy()" data-order="facebook twitter tumblr" data-social-share-privacy="true" /></aside>
	</div>

</article>


	<h3 id="comments">Comments</h3>

	
		<article class="comment even thread-even depth-1" id="comment-113027">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113027">
						May 20, 2009 9:15 AM					</a>

				</p>

				<p>As discussed a few days ago on this blog there are better ways to go these days than with C/C++.</p>
<p>Unfortunatly after something like 40years the assumptions about the resources are the other way around these days (ie Hardware=cheep Humans=expensive).</p>
<p>We need to think of a suitable high level language without the faults but still retaining the power and compactness.</p>
<p>Oh and please please thing up a better way to delcare variables (it&#8217;s a night mare hence so many pointers to void, and the risks ascociated).</p>
<p>I think both K&amp;R have said they would change the precedence and ascociative behaviour in C&#8230;</p>
<p>Oh and perhaps we should stop thinking of &#8220;files&#8221; being the basic data/comms model I&#8217;m sure there are better ways to do it.</p>
<p>But hey Rome was not built in a day 8)</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113028">

			<div class="comment by-jrm ">

				<p class="commentcredit">

					<span class="commenter">JRM</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113028">
						May 20, 2009 10:15 AM					</a>

				</p>

				<p>It&#8217;s not all that smart. The &#8220;safe&#8221; version just includes an extra length parameter (of the target buffer). If the programmer knows both sizes, a good program will already check, and a bad program will just pass the same size as both lengths, or define a lazy workaround:</p>
<p>#define memcpy(dst, src, len) memcpy_s(dst, len, src, len)</p>
<p>Since the programmer now has to check the return value of memcpy_s() (instead of the sizes of the buffer and copy), there&#8217;s no saving in error-handling code.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113029">

			<div class="comment by-david ">

				<p class="commentcredit">

					<span class="commenter">David</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113029">
						May 20, 2009 10:17 AM					</a>

				</p>

				<p>If there are significant numbers of pointers to void in your C++ code, either you&#8217;re doing low-level stuff (which cannot effectively be done using a &#8220;safe&#8221; language), or you&#8217;re doing it wrong.  It&#8217;s perfectly possible to write good, secure C++ code (and very easy to write the other sort, true).</p>
<p>I wouldn&#8217;t want to write a user app in C, though.  There&#8217;s too much that can go wrong, and there are languages that are more expressive and safer (C++, C#, Java, Lisp&#8230;).</p>
<p>That being said, I don&#8217;t see what&#8217;s so bad with memcpy().  The issue with sprintf(), sscanf(), gets(), strcpy(), and others like them, is that there is no particular reason why they couldn&#8217;t overwrite all sorts of memory if something unexpected happened.  With memcpy(), you specify the number of bytes to move, much like snprintf(), fgets(), and strncpy().  There are a lot of C functions that should be banned from use, but memcpy() sure doesn&#8217;t look like one of them to me.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113030">

			<div class="comment by-roboticus ">

				<p class="commentcredit">

					<span class="commenter">Roboticus</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113030">
						May 20, 2009 10:29 AM					</a>

				</p>

				<p>In Writing Secure Code For Windows Vista, Michael Howard and David LeBlanc (Microsoft security dudes) say &#8220;if we see the function call used in three or more security bugs, we ban that function for new code.&#8221; If it took this long for memcpy to be used in 3 bugs in Microsoft code that is actually amazing.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113031">

			<div class="comment by-jack ">

				<p class="commentcredit">

					<span class="commenter">Jack</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113031">
						May 20, 2009 10:30 AM					</a>

				</p>

				<p>I&#8217;m guessing this is not a philosophical list, but a &#8220;That is the fifteenth thousandth security exploit involving memcopy, it&#8217;s going on the list&#8221; list.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113032">

			<div class="comment by-todd-knarr ">

				<p class="commentcredit">

					<span class="commenter">Todd Knarr</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113032">
						May 20, 2009 10:42 AM					</a>

				</p>

				<p>The big problem with the prohibition is that isn&#8217;t not memcpy() that&#8217;s the problem. The problem is programmers who don&#8217;t think about buffer lengths while writing code, who simply don&#8217;t bother doing the work to check sizes correctly. For instance, when passing a destination buffer into a function, rather than going &#8220;Oh, I don&#8217;t know it&#8217;s size, I need to change the API to pass that in so my function can check whether the destination&#8217;s big enough.&#8221;, they go &#8220;I don&#8217;t know the size, so it&#8217;s the caller&#8217;s responsibility to pass in a big enough buffer. Gee, that made my job easier&#8230;&#8221;. Banning memcpy() won&#8217;t help, because programmers like that will continue to find ways to not think about that no matter what you do. You&#8217;ll either do nothing to help the problem, or you&#8217;ll make the code with the problem in it more obscure and harder to spot.</p>
<p>Trying to idiot-proof a system&#8217;s a losing proposition, because the universe keeps coming up with better idiots.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113033">

			<div class="comment by-marcos ">

				<p class="commentcredit">

					<span class="commenter">Marcos</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113033">
						May 20, 2009 10:44 AM					</a>

				</p>

				<p>I also fail to see the problem of memcpy, or, more specificaly, I see how it can be missused (using strlen as the length argument), but the person that does such a thing will create vunerabilities with any API on any language you care to name.</p>
<p>Also, why is sprintf on that list? Should people only use asprintf?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113034">

			<div class="comment by-marc-b ">

				<p class="commentcredit">

					<span class="commenter">Marc B.</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113034">
						May 20, 2009 10:49 AM					</a>

				</p>

				<p>Stupid, stupid, stupid.</p>
<p>memcpy_s throws exceptions right and left, if the parameters are not checked thoroughly.  So you have the same issue as with memcpy &#8211; you are responsible to sanitize all the input into your routines.</p>
<p>It is completely irrelevant which function you use.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113035">

			<div class="comment by-adam ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://blogs.msdn.com/sdl' rel='external nofollow ugc' class='url'>Adam</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113035">
						May 20, 2009 10:51 AM					</a>

				</p>

				<p>Marcos,</p>
<p>Sprintf is on the list because of format string issues.</p>
<p>Anyone looking for more information on where to start should take a look at our Security Development Lifecycle pages (microsoft.com/sdl) and the optimization model, which is all about how to get started.</p>
<p>Because Bruce is right&#8211;you have to start somewhere, and this is a step along the way, and part of how our SDL is evolving.  It&#8217;s not one thing to do in isolation.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113036">

			<div class="comment by-ben-combee ">

				<p class="commentcredit">

					<span class="commenter">Ben Combee</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113036">
						May 20, 2009 10:58 AM					</a>

				</p>

				<p>sprintf is best replaced by snprintf which takes a buffer length so you can&#8217;t write past the end of the destination buffer.  asprintf is also useful if you don&#8217;t know what your max length will be and you&#8217;re OK with allocating memory.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113037">

			<div class="comment by-tim ">

				<p class="commentcredit">

					<span class="commenter">Tim</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113037">
						May 20, 2009 11:05 AM					</a>

				</p>

				<p>&#8220;If there are significant numbers of pointers to void in your C++ code, either you&#8217;re doing low-level stuff (which cannot effectively be done using a &#8220;safe&#8221; language), or you&#8217;re doing it wrong.&#8221;</p>
<p>Exactly. C++ is a great language. D looks good too. Would be nice if there was a byte code version of C++ though to avoid the whole recompilation issue. Java is just evil (seriously who designed StringBuilder?). Haven&#8217;t tried C# though. Is it any less evil than Java?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113038">

			<div class="comment by-rev-matt ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.revmatt.com' rel='external nofollow ugc' class='url'>Rev Matt</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113038">
						May 20, 2009 11:06 AM					</a>

				</p>

				<p>Programmers are writing bad code, rather than provide adequate training or fix the peer review process let&#8217;s ban the use of this function.  So the developers don&#8217;t learn how to write secure code, but instead write insecure code using something other than memcopy.  Brilliant nonsolution.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113039">

			<div class="comment by-kangaroo ">

				<p class="commentcredit">

					<span class="commenter">kangaroo</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113039">
						May 20, 2009 11:14 AM					</a>

				</p>

				<p>I&#8217;ve never seen you this wrong before, Bruce. The problem is programmers that are working above their pay-grade &#8212; no &#8220;process&#8221; is going to fix that, other than hiring better folks, paying them more, and working them less.</p>
<p>It&#8217;s particularly idiotic to go via a statistical analysis to decide what are &#8220;evil&#8221; functions. The misuse of functions don&#8217;t point to a problem in the function &#8212; they either point to a poor choice in methods (innappropriate programming language, review process, &#8230;) or poor choice in employees.</p>
<p>Papering it over with some &#8220;ban&#8221; is only making the problem worse &#8212; it&#8217;s &#8220;programming theater&#8221; that puts a problem under the carpet, rather than a solution in any way. &#8220;You have to start somewhere&#8221; is just a cry of despair &#8212; no, you have to start in the right place, starting &#8220;somewhere&#8221; is just marketing.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113040">

			<div class="comment by-nathan ">

				<p class="commentcredit">

					<span class="commenter">Nathan</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113040">
						May 20, 2009 11:14 AM					</a>

				</p>

				<p>I&#8217;m with Todd. This is just syntactic sugar, plain and simple. This is a perfectly valid and reasonable implementation of memcpy_s(), right?</p>
<p>#define memcpy_s(a,b,c,d) memcpy(a,c,min(b,d))</p>
<p>This is not going to help the programmers who simply fail to think about what will happen when their code actually runs, in any way. The only thing this change has to do with security is the false sense of such.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113041">

			<div class="comment by-david ">

				<p class="commentcredit">

					<span class="commenter">David</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113041">
						May 20, 2009 11:17 AM					</a>

				</p>

				<p>/Opens disk editor. &#8220;Why are my afp passwords appearing in unused regions of this word document? Didn&#8217;t I turn that in as homework, only to have it posted on the course website?&#8221;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113042">

			<div class="comment by-david ">

				<p class="commentcredit">

					<span class="commenter">David</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113042">
						May 20, 2009 11:20 AM					</a>

				</p>

				<p>Isn&#8217;t this sort of a programming variation of an &#8220;Are you sure?&#8221; window popping up?  The first time it pops up, perhaps the programmer will think about checking the sizes of the buffers.  After the 4th time, they&#8217;ll be making the same mistakes, and after the 8th time, they won&#8217;t even be conscious that they&#8217;re typing memcpy_s(target,len,source,len) instead of memcpy(target,source,len).</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113043">

			<div class="comment by-nathan ">

				<p class="commentcredit">

					<span class="commenter">Nathan</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113043">
						May 20, 2009 11:24 AM					</a>

				</p>

				<p>I am rinsing my schadenfreude mug, preparing for the inevitable exploit caused by misuse of memcpy_s(). Boy, will that be delicious.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113044">

			<div class="comment by-curt ">

				<p class="commentcredit">

					<span class="commenter">Curt</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113044">
						May 20, 2009 11:25 AM					</a>

				</p>

				<p>I don&#8217;t understand people who believe that only incompetent programmers can make mistakes.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113045">

			<div class="comment by-nathan ">

				<p class="commentcredit">

					<span class="commenter">Nathan</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113045">
						May 20, 2009 11:27 AM					</a>

				</p>

				<p>Curt, no one believes that only incompetent programmers make mistakes. It&#8217;s just that no one sees how use of memcpy_s() will make any difference in the likelihood of a mistake, regardless of the competence of a programmer.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113046">

			<div class="comment by-fp ">

				<p class="commentcredit">

					<span class="commenter">FP</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113046">
						May 20, 2009 11:28 AM					</a>

				</p>

				<p>What annoys me most is that Microsoft mandates the use of a new, proprietary &#8220;memcpy_s&#8221; function.  If only they had introduced it into any standard (like ISO C) first.</p>
<p>It&#8217;s trivial to work around but still a burden for those who want to write portable code.  Embrace and extend!</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113047">

			<div class="comment by-nathan ">

				<p class="commentcredit">

					<span class="commenter">Nathan</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113047">
						May 20, 2009 11:30 AM					</a>

				</p>

				<p>Allow me to clarify:</p>
<p>If a hypothetical programmer is so incompetent that he is simply unable to use memcpy() properly, then memcpy_s() will not help him.</p>
<p>If another one, highly talented and detail-oriented, nevertheless occasionally makes mistakes using memcpy(), then it seems he is just as likely to make the same mistake using memcpy_s().</p>
<p>Disagree?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113048">

			<div class="comment by-mark-r ">

				<p class="commentcredit">

					<span class="commenter">Mark R</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113048">
						May 20, 2009 11:31 AM					</a>

				</p>

				<p>I like the dangling participle in this sentence from the Reg article:</p>
<p>&#8220;He likened memcpy() to other risky functions such as strcpy() and strcat(), which Microsoft has already banned after exacting untold misery over the years.&#8221;</p>
<p>That&#8217;s either careless writing or a very cleverly veiled shot at Microsoft&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113049">

			<div class="comment by-td ">

				<p class="commentcredit">

					<span class="commenter">TD</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113049">
						May 20, 2009 11:40 AM					</a>

				</p>

				<p>Let&#8217;s not confuse people by appending &#8216;_s&#8217; to the names of &#8216;safe&#8217; functions, a suffix commonly used in the naming of structs.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113050">

			<div class="comment by-david ">

				<p class="commentcredit">

					<span class="commenter">David</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113050">
						May 20, 2009 11:40 AM					</a>

				</p>

				<p>@Jack:  The problem is that, if the list is based on the number of times a function is listed in security reports, and not philosophy, it&#8217;s not very useful.</p>
<p>What we need to do, for security purposes, is identify functions that can be replaced by potentially safer equivalents.  For example, you can&#8217;t control how much memory will be overwritten by gets(), but you can with fgets().  Nobody can write safe code that uses gets(), and it should never be used in anything remotely safety-critical.</p>
<p>However, there&#8217;s no practical difference between memcpy() and memcpy_s().  A good programmer will be precisely as safe with both.  A bad programmer will be precisely as dangerous with both.</p>
<p>Banning memcpy() because it shows up in a predefined number of security reports is much like banning liquids from aircraft:  it&#8217;s mindless, inconvenient (far more so for the airline passengers, of course), and useful only as security theater.  Banning gets() is like hardening the cockpit:  it is clear that it will stop a certain class of threat, and is useful as security.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113051">

			<div class="comment by-adrian ">

				<p class="commentcredit">

					<span class="commenter">Adrian</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113051">
						May 20, 2009 11:42 AM					</a>

				</p>

				<p>Several comments have pointed out that banning dangerous functions isn&#8217;t a complete solution.  True, but it is part of defense in depth.</p>
<p>Programmers should be better trained to understand what their code actually does and to recognize potential pitfalls.</p>
<p>Compilers and analysis tools should check for buffer overruns and other common errors.</p>
<p>Testing should be more comprehensive.</p>
<p><em>And</em> dangerous functions should be eliminated or replaced, just in case the other three layers fail.</p>
<p>Just because I know how to use a table saw properly doesn&#8217;t mean I want one that&#8217;s lacking safety guards.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113052">

			<div class="comment by-curt ">

				<p class="commentcredit">

					<span class="commenter">Curt</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113052">
						May 20, 2009 11:44 AM					</a>

				</p>

				<p>A well-intententioned programmer that supplies appropriately obtained values to memcpy_s is less likely to make an error than one who supplies no-less-appropriate values to memcpy_s. The extra value is a check on the mental model of the programmer that also transmits additional information to code reviewers to help them reason about the code. Naturally, someone who passes the same value to both parameters will defeat this check &#8212; but even this can be easily found in a code review.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113053">

			<div class="comment by-curt ">

				<p class="commentcredit">

					<span class="commenter">Curt</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113053">
						May 20, 2009 11:44 AM					</a>

				</p>

				<p>Oops&#8230; the second &#8220;memcpy_s&#8221; in my first sentence should have been &#8220;memcpy&#8221;.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113054">

			<div class="comment by-unsurprised ">

				<p class="commentcredit">

					<span class="commenter">unsurprised</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113054">
						May 20, 2009 11:45 AM					</a>

				</p>

				<p>I&#8217;m tempted to start a contest in the IOCCC vein where programmers are challenged to create the most insecure code with the (supposedly) most secure languages.  For example, creating a buffer overflow exploit in Java not by writing past the end of an array, but by allowing part of the array to be used for things like security parameters, in which overwriting, say, the last part of the array overwrites the permissions bits.  Appending zeros to your input gives you root access, all without a buffer overflow!</p>
<p>This is exactly the wrong approach: a programmer who creates a security hole by using memcpy will create security problems regardless of the language used.  Banning the API only frustrates the programmer who has a legitimate use for it, e.g., copying a video buffer during a video decode.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113055">

			<div class="comment by-m-welinder ">

				<p class="commentcredit">

					<span class="commenter">M Welinder</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113055">
						May 20, 2009 11:51 AM					</a>

				</p>

				<p>The list includes strlen.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113056">

			<div class="comment by-curt ">

				<p class="commentcredit">

					<span class="commenter">Curt</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113056">
						May 20, 2009 11:51 AM					</a>

				</p>

				<p>There&#8217;s some pretty compelling research which shows that the simple use of checklists in hospitals can have a dramatic effect on mortality. Think of this extra parameter as the equivalent of an item on a checklist.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113057">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113057">
						May 20, 2009 11:55 AM					</a>

				</p>

				<p>As discussed a few days ago on this blog there are better ways to go these days than with C/C++.</p>
<p>Unfortunatly after something like 40years the assumptions about the resources are the other way around these days (ie Hardware=cheep Humans=expensive).</p>
<p>We need to think of a suitable high level language without the faults but still retaining the power and compactness.</p>
<p>Oh and please please thing up a better way to delcare variables (it&#8217;s a night mare hence so many pointers to void, and the risks ascociated).</p>
<p>I think both K&amp;R have said they would change the precedence and ascociative behaviour in C&#8230;</p>
<p>Oh and perhaps we should stop thinking of &#8220;files&#8221; being the basic data/comms model I&#8217;m sure there are better ways to do it.</p>
<p>But hey Rome was not built in a day 8)</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113058">

			<div class="comment by-nathan ">

				<p class="commentcredit">

					<span class="commenter">Nathan</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113058">
						May 20, 2009 12:02 PM					</a>

				</p>

				<p>Here&#8217;s what I think is a relatively common use of memcpy():</p>
<p>char *buf = malloc(src_size);<br />
assert(buf);<br />
memcpy(buf, src, src_size);</p>
<p>When arguing about the very theoretical benefit of replacing memcpy() with memcpy_s(), consider the wastefulness of comparing src_size to itself in this use case, which I suspect accounts for the vast majority of memcpy() uses.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113059">

			<div class="comment by-david ">

				<p class="commentcredit">

					<span class="commenter">David</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113059">
						May 20, 2009 12:06 PM					</a>

				</p>

				<p>@Curt:  While overcasual use of memcpy_s() is going to be obvious in a code review, so&#8217;s bad use of memcpy().  I also don&#8217;t think it looks much like a checklist.  A pilot or nurse using a checklist is performing a major procedure, unlike a programmer using memcpy().</p>
<p>@M Welinder:  strlen() won&#8217;t write over anything, but can try to access a vast amount of memory, and if this causes page faults it can take a significant amount of time.  Call it a potential performance bug.</p>
<p>What struck me as odd on the list was strncpy() and strncat(), until I read the rationale.  They aren&#8217;t just length-safe equivalents of strcpy() and strcat(), but functions with behavior that&#8217;s very like their non-n equivalents, but different enough to be tricky.  I assume that strcpy_s() is pretty much a length-safe variant of strcpy().</p>
<p>So, the only ban I don&#8217;t understand is that of memcpy().  I would expect that, on the statistical basis, they&#8217;ll have to ban memcpy_s() down the road, and replace it with memcpy_s_s(), which will require the copy length to be entered three times, and so on ad infinitum.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113060">

			<div class="comment by-nathan ">

				<p class="commentcredit">

					<span class="commenter">Nathan</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113060">
						May 20, 2009 12:17 PM					</a>

				</p>

				<p>David wins the thread.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113061">

			<div class="comment by-john ">

				<p class="commentcredit">

					<span class="commenter">John</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113061">
						May 20, 2009 12:24 PM					</a>

				</p>

				<p>&#8220;Here&#8217;s what I think is a relatively common use of memcpy():</p>
<p>char *buf = malloc(src_size);<br />
assert(buf);<br />
memcpy(buf, src, src_size);<br />
&#8221;</p>
<p>I most certaintly hope that isn&#8217;t a common use as written. Because it is begging for security issues. The problem is the assert(). Namely, once the code is compiler for production release, it goes away.</p>
<p>So you have a system that&#8217;s equivalent to wearing a safety vest while the ship is docked in port, but once it heads off into deep water, the vest is discarded.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113062">

			<div class="comment by-bryan-feir ">

				<p class="commentcredit">

					<span class="commenter">Bryan Feir</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113062">
						May 20, 2009 12:29 PM					</a>

				</p>

				<p>@M Welinder:</p>
<p>Actually, I have seen strlen() involved in a security bug.  (And yes, it was my fault at the time: it was known that the buffer could be full, so I did strlen() then capped it at the buffer length.  Wrong order of operations: I should have capped the length first and then called a limited search function such as memchr().)</p>
<p>Basically, the implementation of strlen(src) in the system library we were using for an embedded processor just did memchr(src, 0x00, 0xffff)-src.  Not only was there a problem with a bus error if src was less than 64K from the end of memory and there was no NUL in that space, but if no NUL was found in 64K worth of search and memchr() returned NULL itself, strlen() could return some very strange values.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113063">

			<div class="comment by-gweihir ">

				<p class="commentcredit">

					<span class="commenter">Gweihir</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113063">
						May 20, 2009 12:31 PM					</a>

				</p>

				<p>Sorry, but this is not smart at all. The problem is not the function call, but the ones using it an unsafe manner. As long as there is direct memory access in C, this type of mistake can be made. However the direct memory access cannot be removed, C is still needed as assembler replacement. There are only two ways to fix the problem:</p>
<ol>
<li>Have only people with understanding of software security design systemsn and write code.</li>
<li>Go to a language without direct memory access.</li>
</ol>
<p>Option 2. has the drawback that this does only shift the issue to more complex vuknerabilities. &#8221;Programmers&#8221; that do not understand security will screw it up, no matter the language. And there is a host of security problems that have nothing to do with direct memory access. I agree that the number of buffer overflows still found in software today is pathetic, but the issue really is the people writing this software. They are underqualified, undertalended, possibly underpaid, likely under too much time pressure and overestimate their own skills. Many of them will not even see the problem or feel clever that their code is so elegant, it does not need any additional checks&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113064">

			<div class="comment by-m ">

				<p class="commentcredit">

					<span class="commenter">M</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113064">
						May 20, 2009 12:32 PM					</a>

				</p>

				<p>There is a simple solution to prevent programmers from doing memcpy_s(target,len,source,len).</p>
<p>A precompilation checker could verify that the second and fourth parameters are not the same. Isn&#8217;t this the type of work prefast is supposed to do? I wouldn&#8217;t be surprised to see some checks added to prefast to put some sanity checks around the use of memcpy_s.</p>
<p>The use of the more explicit function causes programmers to put at least a modicum of thought into buffer lengths. Adding static syntax checking on top of that can catch the most egregious abuses of this function. It won&#8217;t be too terribly difficult to make it harder to use the function wrong than to use it properly.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113065">

			<div class="comment by-jrm ">

				<p class="commentcredit">

					<span class="commenter">JRM</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113065">
						May 20, 2009 12:54 PM					</a>

				</p>

				<p>@M:</p>
<p>You can&#8217;t pre-check, both because aliasing in C/C++ makes it impossible in general, but also  because it makes the programmer have to try trick the checker in the perfectly normal case mentioned above where the destination buffer is explicitly sized for the source length:</p>
<p>void * dst = malloc(len);<br />
if (dst) {<br />
    if (memcpy_s(dst, len, src, len) != 0) &#8230;</p>
<p>Should I make a new variable just so I can copy len into it so the checker won&#8217;t complain? And if that is such an easy way to defeat the checker, won&#8217;t people trying to cheat just do that in their memcpy_s()-avoidance macros?</p>
<p>You already have to be thinking about buffer sizes when using memcpy(); it&#8217;s part of the API. Adding a second length does not make thinking about it any more likely or not thinking about it any safer.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113066">

			<div class="comment by-gweihir ">

				<p class="commentcredit">

					<span class="commenter">Gweihir</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113066">
						May 20, 2009 12:59 PM					</a>

				</p>

				<p>@M: That will not help. The problem is thet some (many) people do not understand why memcpy() is dangerous. Those that do understand it will need no such check. Those that do not understand it will just work around the check. Example: Use a wrapper:</p>
<p>memcpy_s_works(a,b,c,d) { memcpy_s(a,b,c,d);}</p>
<p>Done. The pre-check gets impossible without dataflow analysis. Such &#8220;clever&#8221; tricks are bound to be discussed among the incompetent even now&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113067">

			<div class="comment by-garrett-g ">

				<p class="commentcredit">

					<span class="commenter">Garrett G</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113067">
						May 20, 2009 1:02 PM					</a>

				</p>

				<p>In a world w/o security cure-alls, this is obviously a good move.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113068">

			<div class="comment by-gweihir ">

				<p class="commentcredit">

					<span class="commenter">Gweihir</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113068">
						May 20, 2009 1:29 PM					</a>

				</p>

				<p>@Garrett G: There is nothing &#8220;obvious&#8221; in secure software implementation&#8230;.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113069">

			<div class="comment by-dave ">

				<p class="commentcredit">

					<span class="commenter">Dave</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113069">
						May 20, 2009 1:49 PM					</a>

				</p>

				<p>Strikes me more as extend and embrace.  Code written under Linux is now harder to port to Windows.  Code written under Windows is now harder to port to Macs.</p>
<p>In the end, it&#8217;s a lot of grief that doesn&#8217;t really solve anything.  Exactly what I&#8217;ve come to expect from large corporations.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113070">

			<div class="comment by-bob ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://bobertville.blogspot.com/' rel='external nofollow ugc' class='url'>Bob</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113070">
						May 20, 2009 2:32 PM					</a>

				</p>

				<p>Not surprising. Microsoft started this a few years ago. I had occasion to update some device driver code from Visual Studio 6 to Visual Studio .NET 2003, and lo and behold, things didn&#8217;t compile. They&#8217;d disabled a whole bunch of standard C library functions like this that they thought were unsafe. Thanks, Microsoft, I wasted quite a lot of time figuring out how to re-enable them so that perfectly safe code would compile.</p>
<p>Mind you, I&#8217;m all for making secure coding easier and insecure coding harder. And specifically, strncpy&#8217;s behavior is an abomination that frequently leads to unterminated strings and it should be deprecated from the language standard.</p>
<p>But my experience is the same as what a lot of other people have said. Security-minded programmers can use all those &#8220;unsafe&#8221; functions safely, and incompetent programmers won&#8217;t use anything safely. So I don&#8217;t find this as exciting as Bruce does, or expect it to immediately lead to better software.</p>
<p>However, I do things like this will make insecure programming difficult enough that it will encourage incompetent programmers to become more skilled at their craft.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113071">

			<div class="comment by-bob ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://bobertville.blogspot.com/' rel='external nofollow ugc' class='url'>Bob</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113071">
						May 20, 2009 2:35 PM					</a>

				</p>

				<p>Oh&#8230; and I do wish safer calls were part of the language standard.</p>
<p>Dave is right on the money &#8211; Microsoft&#8217;s replacements for these unsafe calls are not portable.</p>
<p>I tend to use the safe replacements from GLib on Linux and Mac OS, myself. But I doubt Microsoft will get on board with that.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113072">

			<div class="comment by-patrick-stein ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://nklein.com/' rel='external nofollow ugc' class='url'>Patrick Stein</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113072">
						May 20, 2009 3:41 PM					</a>

				</p>

				<p>I&#8217;ve got to say that I&#8217;m puzzled by this.  Faced with this, any programmer would immediately write the aforementioned macros or write his/her own my_memcpy().</p>
<p>Copying things is essential to most any program (and definitely to any C/C++ program).  You have to copy.  Maybe one could just ban passing arguments into functions? or allocating arrays on the stack? or pointers?</p>
<p>People are going to copy.  People are going to create bugs when copying.  Even if they use memcpy_s() explicitly (as opposed to via macros), they will botch it.</p>
<p>A program that uses memcpy_s() poorly will be just about as bad as a program that uses memcpy() poorly.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113073">

			<div class="comment by-joel8360 ">

				<p class="commentcredit">

					<span class="commenter">joel8360</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113073">
						May 20, 2009 3:49 PM					</a>

				</p>

				<p>@Adrian:</p>
<p>If, in spite of all the safety measure,  someone loses three fingers in three table saw accidents, will they be safer if you take away their table saw and give them a radial arm saw instead?</p>
<p>I&#8217;m all for defense in depth, but this particular measure sounds like trying secure a house by erecting a steel door in the middle of the sidewalk.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113074">

			<div class="comment by-nostromo ">

				<p class="commentcredit">

					<span class="commenter">Nostromo</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113074">
						May 20, 2009 4:20 PM					</a>

				</p>

				<p>This is Microsoft, so it has nothing to do with better programming and everything to do with persuading people to write non-portable, Microsoft-only code.</p>
<p>For example, they don&#8217;t advocate using strncpy, the &#8220;safe&#8221; version of strcpy, because &#8211; wait for it &#8211; it&#8217;s &#8220;so hard to call correctly&#8221;. Bollocks; if you call it with the integer argument first insted of last, a decent compiler will detect that and warn you.</p>
<p>This is yet another attempt to promote Microsoft-only lock-in, and should not have been given any publicity.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113075">

			<div class="comment by-icf7 ">

				<p class="commentcredit">

					<span class="commenter">icf7</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113075">
						May 20, 2009 4:25 PM					</a>

				</p>

				<p>Also note that people might be tempted to</p>
<p>#define ypcmem(dst, len, src) {size_t i = len; while (i&#8211;) *dst++ = *src++;}</p>
<p>Bonus points for declaring i as int.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113076">

			<div class="comment by-david ">

				<p class="commentcredit">

					<span class="commenter">David</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113076">
						May 20, 2009 4:31 PM					</a>

				</p>

				<p>@Nostromo:  It isn&#8217;t that strncpy() is hard to write or call, but that it isn&#8217;t quite &#8220;the &#8216;safe&#8217; version of strcpy&#8221;.</p>
<p>strcpy(), when called with something that isn&#8217;t a string, or too long, will overwrite memory, but if it doesn&#8217;t mess up too badly will leave a null-terminated string.  strncpy(), under those circumstances, copies what it can, but doesn&#8217;t leave a null-terminated string.  This will very likely cause some problems in later processing.  It isn&#8217;t as error-prone as strcpy(), but it&#8217;s still easier to mess up with it than it should be.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113077">

			<div class="comment by-jeff-dege ">

				<p class="commentcredit">

					<span class="commenter">Jeff Dege</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113077">
						May 20, 2009 5:11 PM					</a>

				</p>

				<p>&#8220;This requirement was put in place to prevent use of certain older C runtime functions that lead to buffer overrun flaws and have been deprecated.&#8221;</p>
<p>By whom?  I can see a good argument that these functions should be deprecated, but if that&#8217;s going to happen, it&#8217;s going to have to be the ANSI/ISO standards committees.</p>
<p>Microsoft doesn&#8217;t own the language standard, and has no authority to declare any function deprecated, no matter what they pretend.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113078">

			<div class="comment by-dolphin ">

				<p class="commentcredit">

					<span class="commenter">Dolphin</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113078">
						May 20, 2009 5:28 PM					</a>

				</p>

				<p>@Nostromo</p>
<p>The main problem with strncpy is that it will happily leave you with an unterminated string, leading to lots of:<br />
strncpy(buffer, string, bufferLen);<br />
buffer[bufferLen-1]=0;</p>
<p>Not to mention, it seems somewhat wasteful to always pad out the whole buffer with 0&#8217;s as strncpy does.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113079">

			<div class="comment by-gweihir ">

				<p class="commentcredit">

					<span class="commenter">Gweihir</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113079">
						May 20, 2009 7:14 PM					</a>

				</p>

				<p>Well, I have take to using strdup() or strndup(). The second also ensures that the target string is 0 terminated, and allocating a new string is often what you want anyways. If not, you should have a very clear idea about the target buffer size and enforce it.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113080">

			<div class="comment by-lawrence-doliveiro ">

				<p class="commentcredit">

					<span class="commenter">Lawrence D&#039;Oliveiro</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113080">
						May 20, 2009 7:53 PM					</a>

				</p>

				<p>Interesting how so many of the functions have to do with null-terminated strings. Instead of picking off these functions one by one, why pussyfoot around the issue? Why not just come out and say “ban null-terminated strings”? That would be so much simpler.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113081">

			<div class="comment by-anonymous ">

				<p class="commentcredit">

					<span class="commenter">Anonymous</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113081">
						May 20, 2009 9:00 PM					</a>

				</p>

				<p>So if the programmer knows the destination buffer length, they&#8217;ll replace it with memcpy_s&#8230; but then they probably already know that the source will fit.</p>
<p>If they don&#8217;t know the destination buffer length, will they rewrite whatever portions of the code are necessary to expose it, or will they write<br />
for(int i = 0; i &lt; src_size; i++) ((char<em>)dst)[i] = ((char</em>)src)[i];<br />
?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113082">

			<div class="comment by-not-that-deluded ">

				<p class="commentcredit">

					<span class="commenter">Not that deluded</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113082">
						May 21, 2009 12:44 AM					</a>

				</p>

				<p>@Dave<br />
&#8220;Code written under Linux is now harder to port to Windows. Code written under Windows is now harder to port to Macs.<br />
In the end, it&#8217;s a lot of grief that doesn&#8217;t really solve anything. &#8221;</p>
<p>As if the replacements are hard to write.  If it takes one competent programmer a week of concerted effort, including tests and publishing it to sourceforge.com, I&#8217;d be shocked.  No, it&#8217;s very little grief that doesn&#8217;t really solve anything.</p>
<p>Besides, if memcpy() is banned, determined programmers will just write their own function, only not call it memcpy().  It&#8217;ll be safe_copy(), or bpsc() for Bob&#8217;s Perfectly Safe Copy, or something equally misleading.  If they don&#8217;t have detailed code audits, it&#8217;ll all pass through the bozo filter.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113083">

			<div class="comment by-nostromo ">

				<p class="commentcredit">

					<span class="commenter">Nostromo</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113083">
						May 21, 2009 12:50 AM					</a>

				</p>

				<p>@David, @Dolphin:</p>
<p>You&#8217;re nitpicking at a side-point. The main thing to understand about this whole discussion is that it is yet another attempt by Microsoft to promote non-portable, Microsoft-specific code. I&#8217;m appalled that Bruce helped it along by giving it publicity.</p>
<p>Somebody has a proposal to make C programming less error-prone? Fine, discuss it in an open forum, get a bunch of independent compiler producers on board, hammer out weaknesses with the whole C community, then maybe propose it as an ANSI standard. That&#8217;s if they REALLY want to make C programming less error-prone. If they just want to con programmers into writing stuff that will work only on their platform, then they&#8217;ll do what Microsoft has done.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113084">

			<div class="comment by-anonymous ">

				<p class="commentcredit">

					<span class="commenter">Anonymous</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113084">
						May 21, 2009 3:54 AM					</a>

				</p>

				<p>Don&#8217;t fall for M$&#8217;s &#8220;Embrace, extend and extinguish&#8221;.<br />
Switch to Cyclone for &#8220;low&#8221; Level / Drivers:<br />
<a href="http://cyclone.thelanguage.org" rel="nofollow ugc">http://cyclone.thelanguage.org</a><br />
<a href="http://en.wikipedia.org/wiki/Cyclone_(programming_language)" rel="nofollow ugc">http://en.wikipedia.org/wiki/Cyclone_(programming_language)</a></p>
<p>And use Eiffel for all the High Level / Software Construction stuff.<br />
<a href="http://en.wikipedia.org/wiki/Eiffel_(programming_language)" rel="nofollow ugc">http://en.wikipedia.org/wiki/Eiffel_(programming_language)</a></p>
<p>@Clive Robinson:<br />
And Bjarne Stroustrup knows that too:</p>
<p>Stroustrup: &#8220;In addition to Simula67, my favorite language at the time was Algol68. I think that &#8220;Algol68 with Classes&#8221; would have been a better language than &#8220;C with Classes.&#8221; However, it would have been stillborn.&#8221;<br />
<a href="http://www.gotw.ca/publications/c_family_interview.htm" rel="nofollow ugc">http://www.gotw.ca/publications/c_family_interview.htm</a></p>
<p>The C++ Fanboy-crowd just doesn&#8217;t want to realize that.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113085">

			<div class="comment by-ricky ">

				<p class="commentcredit">

					<span class="commenter">Ricky</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113085">
						May 21, 2009 6:06 AM					</a>

				</p>

				<p>I think “banish the popular programming functions that&#8217;s been responsible for an untold number of security vulnerabilities” is good action which is taken by Microsoft.  But I think the problem with the prohibition is that isn&#8217;t not memcpy(). The problem is programmers who don&#8217;t think about buffer lengths while writing code, who simply don&#8217;t bother doing the work to check sizes correctly.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113086">

			<div class="comment by-chris ">

				<p class="commentcredit">

					<span class="commenter">Chris</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113086">
						May 21, 2009 6:16 AM					</a>

				</p>

				<p>A lot of you seem to be asserting that bad programmers will screw up anyway, but on what grounds? Sure you can say memcpy_s(dst, len, src, len), but you could also perfectly habitually say f(src, x) { memcpy_s(dst, dst_len, src, x) }. It&#8217;s combining two things which should <em>always</em> go together (checking your buffer sizes and doing the copy,) which seems like it might promote a good habit.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113087">

			<div class="comment by-robert-the-red ">

				<p class="commentcredit">

					<span class="commenter">Robert the Red</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113087">
						May 21, 2009 7:27 AM					</a>

				</p>

				<p>What is really needed in C is a way to check if accessing a memory location is legitimate &#8212; without a segfault.  Then it would be possible to write safe code.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113088">

			<div class="comment by-drscrooge ">

				<p class="commentcredit">

					<span class="commenter">drscrooge</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113088">
						May 21, 2009 8:06 AM					</a>

				</p>

				<p>i think the real solution to this problem is to use structs which are length + buffer instead of a plain buffer and have all functions that modify the buffer check internally to ensure overflow doesn&#8217;t happen. for example qmail uses its <a href="http://cr.yp.to/lib/stralloc.html" rel="nofollow ugc">own string library</a> and i don&#8217;t think they&#8217;ve had any overflow bugs.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113089">

			<div class="comment by-david ">

				<p class="commentcredit">

					<span class="commenter">David</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113089">
						May 21, 2009 9:02 AM					</a>

				</p>

				<p>@Lawrence:  I agree that null-terminated strings are a bad idea.  Unfortunately, we&#8217;re stuck with them for writing in C and, to some extent, C++ (C++ has the std::string class that is a whole lot safer and more useful, although it can&#8217;t eliminate all use of null-terminated strings), and we aren&#8217;t going to replace C and C++ at all easily.  What we can do is think of ways to deal with them more safely.</p>
<p>@Robert:  You can&#8217;t check if a memory location is legitimate.  Given cooperation on the part of the OS and hardware, it would be possible to check if the memory location was listed as OK to write to, but that doesn&#8217;t mean it&#8217;s really legitimate to write to.  We&#8217;d need to check if accessing a memory location is legitimate for the operation we&#8217;re doing, since the big problem is usually writing to other data rather than segfaulting.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113090">

			<div class="comment by-dolphin ">

				<p class="commentcredit">

					<span class="commenter">Dolphin</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113090">
						May 21, 2009 9:38 AM					</a>

				</p>

				<p>@nostromo</p>
<p>I&#8217;ll give you that it is a side point, but it is hardly nit picking.  strncpy is not really much of an improvement on strcpy.  yes it protectes the WRITE from going off the end of a buffer.  Unfortunately you have to do extra work to make sure that a subsequent READ of that string doesn&#8217;t read off the end of the array.  Of course, MS could have used strlcpy.  It doesn&#8217;t fit their naming conventions and the return value is different (better IMO) but it is going to be available on more systems than strncpy_s.</p>
<p>I think the main problem is that MS decided to enable the warnings for the original functions by default.  MS is not forcing anyone to use the new functions, just throwing out a bunch of annoying warnings (that you have to opt out of on a per project basis).</p>
<p>In the end though, I do think memcpy_s is a bit on the silly side.  And of course, if you want to man functions that are involved in a large number of security flaws, you should look at WinMain (oh gasp, that is not portable!!!!)</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113091">

			<div class="comment by-jimfive ">

				<p class="commentcredit">

					<span class="commenter">JimFive</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113091">
						May 21, 2009 1:24 PM					</a>

				</p>

				<p>@David<br />
RE: &#8220;You can&#8217;t check if a memory location is legitimate.&#8221;</p>
<p>If a more secure C language is desired then I think you could do this.  You wouldn&#8217;t be able to determine if the memory location is correct, but the compiler could determine if the memory access was legitmate, for certain values of legitimate.  The compiler would need to check two things: Is the memory allocated?  and Is the memory being accessed through a variable for which it was allocated.</p>
<h2>The second condition is harder to check (especially for pointers into arrays/lists etc) but it should be at least checkable at some debug level.</h2>
<p>JimFive</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113092">

			<div class="comment by-david ">

				<p class="commentcredit">

					<span class="commenter">David</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113092">
						May 21, 2009 1:44 PM					</a>

				</p>

				<p>@JimFive:  I don&#8217;t think it&#8217;s possible to test, for reasonable C programs, that memory location X is supposed to be reachable through variable Y.  It would be possible to test if X and Y were in the same allocation, but that could get real slow.</p>
<p>If we were to design a new language, we could define a pointer as a base pointer plus current offset with maximum offset attached, while we were ditching null-terminated strings.  It&#8217;d use memory, and would slow down programs due to increased size and hence cache misses, but it would be safer.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113093">

			<div class="comment by-jimfive ">

				<p class="commentcredit">

					<span class="commenter">JimFive</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113093">
						May 21, 2009 2:49 PM					</a>

				</p>

				<p>@David<br />
It would be possible to determine that the memory accessible by a pointer was allocated as a unit.  This would be, effectively, the same thing as determining if an access is legitimate for that variable (handle).  You could also prevent pointer incrementing from moving outside of the allocated space in the same manner.</p>
<h2>I recognize that there would be difficulties to overcome but that&#8217;s true in any language development.</h2>
<p>JimFive</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113094">

			<div class="comment by-peter-e-retep ">

				<p class="commentcredit">

					<span class="commenter">Peter E Retep</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113094">
						May 21, 2009 5:30 PM					</a>

				</p>

				<p>The MSD banned notice sp terrified the firewall keepers at LAUSD,<br />
that they blocked access to the list of banned commands &#8211;<br />
so no one could find out what they are!<br />
Perhaps Bruce needs to cover a new subject,<br />
Security Abuse, defined as actions where people attempt to impose the illusion of security<br />
by terrorizing or using the rationale of terrorizing<br />
instead of providing any actual security?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113095">

			<div class="comment by-anonymous ">

				<p class="commentcredit">

					<span class="commenter">Anonymous</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113095">
						May 22, 2009 11:16 AM					</a>

				</p>

				<p>A statistical approach to finding areas of code that are likely to produce security flaws makes sense.  I&#8217;m not sure that they actually checked the number of false-positives, however.  Yes, a significant number of bugs are related to non-trivial overwrites of memory, and a significant number of non-trivial overwrites of memory are done using memcpy.  But does the effort of switching to memcpy_s (doing it portably, the effort is small but non-zero) outweigh other means of spotting the same problems?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113096">

			<div class="comment by-moo ">

				<p class="commentcredit">

					<span class="commenter">moo</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113096">
						May 22, 2009 1:57 PM					</a>

				</p>

				<p>As a long-time C and C++ programmer, I agree with other posters above that banning memcpy is pointless and will solve nothing.</p>
<p>Most people disable the &#8220;deprecated&#8221; warnings Microsoft compilers issue about standard library functions anyway, and go right on using them.  I&#8217;m not interested in Microsoft&#8217;s embrace-and-extend functions with the _s on the end.  But even if I was&#8230; strcpy_s or sprintf_s might have some utility in preventing a buffer overflow; memcpy_s is totally redundant because YOU ALREADY PASS A LENGTH PARAMETER TO MEMCPY and if you calculated that length wrong then you are *screwed* and asking you to pass it twice (or pass two different length parameters) is not going to change a goddamn thing.</p>
<p>In addition&#8212;when I think about most of my uses of memcpy, they are copying <em>partial</em> buffers around, not entire fixed-size buffers.  I use it for copying unaligned data to buffers that are properly aligned for them, and things like that.  In many cases there <em>is</em> no correct value to pass as the new &#8220;buffer size&#8221; parameter for memcpy_s, and the programmer will end up passing the same value for both size arguments, and the function will end up doing unnecessary checking with absolutely zero effect on program safety.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113097">

			<div class="comment by-wim-l ">

				<p class="commentcredit">

					<span class="commenter">Wim L</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113097">
						May 23, 2009 12:49 PM					</a>

				</p>

				<p>JimFive: I think that would still only cover a fraction of the problems caused by memory overwrites. If you&#8217;re going to implement the amount of type-bookkeeping that it would require, I think you&#8217;d be better off moving to a typesafe language. Strong typing doesn&#8217;t have to be painful to program with; I&#8217;m thinking of languages with relatively complete type systems and type inference (ML being the canonical example). This will catch most of these errors <em>at compile time</em>, which is worlds better than any runtime checking.</p>
<p>On the one hand, we do need &#8220;unsafe&#8221; languages like C for low-level work. On the other hand, most of the code written in the world isn&#8217;t doing low-level work.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113098">

			<div class="comment by-kevin-nickerson ">

				<p class="commentcredit">

					<span class="commenter">Kevin Nickerson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113098">
						May 23, 2009 3:15 PM					</a>

				</p>

				<p>Bah. If they wanted to improve C programs they&#8217;d A) Get a copy of PCLint and fix the headers supplied by MS for C/C++ to the top warning levels and B) Change all the &#8216;safe&#8217; functions that take &#8216;the number of elements&#8217; and make them take the size in bytes so we can use sizeof without needing a magic divide.</p>
<p>I must admit I hadn&#8217;t realized they have a strcpy_s, we made a str_copy function 15 years ago that works like that. Probably the single biggest bug reducer we&#8217;ve ever done other than insisting on a clean lint.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113099">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113099">
						May 23, 2009 4:25 PM					</a>

				</p>

				<p>@ Wim L</p>
<p>&#8220;This will catch most of these errors <em>at compile time</em>, which is worlds better than any runtime checking.&#8221;</p>
<p>Unfortunatly compile time checking can not catch most clases of malicious code nor does it check code that is to be linked at run time.</p>
<p>&#8220;On the one hand, we do need &#8220;unsafe&#8221; languages like C for low-level work.&#8221;</p>
<p>Actually you don&#8217;t need unsafe languages at all for doing low-level work. It is one of those &#8220;here be dragons&#8221; myths. The problem invariably in my experiance is the programmers not the lanquage they use.</p>
<p>&#8220;On the other hand, most of the code written in the world isn&#8217;t doing low-level work.&#8221;</p>
<p>True it is not but even with &#8220;safe this&#8221; and &#8220;safe that&#8221; laguages programers still manage to make a compleat pigs ear of it.</p>
<p>I now get on my old and venerable hobby horse and point it towards the nearest windmill 😉</p>
<p>I would rather employ a persone who writes software &#8220;in ascociation&#8221; with their vocation rather than a person for whom programing is their vocation.</p>
<p>Electronic Hardware and mechanical Engineers usually have little difficulty in writing safe code in assembler that will run in embedded systems for years without issues.</p>
<p>Likewise physisists and mathmaticians likewise appear to have little difficulty writing fairly robust and reliable code</p>
<p>Those few I have met with chemical, biological or medical training likewise have few problems. Ive even seen excelent code from librarians.</p>
<p>What is it about computer science training that sucks? Or is it those drawn to the subject that suck?</p>
<p>I have developed compleate embeded solutions which have ended up in millions of consumer products and have yet to here of any real problemswith systems I designed a quater of a century ago that are still doing their thing out ther 24&#215;365.25 come rain snow and hurricane (and worse).</p>
<p>I&#8217;m not a genius few engineers are (we&#8217;d be scientists if we where 8). We just appear to have a much clearer perspective of what is needed and how to acheive it reliably.</p>
<p>And before you ask yes I work close to the metal most of the time and still use WordStar style editors. Line for line I cann&#8217;t touch those &#8220;formular One&#8221; &#8220;code cutters&#8221; for shear output, but unlike them I tend not to have bugs to fix&#8230;</p>
<p>Call me the tortoise if you will but I still beat a lot of hairs, especialy those indicative of the mad march ones.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113100">

			<div class="comment by-shane ">

				<p class="commentcredit">

					<span class="commenter">Shane</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113100">
						May 27, 2009 10:32 AM					</a>

				</p>

				<p>That good ole&#8217; American sentiment:  &#8220;It&#8217;s somehow related to problems that are occurring, let&#8217;s ban it!&#8221;</p>
<p>I&#8217;m not a fan, and with a decade of development experience in all mess of languages, sorry to say, it would be far more useful to simply fire the idiot programmers who don&#8217;t know WTF they&#8217;re doing.</p>
<p>Banning memcopy() sounds about as useful as banning water on an airplane because &#8216;terrorists have been known to drink water while flying, allowing them to hydrate themselves so they can complete their terrifying mission of terror&#8217;.</p>
<p>Let&#8217;s hope they don&#8217;t ban Assembly next&#8230; Otherwise compilers are gonna have a rough time, you know, compiling.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113101">

			<div class="comment by-rpl ">

				<p class="commentcredit">

					<span class="commenter">rpl</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113101">
						May 27, 2009 3:11 PM					</a>

				</p>

				<p>==<br />
Likewise physicists and mathematicians likewise appear to have little difficulty writing fairly robust and reliable code</p>
<h1>Those few I have met with chemical, biological or medical training likewise have few problems. Ive even seen excellent code from librarians.</h1>
<p>Oh, come on, now.  I&#8217;ve seen a lot of scientific codes too, and the quality is all over the map.  I&#8217;ve seen thousand-line do loops, incomprehensible control flow, every variable a global, functions that do completely different operations depending on a flag setting; you name it.  And hardly anyone checks return values because they &#8220;just know&#8221; their library calls aren&#8217;t going to fail.  Some scientific code is pretty good, but a lot of it is pretty bad, and some is horrible.  Pretty much the same as any other discipline, in other words.</p>
<p>I believe science code tends to have fewer egregious failures than general-purpose software because it typically has a much easier job: do the following sequence of calculations a billion times and write the answer to a file.  Input is usually fairly simple and often rigidly formatted by another program, so there&#8217;s little need to validate it or check its length.  There is no event handling and little, if any, dependence on state from outside the program.  There is, in short, little that can go wrong, and so scientific programmers can get away with making assumptions that would completely sink, for example, a network stack.</p>
<p>So, while I don&#8217;t doubt there is plenty of room for improvement in the discipline of programming, physicists&#8217; and biologists&#8217; code provides no evidence one way or the other on that score.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113102">

			<div class="comment by-anonymous ">

				<p class="commentcredit">

					<span class="commenter">Anonymous</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113102">
						May 27, 2009 4:14 PM					</a>

				</p>

				<p>@ rpl,</p>
<p>I think you missed the point that my comments where with respect to those writing in low level languages for embeded and Hard RT systems, used in demanding real world aplications such as flight control and engine/breaking managment systems.</p>
<p>Not general purpose slop code to hack a quick set of results to enable other activities.</p>
<p>Or three dimensional desktop widgets or office productivity code.</p>
<p>The simple fact is that in my experiance, those who&#8217;s chosen vocation was not computer science but engineering or hard science tend to have a more focused aproach to what they are doing.</p>
<p>Especially when it comes to not so obvious and difficult issues that cannot be &#8220;abstracted&#8221; away to the OS to deal with via threads and IPC&#8230;</p>
<p>When it comes to developing Hard RT and top half device drivers, you need an eye for minutia, it realy is function over form every time and it has to meet the micro/nano second time limits each and every time.</p>
<p>Those who&#8217;s vocation is ordinary computer science appear to jump in their education from basic while loops to multithred objects without any understanding of 60years of sweat and toil in between that have ,ade those objects not just possible but usable in human time scales.</p>
<p>Thankfully for most they never need look behind the illusion that is multithreaded objects.</p>
<p>Hardware and OS performance has improved so much that it has alowed such abstraction to appear relativly responsive in human terms.</p>
<p>But unfortunatly they are like any abstraction, an illusion, and in this case purchased by the wastefull expenditure of resources.</p>
<p>They most definatly are non functional in terms of the time it takes light to cross the palm of your hand, or realisticaly the time it takes a jet aircraft to fly it&#8217;s own length.</p>
<p>And it is in this arena of Hard RT that I realy do see the difference between software artisans with their cosy &#8220;patterns&#8221; and &#8220;object reuse&#8221; and engineers and scientists with the cold harsh unforgiving real world to deal with.</p>
<p>Afterall you don&#8217;t want the ABS on your car to stop working while your passenger is navigating the menus to adjust the aircon do you?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113103">

			<div class="comment by-mike-becker ">

				<p class="commentcredit">

					<span class="commenter">Mike Becker</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113103">
						June 15, 2009 9:27 AM					</a>

				</p>

				<p>This is the illusion of security.  I can still overrun the buffer if I pass in bad data, and I can use this API to pull extra data from source into destination if I don’t check for it.  A wiz-bang spiffy new API doesn’t make code secure, good engineers do.</p>
<h1>Given:</h1>
<p>#define SIZE 10</p>
<p>//<br />
//    Globals<br />
//<br />
unsigned char Buffer [SIZE];<br />
char password[8];</p>
<p>void<br />
GiveUserSomeData (unsigned char UserBuffer, size_t BufferSize)<br />
{<br />
errno_t Code;</p>
<p>//<br />
//    Count the characters for the user<br />
//<br />
for (int count = 0; count &lt; SIZE; count ++){<br />
      if ( Buffer[count] == 0 ){<br />
            Break;<br />
      }<br />
}</p>
<p>//<br />
//    Now count will be the length of the Buffer, give it back to the user<br />
//<br />
Code = memcpy_s( UserBuffer, BufferSize, Buffer, count);</p>
<p>if (Code == 0){<br />
      //<br />
      //    Yay!  I am a security guru!<br />
      //<br />
}<br />
else{<br />
      //<br />
      //    Good job memcpy_s() for saving me!<br />
      //<br />
}<br />
}</p>
<h1>Problem 1 – leaking data:</h1>
<p>Assume:  Buffer[] has no null characters in it (oops)</p>
<p>unsigned char MyBuffer[12];</p>
<p>GiveUserSomeData (MyBuffer, 12);<br />
//<br />
//    Question, what does MyBuffer[10] contain?<br />
//</p>
<h1>Problem 2 &#8211; Overrun:</h1>
<p>#define SIZE_1          1<br />
#define SIZE_2          2<br />
#define SIZE_3          4<br />
#define SIZE_4          8<br />
#define SIZE_5          16<br />
#define SIZE_6          32</p>
<p>unsigned char MyBuffer[SIZE_4];</p>
<p>//<br />
// Other code here&#8230;<br />
//<br />
GiveUserSomeData (MyBuffer, SIZE_5)</p>
<p>//<br />
//    This one’s easy to catch, but not all are<br />
//</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113104">

			<div class="comment by-tom-crispin ">

				<p class="commentcredit">

					<span class="commenter">Tom Crispin</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113104">
						June 15, 2009 11:10 AM					</a>

				</p>

				<p>How is banning memcpy() different from the security theater at airports?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113105">

			<div class="comment by-paul ">

				<p class="commentcredit">

					<span class="commenter">Paul</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113105">
						June 15, 2009 12:47 PM					</a>

				</p>

				<p>I can hardly wait until Microsoft programmers start generating more than three security bugs with the _s functions and thus require Microsoft to deprecated them as well.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113106">

			<div class="comment by-giraffe ">

				<p class="commentcredit">

					<span class="commenter">giraffe</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113106">
						June 16, 2009 10:19 AM					</a>

				</p>

				<p>Hey, Microsoft, isn&#8217;t it true, that memmove(dest, src, len) left, but memcpy was banned?<br />
And what about bcopy(src, dst, len)? Was it already banned?<br />
Or let&#8217;s just hope, that windows programmers don&#8217;t know such functions&#8230; Tss&#8230; don&#8217;t tell them!</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113107">

			<div class="comment by-martinr ">

				<p class="commentcredit">

					<span class="commenter">martinr</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113107">
						June 16, 2009 2:29 PM					</a>

				</p>

				<p>Requiring programmers to replace memcpy() with memcpy_s() might reduce the amount of buffer overflows, but it does not fix the underlying programming error!</p>
<p>The serious problem with most of Microsoft&#8217;s proposed securelib functions is that they suggest silent truncation is a good idea.  It&#8217;s not.  It is just a different variety of the same bug that is less obvious to exploit.</p>
<p>Currently, integer overflow vulnerabilities are on the rise, which are often silent truncation errors (for integers, truncation is usually a modulo operation either during a calculation or when storing the result).</p>
<p>Every piece of code that is looking at data or copying data ought to contain sanity/plausibility checks instead of bogus assumptions.  If you have a short buffer, and the source is to long to fit, the programmer must decide consciously what to do, and whether silent truncation and continuing without error is a sensible thing to do.  In many situations it is an extremely unreasonable thing to perform silent truncation.</p>
<p>Good code needs &gt;70% of its statements for error handling &#8212; the actual algorithm for the good case is often the &#8220;easy/trivial&#8221; part of the task.</p>
<p>And then, Microsoft fubar&#8217;ed snprintf() in their C Runtime, which is why they had to add snprintf_s().  That way Microsoft is giving snprintf() a bad reputation.</p>
<p>Personally, I think that securelib functions are a dumb idea.  For traditional code it is easy to distinguish good from bad code in C &#8212; the good code contains seperate length checks.</p>
<p>When code uses memcpy_s() instead, you no longer can distinguish new good code doing conscious silent truncation from bad code that is just adhering to a policy.</p>
<p>Only when the good code needs to do sensible error handling, then the explicit check will still be present &#8212; and the extra parameter on memcpy_s() will amout to pure waste, and at worst become a consistency problem for future changes.</p>
<p>Training programmers to make conscious decisions about oversized data or integers not fitting into available containers would be a good idea, reduce the number of bugs and significantly improve the overall situation.  Hitting programmers with the policy bat is a pretty bad idea.</p>
<p>Requiring programmer to change code without requiring them to actually fix existing or potential bugs is also a bad idea.  A securelib policy is likely going to convert many buffer overflow bugs into silent truncation bugs only while giving the false impression that the bugs were fixed.</p>
<p>Address space randomization is an acceptable countermeasure to temporarily make the exploitation of buffer overflows more difficult &#8212; no code is changed, so noone gets confused about bugs that were not really fixed, and since no source code is changed, no new bugs are introduced.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113108">

			<div class="comment by-mark5009 ">

				<p class="commentcredit">

					<span class="commenter">mark5009</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113108">
						June 16, 2009 6:03 PM					</a>

				</p>

				<p>@Tom C</p>
<p>It isn&#8217;t, and it conveniently ignores the underlying issue(s).  IMO, this is the &#8220;Curse of C&#8221;.  As K&amp;R (and others) have pointed out, C was meant as a portable assembler for a PDP-8(11), not as a general, commercial language.  There were much better languages for that back in the day.</p>
<p>But Unix was begat, and universities got Unix for zip, and C was taught and promulgated, and the curse spread.  And the folks came to believe that C was the language of choice for everything, forgetting the warning that it was &#8220;caveat emptor&#8221; and, like any assembler, most difficult stuff was left in the hands of the coder.  Very necessary when you are writing device drivers and the like.  Less helpful for your average accounting reporter.</p>
<p>The solution is to lose C and take a better option, of which there are many.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113109">

			<div class="comment by-mark ">

				<p class="commentcredit">

					<span class="commenter">mark</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113109">
						June 25, 2009 1:01 PM					</a>

				</p>

				<p>Forget about fixing a few calls, let&#8217;s replace C++, C#, etc. with Ada and fix all these pesky coding problems. Sharp edges are dangerous. Hence the avoidance of &#8220;pointers&#8221;.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-113110">

			<div class="comment by-martinr ">

				<p class="commentcredit">

					<span class="commenter">martinr</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113110">
						July 17, 2009 10:33 AM					</a>

				</p>

				<p>I&#8217;m really sad to see so many people promote the million monkey approach to software development.</p>
<p>Personally, I do prefer to be a good programmer, technical expert and improve my expertise constantly, rather than being a simple-minded code monkey with mediocre skills whose code would be completely unusable if there weren&#8217;t stringent programming languages and tools.</p>
<p>Although I personally definitely no fan of pair programming, I think the other decision of Microsoft &#8212; to perform development of Windows 7 with half the Manpower and double the quality is in principle a very wise idea.</p>
<p>And if you manage to combine the expertise of two such developers into one person, then it is the scheme that I&#8217;ve been successfully doing during the last 15 years with mission critical business software.</p>
<p>Expertise also significantly helps in recognizing bugs (malfunctions rather than vulnerabilities) of others in code or documentation (of which there are plenty) and devise workarounds.</p>
<p>For may years there have been tools like purify to locate many of the buffer overflow errors (ABR array bounds write) plus a lot of others, and using that tools to improve ones skills is a really good training.  Requiring users to use so-called &#8220;modern&#8221; languages takes those training possibilities away from the programmer, and will reinforce their mediocricy.</p>
<p>A 4-wheel car is a car that breaks down where no towing car can get to rescue it.</p>
<p>.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-113111">

			<div class="comment by-kris ">

				<p class="commentcredit">

					<span class="commenter">Kris</span> •

					<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/#comment-113111">
						July 16, 2010 2:51 AM					</a>

				</p>

				<p>Why don&#8217;t you people just replace your brains with something? Try bird food for a change!<br />
I can&#8217;t believe I am unable to compile a stupid DLL written in C because the god darned linker spits out something like &#8220;undefined reference to _snprintf&#8221;! Have you ever tried to understand the concept of &#8220;standard&#8221;? Hell, my code is written in standard C &amp; a so-called C compiler can&#8217;t get it to binary form&#8230;</p>
<p>Why don&#8217;t you just ban your lives!!</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

	<p class="subscribe-comments">
		<a href="https://www.schneier.com/blog/archives/2009/05/microsoft_bans.html/feed/">
			<img alt="Atom Feed" src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/rss.png">
			Subscribe to comments on this entry		</a>
	</p>

		<div id="respond" class="comment-respond">
		<h2 class="comments-open-header">Leave a comment <small><a rel="nofollow" id="cancel-comment-reply-link" href="/blog/archives/2009/05/microsoft_bans.html#respond" style="display:none;">Cancel reply</a></small></h2><form action="https://www.schneier.com/wp-comments-post.php" method="post" id="commentform" class="comment-form" novalidate><a href="https://www.schneier.com/wp-login.php?redirect_to=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2009%2F05%2Fmicrosoft_bans.html" title="Login">Login</a><p class="comment-form-author"><label for="author">Name</label> <input id="author" name="author" type="text" value="" size="30" maxlength="245" /></p>
<p class="comment-form-email"><label for="email">Email</label> <input id="email" name="email" type="email" value="" size="30" maxlength="100" /></p>
<p class="comment-form-url"><label for="url">URL:</label> <input id="url" name="url" type="url" value="" size="30" maxlength="200" /></p>
<p class="comment-form-cookies-consent"><input id="wp-comment-cookies-consent" name="wp-comment-cookies-consent" type="checkbox" value="yes" /> <label for="wp-comment-cookies-consent">Remember personal info?</label></p>

<p class="comment-form-author">

	<label for="comm_capt_challenge">
		Fill in the blank: the name of this blog is Schneier on ___________ (required):	</label>

	<input id="comm_capt_challenge" name="comm_capt_challenge" size="30" type="text" />
</p>

<div class="comment-form-comment">

	<label for="comment">Comments:</label>

	<textarea id="comment" name="comment" cols="45" rows="8" maxlength="65525" required="required"></textarea>

	<div id="preview-box" class="preview-box hide"></div>
	<img class="comment-loading hide" src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/loader.gif" />

</div>

<p id="allowed">

	<strong>Allowed HTML</strong>
	&lt;a href=&quot;URL&quot;&gt; &bull; &lt;em&gt; &lt;cite&gt; &lt;i&gt; &bull; &lt;strong&gt; &lt;b&gt; &bull; &lt;sub&gt; &lt;sup&gt; &bull; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &bull; &lt;blockquote&gt; &lt;pre&gt;
	<strong>Markdown Extra</strong> syntax via <a href="https://michelf.ca/projects/php-markdown/extra/">https://michelf.ca/projects/php-markdown/extra/</a>
</p>

<input type="hidden" id="wp_comment_nonce" name="wp_comment_nonce" value="4b1534b792" /><input type="hidden" name="_wp_http_referer" value="/blog/archives/2009/05/microsoft_bans.html" />
<input type="button" id="comment-preview" class="comment-preview comment-actions" value="Preview" />
<input type="button" id="comment-write" class="comment-write comment-actions hide" value="Edit" />

<p class="form-submit"><input name="submit" type="submit" id="submit" class="submit" value="Submit" /> <input type='hidden' name='comment_post_ID' value='2849' id='comment_post_ID' />
<input type='hidden' name='comment_parent' id='comment_parent' value='0' />
</p></form>	</div><!-- #respond -->
	
	<div class="stepthrough">
		<a href="https://www.schneier.com/blog/archives/2009/05/lost_puzzle_in.html" rel="prev">← "Lost" Puzzle in <i>Wired Magazine</i></a>		<a href="https://www.schneier.com/blog/archives/2009/05/me_on_full-body.html" rel="next">Me on Full-Body Scanners in Airports →</a>	</div>

	
<p id="powered">Sidebar photo of Bruce Schneier by Joe MacInnis.</p>
		</div>

		
<aside>
	<div class="sidebar" id="sidebar-two">
		<section><div class="sidesection widget widget_schneier_about" id="schneier_about-2"><h3>About Bruce Schneier</h3><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/Bruce-Schneier.jpg" /><p><p class="small">I am a <a href="https://public-interest-tech.com/">public-interest technologist</a>, working at the intersection of security, technology, and people. I've been writing about security issues on my <a href="/">blog</a> since 2004, and in my monthly <a href="/crypto-gram/">newsletter</a> since 1998. I'm a fellow and lecturer at Harvard's <a href="https://www.hks.harvard.edu/faculty/bruce-schneier">Kennedy School</a>, a board member of <a href="https://www.eff.org/">EFF</a>, and the Chief of Security Architecture at <a href="https://inrupt.com/">Inrupt, Inc.</a> This personal website expresses the opinions of none of those organizations.</p>
</p></div></section><section><div class="sidesection widget widget_schneier_related_posts" id="schneier_related_posts-2"><h3>Related Entries</h3>
<ul>

	<li><a href="https://www.schneier.com/blog/archives/2021/03/illegal-content-and-the-blockchain.html">Illegal Content and the Blockchain</a></li><li><a href="https://www.schneier.com/blog/archives/2021/03/national-security-risks-of-late-stage-capitalism.html">National Security Risks of Late-Stage Capitalism</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/weis-2021-call-for-papers.html">WEIS 2021 Call for Papers</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/ransomware-profitability.html">Ransomware Profitability</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/presidential-cybersecurity-and-pelotons.html">Presidential Cybersecurity and Pelotons</a></li><li><a href="https://www.schneier.com/blog/archives/2021/01/police-have-disrupted-the-emotet-botnet.html">Police Have Disrupted the Emotet Botnet</a></li>
</ul>
</div></section><section><div class="sidesection widget widget_schneier_featured_essays" id="schneier_featured_essays-2"><h3>Featured Essays</h3>
	<ul>
		<li><a href="https://www.schneier.com/essays/archives/2016/04/the_value_of_encrypt.html">The Value of Encryption</a></li><li><a href="https://www.schneier.com/essays/archives/2016/03/data_is_a_toxic_asse.html">Data Is a Toxic Asset, So Why Not Throw It Out?</a></li><li><a href="https://www.schneier.com/essays/archives/2014/01/how_the_nsa_threaten.html">How the NSA Threatens National Security</a></li><li><a href="https://www.schneier.com/essays/archives/2009/01/terrorists_may_use_g.html">Terrorists May Use Google Earth, But Fear Is No Reason to Ban It</a></li><li><a href="https://www.schneier.com/essays/archives/2007/01/in_praise_of_securit.html">In Praise of Security Theater</a></li><li><a href="https://www.schneier.com/essays/archives/2006/08/refuse_to_be_terrori.html">Refuse to be Terrorized</a></li><li><a href="https://www.schneier.com/essays/archives/2006/05/the_eternal_value_of.html">The Eternal Value of Privacy</a></li><li><a href="https://www.schneier.com/essays/archives/2005/09/terrorists_dont_do_m.html">Terrorists Don&#039;t Do Movie Plots</a></li>	</ul>

	<p><a href="https://www.schneier.com/essays/">More Essays</a></p></div></section><section><div class="sidesection widget widget_schneier_archives" id="schneier_archives-2"><h3>Blog Archives</h3>
<ul>

	<li><a href="https://www.schneier.com/blog/calendar.html/">Archive by Month</a></li><li><a href="https://www.schneier.com/blog/newcomments.html/">100 Latest Comments</a></li></ul>

<h4>Blog Tags</h4><ul class="top-tags"><li><a href="https://www.schneier.com/tag/3d-printers/">3d printers</a></li><li><a href="https://www.schneier.com/tag/9-11/">9/11</a></li><li><a href="https://www.schneier.com/tag/aaron-swartz/">Aaron Swartz</a></li><li><a href="https://www.schneier.com/tag/academic/">academic</a></li><li><a href="https://www.schneier.com/tag/academic-papers/">academic papers</a></li><li><a href="https://www.schneier.com/tag/accountability/">accountability</a></li><li><a href="https://www.schneier.com/tag/aclu/">ACLU</a></li><li><a href="https://www.schneier.com/tag/activism/">activism</a></li><li><a href="https://www.schneier.com/tag/adobe/">Adobe</a></li><li><a href="https://www.schneier.com/tag/advanced-persistent-threats/">advanced persistent threats</a></li><li><a href="https://www.schneier.com/tag/adware/">adware</a></li><li><a href="https://www.schneier.com/tag/aes/">AES</a></li><li><a href="https://www.schneier.com/tag/afghanistan/">Afghanistan</a></li><li><a href="https://www.schneier.com/tag/air-marshals/">air marshals</a></li><li><a href="https://www.schneier.com/tag/air-travel/">air travel</a></li><li><a href="https://www.schneier.com/tag/airgaps/">airgaps</a></li><li><a href="https://www.schneier.com/tag/al-qaeda/">al Qaeda</a></li><li><a href="https://www.schneier.com/tag/alarms/">alarms</a></li><li><a href="https://www.schneier.com/tag/algorithms/">algorithms</a></li><li><a href="https://www.schneier.com/tag/alibis/">alibis</a></li><li><a href="https://www.schneier.com/tag/amazon/">Amazon</a></li><li><a href="https://www.schneier.com/tag/android/">Android</a></li><li><a href="https://www.schneier.com/tag/anonymity/">anonymity</a></li><li><a href="https://www.schneier.com/tag/anonymous/">Anonymous</a></li><li><a href="https://www.schneier.com/tag/antivirus/">antivirus</a></li><li><a href="https://www.schneier.com/tag/apache/">Apache</a></li><li><a href="https://www.schneier.com/tag/apple/">Apple</a></li><li><a href="https://www.schneier.com/tag/applied-cryptography/">Applied Cryptography</a></li><li><a href="https://www.schneier.com/tag/artificial-intelligence/">artificial intelligence</a></li><li><a href="https://www.schneier.com/tag/assassinations/">assassinations</a></li></ul><p><a href="https://www.schneier.com/blog/tags.html/">More Tags</a></p></div></section><section><div class="sidesection widget widget_schneier_latest_book" id="schneier_latest_book-3"><h3>Latest Book</h3><a href="https://www.schneier.com/books/click-here/"><img class="sidepic" alt="Click Here to Kill Everybody" src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2018/07/book-ch2-200w.png" /></a><p><a href="https://www.schneier.com/books/">More Books</a></p></div></section><section><div class="sidesection widget widget_schneier_promotion" id="schneier_promotion-2">
<a href="https://www.eff.org/issues/bloggers/legal/join">
	<img src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/join-eff@2x.png" id="effbutton" alt="Support Bloggers' Rights!" title="Support Bloggers' Rights!" /></a>

<a href="https://npo.networkforgood.org/Donate/Donate.aspx?npoSubscriptionId=8252">
	<img src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/support-epic@2x.png" alt="Defend Privacy--Support Epic" title="Defend Privacy--Support Epic" /></a>
</div></section>	</div>
</aside>

		<footer>
			<nav>
				<div class="nav" id="footer-nav">
					<div class="menu-main-menu-container"><ul id="menu-main-menu-1" class="menu"><li class="menu1 menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-50175 current-menu-item"><a href="https://www.schneier.com">Blog</a></li>
<li class="menu2 menu-item menu-item-type-post_type menu-item-object-page menu-item-50916"><a href="https://www.schneier.com/crypto-gram/">Newsletter</a></li>
<li class="menu3 menu-item menu-item-type-post_type menu-item-object-page menu-item-50166"><a href="https://www.schneier.com/books/">Books</a></li>
<li class="menu4 menu-item menu-item-type-custom menu-item-object-custom menu-item-50169"><a href="https://www.schneier.com/essays/">Essays</a></li>
<li class="menu5 menu-item menu-item-type-custom menu-item-object-custom menu-item-50170"><a href="https://www.schneier.com/news/">News</a></li>
<li class="menu6 menu-item menu-item-type-custom menu-item-object-custom menu-item-50171"><a href="https://www.schneier.com/talks/">Talks</a></li>
<li class="menu7 menu-item menu-item-type-post_type menu-item-object-page menu-item-50167"><a href="https://www.schneier.com/academic/">Academic</a></li>
<li class="menu8 menu-item menu-item-type-post_type menu-item-object-page menu-item-50174"><a href="https://www.schneier.com/blog/about/">About Me</a></li>
</ul></div>				</div>
			</nav>
		</footer>

		</div><!--#main-->
	</div><!--#wrapper-->

		<script type="text/javascript">
		(function () {
			var c = document.body.className;
			c = c.replace(/woocommerce-no-js/, 'woocommerce-js');
			document.body.className = c;
		})();
	</script>
	<script type='text/javascript' src='https://c0.wp.com/p/woocommerce/5.1.0/assets/js/jquery-cookie/jquery.cookie.min.js' id='jquery-cookie-js'></script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/vendor/socialshareprivacy/js/socialshareprivacy.js?ver=1.0.1' id='social-share-privacy-js'></script>
<script type='text/javascript' id='social-share-privacy-icons-js-extra'>
/* <![CDATA[ */
var schneierSocial = {"path":"https:\/\/www.schneier.com\/wp-content\/themes\/schneier\/assets\/vendor\/socialshareprivacy\/"};
/* ]]> */
</script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/vendor/socialshareprivacy/js/icons.js?ver=1.0.0' id='social-share-privacy-icons-js'></script>
<script type='text/javascript' id='schneier-comment-js-extra'>
/* <![CDATA[ */
var schneierComment = {"translateErrorSecurityAnswerWrong":"Your response to the challenge question ('The name of this blog is Schneier on ____') was not correct. Please try again.","ajax_url":"https:\/\/www.schneier.com\/wp-admin\/admin-ajax.php"};
/* ]]> */
</script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/js/comment.js?ver=1.0.1' id='schneier-comment-js'></script>
<script type='text/javascript' src='https://c0.wp.com/c/5.7/wp-includes/js/wp-embed.min.js' id='wp-embed-js'></script>

</body>

</html>
