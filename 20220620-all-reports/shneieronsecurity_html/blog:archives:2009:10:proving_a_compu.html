<!DOCTYPE html>
<html lang="en-US">

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<title>Proving a Computer Program&#039;s Correctness - Schneier on Security</title>
	<meta name='robots' content='max-image-preview:large' />
<link rel='dns-prefetch' href='//s.w.org' />
<link rel='dns-prefetch' href='//c0.wp.com' />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Feed" href="https://www.schneier.com/feed/" />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Comments Feed" href="https://www.schneier.com/comments/feed/" />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Proving a Computer Program&#039;s Correctness Comments Feed" href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/feed/" />
<link rel='stylesheet' id='wp-block-library-css'  href='https://c0.wp.com/c/5.7/wp-includes/css/dist/block-library/style.min.css' type='text/css' media='all' />
<style id='wp-block-library-inline-css' type='text/css'>
.has-text-align-justify{text-align:justify;}
</style>
<style id='woocommerce-inline-inline-css' type='text/css'>
.woocommerce form .form-row .required { visibility: visible; }
</style>
<link rel='stylesheet' id='schneier-css'  href='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/style.css?ver=1.0.0' type='text/css' media='all' />
<link rel='stylesheet' id='schneier-main-css'  href='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/dist/css/style.css?ver=1.0.2' type='text/css' media='all' />
<link rel='stylesheet' id='jetpack_css-css'  href='https://c0.wp.com/p/jetpack/9.5.2/css/jetpack.css' type='text/css' media='all' />
<script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js?ver=3.5.1' id='jquery-js'></script>
<link rel="https://api.w.org/" href="https://www.schneier.com/wp-json/" /><link rel="alternate" type="application/json" href="https://www.schneier.com/wp-json/wp/v2/posts/3051" /><link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://www.schneier.com/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://www.schneier.com/wp-includes/wlwmanifest.xml" /> 

<link rel="canonical" href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html" />
<link rel='shortlink' href='https://www.schneier.com/?p=3051' />
<link rel="alternate" type="application/json+oembed" href="https://www.schneier.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2009%2F10%2Fproving_a_compu.html" />
<link rel="alternate" type="text/xml+oembed" href="https://www.schneier.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2009%2F10%2Fproving_a_compu.html&#038;format=xml" />
	<noscript><style>.woocommerce-product-gallery{ opacity: 1 !important; }</style></noscript>
	<link rel="icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-32x32.png" sizes="32x32" />
<link rel="icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-180x180.png" />
<meta name="msapplication-TileImage" content="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-270x270.png" />
		<style type="text/css" id="wp-custom-css">
			#schneier_promotion-2 img {
    max-width: 180px;
}		</style>
		</head>

<body class="post-template-default single single-post postid-3051 single-format-standard theme-schneier woocommerce-no-js">

	<div id="wrapper">
		<div id="main">

			<header>
				<div id="header">
					<h1>
						<a href="https://www.schneier.com/" rel="home">
							Schneier on Security						</a>
					</h1>
				</div>
			</header>

			<nav>
				<div class="nav" id="header-nav">
					<div class="menu-main-menu-container"><ul id="menu-main-menu" class="menu"><li id="menu-item-50175" class="menu1 menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-50175 current-menu-item"><a href="https://www.schneier.com">Blog</a></li>
<li id="menu-item-50916" class="menu2 menu-item menu-item-type-post_type menu-item-object-page menu-item-50916"><a href="https://www.schneier.com/crypto-gram/">Newsletter</a></li>
<li id="menu-item-50166" class="menu3 menu-item menu-item-type-post_type menu-item-object-page menu-item-50166"><a href="https://www.schneier.com/books/">Books</a></li>
<li id="menu-item-50169" class="menu4 menu-item menu-item-type-custom menu-item-object-custom menu-item-50169"><a href="https://www.schneier.com/essays/">Essays</a></li>
<li id="menu-item-50170" class="menu5 menu-item menu-item-type-custom menu-item-object-custom menu-item-50170"><a href="https://www.schneier.com/news/">News</a></li>
<li id="menu-item-50171" class="menu6 menu-item menu-item-type-custom menu-item-object-custom menu-item-50171"><a href="https://www.schneier.com/talks/">Talks</a></li>
<li id="menu-item-50167" class="menu7 menu-item menu-item-type-post_type menu-item-object-page menu-item-50167"><a href="https://www.schneier.com/academic/">Academic</a></li>
<li id="menu-item-50174" class="menu8 menu-item menu-item-type-post_type menu-item-object-page menu-item-50174"><a href="https://www.schneier.com/blog/about/">About Me</a></li>
</ul></div>				</div>
			</nav>

			
<aside>
	<div class="sidebar" id="sidebar-one">
		<section><div class="sidesection widget widget_schneier_search" id="schneier_search-3"><h3>Search</h3>
<p class="small">
	<em>Powered by <a href="https://duckduckgo.com/">DuckDuckGo</a></em></p>

<form method="get" action="https://duckduckgo.com/">

	<input type="hidden" name="kh" value="1" /><!-- use https -->

	<input id="search" name="q" size="15" maxlength="255" />

	<input type="submit" value="Go" /><br>

	<input type="radio" name="sites" id="searchblog" value="www.schneier.com/blog" />
	<label for="searchblog">Blog</label>

	<input type="radio" name="sites" id="searchessays" value="www.schneier.com/essays" />
	<label for="searchessays">Essays</label>

	<input type="radio" name="sites" id="searchall" value="www.schneier.com" checked="" />
	<label for="searchall">Whole site</label>

</form>
</div></section><section><div class="sidesection widget widget_schneier_social" id="schneier_social-2"><h3>Subscribe</h3>
<div id="subscription-buttons">

	<a href="https://www.schneier.com/feed/atom"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/rss-32px.png" alt="Atom Feed" /></a><a href="https://www.facebook.com/bruce.schneier"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/facebook-32px.png" alt="Facebook" /></a><a href="https://twitter.com/schneierblog/"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/twitter-32px.png" alt="Twitter" /></a><a href="https://www.amazon.com/Schneier-on-Security/dp/B0053HDDWW/"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/kindle-32px.png" alt="Kindle" /></a><a href="https://www.schneier.com/crypto-gram"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/email-32px.png" alt="E-Mail Newsletter (Crypto-Gram)" /></a>
</div>
</div></section>	</div>
</aside>

			<div id="content">

				
		<p id="breadcrumbs">

			<a href="https://www.schneier.com">Home</a><a href="https://www.schneier.com/blog/archives/">Blog</a>		</p>

		
<article id="post-3051" class="post-3051 post type-post status-publish format-standard hentry category-uncategorized tag-computer-security tag-operating-systems tag-security-engineering">

	<div class="article">

		<h2 class="entry">Proving a Computer Program&#039;s Correctness</h2>
		<p><a href="http://www.physorg.com/news173086905.html">This</a> is interesting:</p>
<blockquote><p>Professor Gernot Heiser, the John Lions Chair in Computer Science in the School of Computer Science and Engineering and a senior principal researcher with NICTA, said for the first time a team had been able to prove with mathematical rigour that an operating-system kernel—the code at the heart of any computer or microprocessor—was 100 per cent bug-free and therefore immune to crashes and failures.</p></blockquote>
<p>Don&#8217;t expect this to be practical any time soon:</p>
<blockquote><p>Verifying the kernel—known as the seL4 microkernel—involved mathematically proving the correctness of about 7,500 lines of computer code in an project taking an average of six people more than five years.</p></blockquote>
<p>That&#8217;s 250 lines of code verified per man-year.  Both Linux and Windows have something like 50 million lines of code; verifying that would take 200,000 man-years, assuming no increased complexity resulting from the increased complexity.  Clearly some efficiency improvements are required.</p>

		
			<p class="entry-tags">
				<span class="tags-links">Tags: <a href="https://www.schneier.com/tag/computer-security/" rel="tag">computer security</a>, <a href="https://www.schneier.com/tag/operating-systems/" rel="tag">operating systems</a>, <a href="https://www.schneier.com/tag/security-engineering/" rel="tag">security engineering</a></span>			</p>

		
		
		<p class="posted">
			<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html" rel="bookmark">Posted on October 2, 2009 at 7:01 AM</a>			•
			<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html#comments">91 Comments</a>		</p>

		<aside><div class="schneier-share share" data-uri="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html" data-title="Proving a Computer Program&#039;s Correctness" data-order="facebook twitter tumblr" data-social-share-privacy="true" /></aside>
	</div>

</article>


	<h3 id="comments">Comments</h3>

	
		<article class="comment even thread-even depth-1" id="comment-121757">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121757">
						October 2, 2009 7:19 AM					</a>

				</p>

				<p>Technically, it hasn&#8217;t proven to be &#8220;bug-free&#8221;. Part of proving program correctness is picking properties about the code to prove. If they overlooked even trying to prove some important property of the code, then it could still have unforseen problems. However, it&#8217;s a great accomplishment. They&#8217;ve proved that it&#8217;s free of certain classes of bugs that they knew to look for, which presumably cover most common failure modes.</p>
<p>What I&#8217;d like to know is how many bugs in the kernel source they found and corrected in the process of proving correctness.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121758">

			<div class="comment by-tom-welsh ">

				<p class="commentcredit">

					<span class="commenter">Tom Welsh</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121758">
						October 2, 2009 7:46 AM					</a>

				</p>

				<p>An entire Linux distribution may amount to 50 million LOC, but that can easily be broken down into separate programs and components (because that&#8217;s how proper softare is designed). Then the programs and components could be verified one by one, starting with the most important and those upon which other software depends.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121759">

			<div class="comment by-jrr ">

				<p class="commentcredit">

					<span class="commenter">JRR</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121759">
						October 2, 2009 7:59 AM					</a>

				</p>

				<p>Clearly we need to build a computer program that can mathematically prove the correctness of other computer programs.  Then we simply need to mathematically prove the correctness of that.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121760">

			<div class="comment by-jl ">

				<p class="commentcredit">

					<span class="commenter">Jl</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121760">
						October 2, 2009 8:02 AM					</a>

				</p>

				<p>Yup, it&#8217;s only as secure as the properties you&#8217;ve defined and proven.<br />
Furthermore, large math projects often contain errors: Don&#8217;t be surprised if, under closer scrutiny, someone finds a fault in their proofs.</p>
<p>Because of the Halting problem, termination of programs written in a turing complete language is not provable.<br />
And no OS can recover from all possible hardware failures.</p>
<p>THAT SAID:<br />
If the core of the OS has been proven to have many strong properties, e.g. it can&#8217;t crash under reasonable hardware assumptions, then building a more complex (and well tested!) OS on that proven core could be very profitable!</p>
<p>So congrats to the team and let&#8217;s see what we can build on their work.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121761">

			<div class="comment by-frank ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://blog.1ssa.net' rel='external nofollow ugc' class='url'>Frank</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121761">
						October 2, 2009 8:03 AM					</a>

				</p>

				<p>My experience with testing that I ahve seen with large code producing vendors is that they go with standard cases to test. In the year 1990 nobody was thinking of testing against buffer overflows. So does this method scale to address for the currently unknown? Reminds me of the guys producing &#8220;ants&#8221; to tackle malicious code. They already have 3000 different ants but where does it stop? Suddenly 30,000 ants are in your network or you spend 10 years to proove your code is bug free.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121762">

			<div class="comment by-dave-walker ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://blogs.sun.com/davew' rel='external nofollow ugc' class='url'>Dave Walker</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121762">
						October 2, 2009 8:03 AM					</a>

				</p>

				<p>&#8230;lest we forget the Viper chip &#8211; proven correct, yes, but practically, almost useless.</p>
<p>Also, I can&#8217;t help but roll the classic Knuth quote out &#8211; &#8220;Note that I have not tested this code, I have merely proven it correct&#8221;.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121763">

			<div class="comment by-tim ">

				<p class="commentcredit">

					<span class="commenter">Tim</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121763">
						October 2, 2009 8:09 AM					</a>

				</p>

				<p>This page has the answers to any questions people will ask here:</p>
<p><a href="http://ertos.nicta.com.au/research/l4.verified/proof.pml" rel="nofollow ugc">http://ertos.nicta.com.au/research/l4.verified/proof.pml</a></p>
<p>In particular:</p>
<p>&#8220;We mentioned above that our formal proof of functional correctness implies the absence of whole classes of common programming errors. Provided our assumptions above are true, some of these common errors are:</p>
<pre><code>* Buffer overflows
* Null pointer dereferences
* Pointer errors in general
* Memory leaks
* Arithmetic overflows and exceptions"
</code></pre>
<p>Apparently they are all impossible in seL4.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121764">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121764">
						October 2, 2009 8:10 AM					</a>

				</p>

				<p><i>Furthermore, large math projects often contain errors: Don&#8217;t be surprised if, under closer scrutiny, someone finds a fault in their proofs.</i></p>
<p>Well, these are all computer-checked proofs, so there can&#8217;t be any errors in the <em>proofs</em>, though there could be errors in the formulation of the theorems, or, very unlikely, in the axioms.</p>
<p><i>Because of the Halting problem, termination of programs written in a turing complete language is not provable.</i></p>
<p>That&#8217;s only true in the general case. It&#8217;s trivial to prove the termination of many programs. I would guess that it&#8217;s possible to implement any computable algorithm that always terminates in a manner that can be proven to terminate.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121765">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121765">
						October 2, 2009 8:11 AM					</a>

				</p>

				<p>Crap. First and third paragraphs are quotes.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121766">

			<div class="comment by-aikimark ">

				<p class="commentcredit">

					<span class="commenter">aikimark</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121766">
						October 2, 2009 8:14 AM					</a>

				</p>

				<p>Even the simplest programs are not immune from defects.  In OS/360, one of the simplest programs, IEFBR14, had to be patched.  One tale I heard was that it was the first patch every issued &#8212; and the program is only 4-6 lines of assembly instructions!</p>
<p>==========<br />
@JRR</p>
<p>I&#8217;m not sure that this is possible, given the work of Alan Turing (et. al.).</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121767">

			<div class="comment by-alans ">

				<p class="commentcredit">

					<span class="commenter">AlanS</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121767">
						October 2, 2009 8:18 AM					</a>

				</p>

				<p>@JRR<br />
Agreed. See writings by Michael Mahoney, an historian of computing at Princeton, on &#8216;sofware engineering&#8217; and mathematical theory in computing science.<br />
<a href="http://www.princeton.edu/~mike/computing.html" rel="nofollow ugc">http://www.princeton.edu/~mike/computing.html</a></p>
<p>From &#8216;Computer Science: The Search for a Mathematical Theory&#8217;:<br />
&#8220;Efforts to bring mathematical rigor to programming quickly reach a level of complexity that makes the techniques of verification subject to the very concerns that prompted their development&#8230;.computer science remains an amalgam of mathematical theory, engineering practice, and craft skill.&#8221;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121768">

			<div class="comment by-christopher ">

				<p class="commentcredit">

					<span class="commenter">christopher</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121768">
						October 2, 2009 8:25 AM					</a>

				</p>

				<p>The best way to think about this is: proving a program correct means it matches your design.  If your design is flawed, your program is equally flawed, but it is still &#8220;correct&#8221; since it matches spec.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121769">

			<div class="comment by-tim ">

				<p class="commentcredit">

					<span class="commenter">Tim</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121769">
						October 2, 2009 8:28 AM					</a>

				</p>

				<p>Furthermore, pdf23ds:</p>
<p>&#8220;How many bugs have you found?</p>
<p>We found 160 bugs in the C code in total. 16 of these were found during testing and internal student projects running the kernel before the C verification had started in earnest. 144 bugs were found during the C verification phase.&#8221;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121770">

			<div class="comment by-jp ">

				<p class="commentcredit">

					<span class="commenter">JP</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121770">
						October 2, 2009 8:41 AM					</a>

				</p>

				<p>&#8220;Because of the Halting problem, termination of programs written in a turing complete language is not provable.&#8221;</p>
<p>No, it&#8217;s impossible to write a program that, given a second program as input, can determine whether the second program will terminate.</p>
<p>It is, however, entirely possible to prove that individual programs will terminate.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121771">

			<div class="comment by-david ">

				<p class="commentcredit">

					<span class="commenter">David</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121771">
						October 2, 2009 8:46 AM					</a>

				</p>

				<p>It&#8217;s also worth noting that this is a proof of certain correctness properties for the C code.  The assembly language code involved was not proved correct, and the translation and loading of the C code was assumed correct.</p>
<p>This is a very impressive achievement, but the relatively limited results show that formal code verification is very, very difficult.</p>
<p>My personal experience with formal correctness proofs is that it&#8217;s possible to prove small things correct (which can be very useful), and once I&#8217;ve proven something correct the only errors tend to be the really stupid kind that are easy to find and fix.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121772">

			<div class="comment by-pete-austin ">

				<p class="commentcredit">

					<span class="commenter">Pete Austin</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121772">
						October 2, 2009 8:57 AM					</a>

				</p>

				<p>In the real world, &#8220;100 per cent bug-free&#8221; does NOT mean it&#8217;s &#8220;immune to crashes and failures&#8221;.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121773">

			<div class="comment by-kangaroo ">

				<p class="commentcredit">

					<span class="commenter">kangaroo</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121773">
						October 2, 2009 9:01 AM					</a>

				</p>

				<p>JP : &#8220;No, it&#8217;s impossible to write a program that, given a second program as input, can determine whether the second program will terminate.<br />
It is, however, entirely possible to prove that individual programs will terminate.&#8221;</p>
<p>A proof is equivalent to writing a program. So, to say it more correctly, it is possible to write a program that can determine the termination of a sub-class of other programs &#8212; just not all classes of other programs (including the class of programs that your proof belongs to).</p>
<p>The sub-class would then have to not belong to the class of programs that can fully implement Principia Mathematica &#8212; it would be the unGodelizable set of programs.</p>
<p>Now, Turing-complete is basically isomorphic with Godelizable &#8212; one is the programming idea, while the latter is the formal systems idea. So, we&#8217;re talking about programs which are unable to to interpret a Turing-complete language &#8212; even if they were written in one.</p>
<p>So, to go beyond simply proving a subset of the properties of a program, but instead &#8220;prove&#8221; the given program in general, the program would have to be a pretty simple one &#8212; one that, in short, is incapable of modifying itself in general. Most kernels and computer systems are &#8212; in general, they&#8217;d be pretty damn useless if they couldn&#8217;t.</p>
<p>Of course, there is a way around all that &#8212; because in fact all real computers have finite memory. So you could iterate through all the states of the program and determine all the programs properties. So, you can trivially show that a brute force approach exists for the subset of programs that will actually run on a given real computer (since no real computer is actually Turing complete).</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121774">

			<div class="comment by-sp332 ">

				<p class="commentcredit">

					<span class="commenter">sp332</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121774">
						October 2, 2009 9:04 AM					</a>

				</p>

				<p>@JP:<br />
&#8220;It is, however, entirely possible to prove that individual programs will terminate.&#8221;</p>
<p>How are you going to prove that?  You would have to write a Turing machine that takes that program as input and proves whether or not it halts.  So no, you can&#8217;t prove that any given program will terminate.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121775">

			<div class="comment by-aguirre ">

				<p class="commentcredit">

					<span class="commenter">Aguirre</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121775">
						October 2, 2009 9:07 AM					</a>

				</p>

				<p>&#8220;the code at the heart of any computer or microprocessor—was 100 per cent bug-free and therefore immune to crashes and failures.&#8221;</p>
<p>We fired the microprocessor up and ????</p>
<p>It got a soft error caused by a nasty little cosmic ray.</p>
<p>More lead shielding required.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121776">

			<div class="comment by-mike-sperber ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.deinprogramm.de/sperber/' rel='external nofollow ugc' class='url'>Mike Sperber</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121776">
						October 2, 2009 9:09 AM					</a>

				</p>

				<p>Elsewhere, huge strides are being made wrt. efficiency, given that a lot of research is going into proof-assistant software. In the CompCert project, proving about 6000 lines of a compiler (for a large subset of C) took Xavier Leroy about 3 years.</p>
<p><a href="http://compcert.inria.fr/" rel="nofollow ugc">http://compcert.inria.fr/</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121777">

			<div class="comment by-jp ">

				<p class="commentcredit">

					<span class="commenter">JP</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121777">
						October 2, 2009 9:16 AM					</a>

				</p>

				<p>&#8220;So no, you can&#8217;t prove that any given program will terminate.&#8221;</p>
<p>To be more clear, given a single, specific program, it may be possible to prove that it terminates. (In other words, you <em>can</em> write a program that, given another program as input, will output &#8220;terminates&#8221;, &#8220;does not terminate&#8221;, and &#8220;cannot determine&#8221;.)</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121778">

			<div class="comment by-paul ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://alltoosimple.wordpress.com' rel='external nofollow ugc' class='url'>paul</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121778">
						October 2, 2009 9:25 AM					</a>

				</p>

				<p>Where is the cost? If in the translation of code into logical specification and vice versa, you&#8217;re sunk. But if it&#8217;s just prover cycles, Moore&#8217;s law should be helping on that.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121779">

			<div class="comment by-adam ">

				<p class="commentcredit">

					<span class="commenter">Adam</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121779">
						October 2, 2009 9:27 AM					</a>

				</p>

				<p>@sp332</p>
<p>No, you don&#8217;t need to go to a Turing Machine in this case. The key word here is &#8220;individual&#8221;. The point about Turing Machines is a subtle one in that it <em>only</em> refers to the general case. A single program can be proven correct manually if it&#8217;s within a very small size. You can look up unassisted proofs that quicksort terminates.</p>
<p>For larger programs, you need a machine to help you. The general technique is to come up with a set of small-but-useful theorems that you <em>can</em> prove to be true manually, then construct your proof in terms of those theorems. This may be a poor analogy, but the technique is vaguely similar to applying functional decomposition to standard programming problems.</p>
<p>You quickly hit a point where you need machine checking to make this kind of proof manageable, but if you&#8217;re smart about it (and these guys are) you don&#8217;t leave any unreasonable assumptions unchecked.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121780">

			<div class="comment by-paul-crowley ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.ciphergoth.org/' rel='external nofollow ugc' class='url'>Paul Crowley</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121780">
						October 2, 2009 9:56 AM					</a>

				</p>

				<p>&#8220;Because of the Halting problem, termination of programs written in a turing complete language is not provable.&#8221;</p>
<p>I can prove that this program terminates:</p>
<p>int main(int argc, char *argv[]) {<br />
    return 0;<br />
}</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121781">

			<div class="comment by-gilberto ">

				<p class="commentcredit">

					<span class="commenter">gilberto</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121781">
						October 2, 2009 10:11 AM					</a>

				</p>

				<p>IEFBR14 is just 2 assemby instructions: set returncode to zero, then return to calling program. it really does nothing, but functions as a place holder for IBM MVS/zOS operating system to do file allocations, within MVS JCL scripts, so it is not a good example or benchmark in this case. as for the halting problem: you can not write a universal program UP, that can determine if ANY given inout program P halts. The key here is that UP has to work for ALL input programs, but clearly there are many programs small and large that can be shown to terminate.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121782">

			<div class="comment by-curt-sampson ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.starling-software.com/' rel='external nofollow ugc' class='url'>Curt Sampson</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121782">
						October 2, 2009 10:21 AM					</a>

				</p>

				<p>There was a presentation on this given at ICFP last month. Searching for &#8220;Experience Report: seL4 &#8212; Formally Verifying a High-Performance Microkernel&#8221; will bring up all sorts of links to the paper and its related research; the video is available at <a href="http://vimeo.com/6628930" rel="nofollow ugc">http://vimeo.com/6628930</a> .</p>
<p>For those who haven&#8217;t followed up on the details, the proof was quite a lot of work. They proved about 7000 lines of C code, but the proof is about 150,000 lines of code (which is machine-checked).</p>
<p>Note that proving certain properties of code (as opposed to testing, which, as Dikjstra so famously said, can only show the presence of errors, not their absence) is something that many programmers have been doing in a limited way for a long time: that&#8217;s the whole point of a type system. Languages like Java, unfortunately, have rather lame type systems and so don&#8217;t let you prove very much at all (and often what you can prove isn&#8217;t of very much use), but there are far more powerful systems out there, and in fact that is, at least in part, what systems like Isabelle (which is what was used to prove this OS kernel) provide.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121783">

			<div class="comment by-jo ">

				<p class="commentcredit">

					<span class="commenter">Jo</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121783">
						October 2, 2009 10:22 AM					</a>

				</p>

				<p>Paul says:<br />
&#8220;I can prove that this program terminates:</p>
<p>int main(int argc, char *argv[]) {<br />
return 0;<br />
}<br />
&#8221;<br />
Sure &#8211; and I can prove my &#8220;hello world&#8221; program terminates as well (unless I put in that &#8216;goto 10&#8217; line at the end&#8230;).  But do you have an algorithm for proving that an arbitrary program terminates?</p>
<p>Of course- proving termination (or non-termination) is not the same as proving there are no bugs, nor is it: &#8220;mathematically proving the correctness of about 7,500 lines of computer code&#8221;.  And what I <em>really</em> want to know is what was proven?  It sounds like what was proven was that the code will not allow several classes of faults to occur &#8211; but is that &#8216;correctness&#8217;?  (Note &#8211; &#8216;correctness&#8217; sounds to me like the syntax is correct and when I run it through gcc, I get an a.out that does <em>something</em> approximating what I wanted it to do).</p>
<p>Then there are the inevitable tradeoffs &#8211; by preventing these types of errors, are there things that the computer cannot now be programmed to do (using that OS)?  I don&#8217;t know &#8211; just throwing the question out there&#8230;</p>
<p>ex animo omnes-</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121784">

			<div class="comment by-alan-braggins ">

				<p class="commentcredit">

					<span class="commenter">Alan Braggins</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121784">
						October 2, 2009 10:47 AM					</a>

				</p>

				<blockquote><p>
  Well, these are all computer-checked proofs, so there can&#8217;t be any errors in the <em>proofs</em>
</p></blockquote>
<p>Not strictly true, since there could be errors in the checking code (including the operating system it runs on), or errors in the design of the hardware it runs on.<br />
Bootstrapping an entire verified system from designs which are simple enough to reliably verify manually would be a truely huge task.</p>
<p>Early IEFBR14 history is described on <a href="http://en.wikipedia.org/wiki/IEFBR14#History_from_the_RISKS_Digest" rel="nofollow ugc">http://en.wikipedia.org/wiki/IEFBR14#History_from_the_RISKS_Digest</a></p>
<p>There are implementations of /bin/true with comparable revision histories.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121785">

			<div class="comment by-o-s ">

				<p class="commentcredit">

					<span class="commenter">o.s.</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121785">
						October 2, 2009 11:06 AM					</a>

				</p>

				<p>I&#8217;m quite interested in formal software proofs but I don&#8217;t know if it will ever become a practical exercise. For example, a simple program with just 32 if statements already has 2^32 unique states for true and false across those 32 if statements. So already the task of correctly verifying the simplest of programs can become huge.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121786">

			<div class="comment by-adam ">

				<p class="commentcredit">

					<span class="commenter">Adam</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121786">
						October 2, 2009 11:08 AM					</a>

				</p>

				<p>Does it matter whether we can prove Windows is bug-free? We&#8217;ve already proven that it <em>isn&#8217;t</em> bug-free.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121787">

			<div class="comment by-impossibly-stupid ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.impossiblystupid.com' rel='external nofollow ugc' class='url'>Impossibly Stupid</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121787">
						October 2, 2009 11:13 AM					</a>

				</p>

				<p>The real world does not respect mathematical proofs of this nature:</p>
<p><a href="http://en.wikipedia.org/wiki/Pentium_FDIV_bug" rel="nofollow ugc">http://en.wikipedia.org/wiki/Pentium_FDIV_bug</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121788">

			<div class="comment by-aikimark ">

				<p class="commentcredit">

					<span class="commenter">aikimark</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121788">
						October 2, 2009 11:26 AM					</a>

				</p>

				<p>@Alan Braggins</p>
<p>Thanks for the IEFBR14 link.  Ahhhh&#8230;memories.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121789">

			<div class="comment by-john-wilson ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.flickr.com/photos/tug/' rel='external nofollow ugc' class='url'>John Wilson</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121789">
						October 2, 2009 11:33 AM					</a>

				</p>

				<p>I hope it doesn&#8217;t all end in tears like the RSRE&#8217;s VIPER &#8220;formally specified&#8221; microprocessor.</p>
<p><a href="http://catless.ncl.ac.uk/Risks/10.15.html#subj4" rel="nofollow ugc">http://catless.ncl.ac.uk/Risks/10.15.html#subj4</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121790">

			<div class="comment by-joe-buck ">

				<p class="commentcredit">

					<span class="commenter">Joe Buck</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121790">
						October 2, 2009 11:52 AM					</a>

				</p>

				<p>&#8220;Because of the Halting problem, termination of programs written in a turing complete language is not provable.&#8221;</p>
<p>Incorrect. It only means that any correct procedure to try to prove whether programs halt must give three-way answers: it halts, it doesn&#8217;t halt, or it can&#8217;t be determined.</p>
<p>Optimizing compilers have to &#8220;solve the halting problem&#8221; in this sense all the time.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121791">

			<div class="comment by-ac ">

				<p class="commentcredit">

					<span class="commenter">-ac-</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121791">
						October 2, 2009 12:00 PM					</a>

				</p>

				<p>Great to have a framework like this. It would be interesting for a team to build a new OS using this framework as they went. Say, a smart phone OS.</p>
<p>But the microprocessor code would obviously more fundamental.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121792">

			<div class="comment by-pascal-cuoq ">

				<p class="commentcredit">

					<span class="commenter">Pascal Cuoq</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121792">
						October 2, 2009 12:03 PM					</a>

				</p>

				<p>To answer a few recurring misconceptions in the comments:</p>
<ul>
<li>
<p>yes, NICTA&#8217;s work does not protect us from bugs in the specifications. Do the usual human methods of testing and code reviews make us safe from bugs in the specifications? At least in seL4 there are some classes of bugs that cannot happen.</p>
</li>
<li>
<p>no, it is <em>extremely</em> unlikely that a bug will be found in the proofs, because the proofs are machine-checked. Bugs can be found at the interfaces (i.e. specifications and axioms). Again, do code reviews protect us from flawed assumptions in the reasoning of humans involved in the process? At least with seL4, <em>all</em> the hypotheses are written down so you can examine them for yourself.</p>
</li>
<li>
<p><em>some</em> programs can be proved to terminate. <em>Some</em> programs can be proved to be bug-free for a non-trivial definition of &#8220;bug&#8221;. This one has. This does not contradict Computability&#8217;s principles in the least.</p>
</li>
<li>
<p>Heck, even some uses of Skein-256 can be proved to be bug-free, for a limited but still not trivial definition of &#8220;bug&#8221;: see tutorial in <a href="http://frama-c.cea.fr/download/value-analysis-Beryllium-20090902.pdf" rel="nofollow ugc">http://frama-c.cea.fr/download/value-analysis-Beryllium-20090902.pdf</a></p>
</li>
</ul>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121794">

			<div class="comment by-nzruss ">

				<p class="commentcredit">

					<span class="commenter">Nzruss</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121794">
						October 2, 2009 12:52 PM					</a>

				</p>

				<p>To migrate toward &#8216;correctness&#8217; look at RTCA DO-178B. (level a).</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121795">

			<div class="comment by-anonymous ">

				<p class="commentcredit">

					<span class="commenter">anonymous</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121795">
						October 2, 2009 1:22 PM					</a>

				</p>

				<p>Bruce, seL4 is a microkernel. Most of what&#8217;s in Linux would go in the userspace. Unless your claim is everything down to the text editor should be formally verified, this is going to have a great deal of practical effect. If you&#8217;re curious, there was an attempt to make a low level language to allow easy verification proofs: <a href="http://www.bitc-lang.org/" rel="nofollow ugc">http://www.bitc-lang.org/</a> .</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121796">

			<div class="comment by-pascal-cuoq ">

				<p class="commentcredit">

					<span class="commenter">Pascal Cuoq</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121796">
						October 2, 2009 1:31 PM					</a>

				</p>

				<p>@Nzruss Interestingly, Airbus used comparable methods to satisfy some DO-178B objectives for some of the level A code of the A380.<br />
Sorry that the link is in French, but in the world of embedded code, you have to do with what you have:</p>
<p><a href="http://www.captronic.fr/documents/trophees/trophees-2009/trophees-embarque-2009-laureats.pdf" rel="nofollow ugc">http://www.captronic.fr/documents/trophees/trophees-2009/trophees-embarque-2009-laureats.pdf</a></p>
<p>(they published more information in English themselves at ERTS or similar venues)</p>
<p>Bruce mentions the &#8220;250 lines of code verified per man-year&#8221; ratio. An interesting question is how much does it cost to obtain near-complete confidence in a piece of code (say, level A code) using tests and code reviews. Apparently, about the same, since for some problems formal methods come out ahead (Airbus does not use formal methods by ideology. They use them because they think they can get a competitive advantage this way).</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121797">

			<div class="comment by-anthony-derobertis ">

				<p class="commentcredit">

					<span class="commenter">Anthony DeRobertis</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121797">
						October 2, 2009 2:12 PM					</a>

				</p>

				<p>The halting problem is for universal Turing machines. No such thing has ever been built nor, within the known laws of physics, is such a thing buildable. Computers are finite state machines (assuming we&#8217;re talking a computer with no true random number generator).</p>
<p>It&#8217;s &#8220;easy&#8221; to prove if a finite state machine halts. Keep running it, writing down each state it enters, until you either (a) hit the halt state, in which case it clearly halts; (b) hit a state you&#8217;ve seen before, in which case it does not halt, ever.</p>
<p>Of course, actually doing that isn&#8217;t possible, because the number of states is far too large. But, mathematically, its possible.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121798">

			<div class="comment by-jldugger ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://pwnguin.net' rel='external nofollow ugc' class='url'>jldugger</a></span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121798">
						October 2, 2009 2:26 PM					</a>

				</p>

				<p>Part of the point is that microkernels are small. Proving a microkernel correct is like proving the initialization, interrupt handlers and message passing systems of Linux or OS are correct.</p>
<p>Actual paper (check october ACM for the quasi official one to cite) <a href="http://ertos.nicta.com.au/publications/papers/Klein_EHACDEEKNSTW_09.pdf" rel="nofollow ugc">http://ertos.nicta.com.au/publications/papers/Klein_EHACDEEKNSTW_09.pdf</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121799">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121799">
						October 2, 2009 2:27 PM					</a>

				</p>

				<p>A simple question to ponder,</p>
<p>Do I care if the OS is provably bug free provided it has a mechanisum which recognises errors and exceptions and handels them in a sensible way?</p>
<p>As has been noted &#8220;nothing in life is perfect&#8221; but we still manage to get things done (ECC&#8217;s work wonders for more than unreliable communications).</p>
<p>Another thing is if we assume for arguments sake the kernel is sufficiently robust, when are we going to se a security hypervisor for it.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121800">

			<div class="comment by-random-walk ">

				<p class="commentcredit">

					<span class="commenter">Random Walk</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121800">
						October 2, 2009 2:33 PM					</a>

				</p>

				<p>Termination can certainly be proven for many programs, however, an operating system kernel does not necessarily need to terminate !</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121801">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121801">
						October 2, 2009 2:50 PM					</a>

				</p>

				<p>Actually, seL4 isn&#8217;t totally verified yet. All of the C code is, but several hundred lines of x86 and ARM assembler aren&#8217;t. One of the next phases is a correspondence proof of the ARM assembler, as the technology will be used on cell phones by OK Labs. It will likely be integrated into OKL4, already excellent product.</p>
<p>Clive, you should care. None of those &#8220;error-tolerant&#8221; systems can protect your private key, prevent a drive-by-download from disabling your firewall, etc. seL4, which I&#8217;ve posted about many times here, is a MILS architecture kernel that isolates critical apps from main system. It currently has paravirtualized Linux, and the OKL4 and seL4 microvisors allow one to use drivers in any of the partitions. The small TCB and formal proof provide extreme confidence in it.</p>
<p>Want to see a security hypervisor for it? It is a separation kernel, which is useful enough in some situations. It IS a hypervisor for Linux apps. It runs on x86 and ARM. If you want to get started, download and play with OKL4. It&#8217;s used in many cell phones right now. They are gradually transforming OKL4 into seL4: it will be at its core, or offered as a separate product.</p>
<p>Personally, I&#8217;m very excited about this and I anxiously await both the separation kernel and the development/porting of high assurance middleware.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121802">

			<div class="comment by-rik-uk ">

				<p class="commentcredit">

					<span class="commenter">Rik, UK</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121802">
						October 2, 2009 3:01 PM					</a>

				</p>

				<p>It seems that people like to comment on the Halting Problem, many citing Turing Machines, despite the fact that they have obviously not read Turing&#8217;s work. Perhaps they would find the earlier work carried out by Church easier to understand?</p>
<p>The works by Church and Turing rely solely on mathematical proofs. No mention is made of computational automata.</p>
<p>I do wish that people who work in IT would stick to IT and not pretend that they are computer scientists.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121803">

			<div class="comment by-valentin ">

				<p class="commentcredit">

					<span class="commenter">Valentin</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121803">
						October 2, 2009 3:57 PM					</a>

				</p>

				<p>@Rick:</p>
<p>😀 &#8211; you yourself might want to read &#8220;On Computable Numbers with an application to the Entscheidungsproblem&#8221; &#8211; probably Turing&#8217;s most famous paper and the one where he defines what is now known as Turing machine. The first section is called &#8220;Computing Machines&#8221;&#8230; You can download the entire paper here <a href="http://www.comlab.ox.ac.uk/activities/ieg/e-library/sources/tp2-ie.pdf" rel="nofollow ugc">http://www.comlab.ox.ac.uk/activities/ieg/e-library/sources/tp2-ie.pdf</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121804">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121804">
						October 2, 2009 4:11 PM					</a>

				</p>

				<p>Impossibly Stupid, your name is pretty much right. The Pentium FDIV bug was present <em>before</em> Intel starting using formal verification for their processors, and in fact, the bug is what caused them to start doing formal verification.</p>
<p>I simply can&#8217;t believe how many people in this thread keep flogging dead horses. Five different people all saying the same mistaken bullshit about the halting problem, and twice as many people correcting them. Several people pointing out the possibility of bugs in the proof verifiers, even though it&#8217;s extremely unlikely. It&#8217;s like no one read the first ten comments.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121805">

			<div class="comment by-david ">

				<p class="commentcredit">

					<span class="commenter">David</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121805">
						October 2, 2009 4:27 PM					</a>

				</p>

				<p>@Anthony DeRobertis:  It seems symmetric to me.  Mathematically, you can&#8217;t necessarily predict if a Turing machine (which is a mathematical construct) will halt.  Practically, you can&#8217;t necessarily predict if a practical computer will halt.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121806">

			<div class="comment by-david ">

				<p class="commentcredit">

					<span class="commenter">David</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121806">
						October 2, 2009 4:40 PM					</a>

				</p>

				<p>pdf23ds:  Have the proof verifiers been proved correct, and are we sure that proof is correct?  If not, then we are entitled to suspect the verifiers might be buggy.</p>
<p>&#8216;I would guess that it&#8217;s possible to implement any computable algorithm that always terminates in a manner that can be proven to terminate.&#8221;  Certainly, for any program that terminates there is a program with the same output that provably terminates, but I don&#8217;t think that&#8217;s what you mean.  I can write a computable algorithm for testing Goldbach&#8217;s Conjecture that either will or will not always terminate.  (My guess is that it doesn&#8217;t, but I can amass enough unproven conjectures so that by sheer chance I&#8217;ve likely got one that terminates.)  You&#8217;re not going to be able to solve these by determining which algorithms terminate.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121807">

			<div class="comment by-anonanona ">

				<p class="commentcredit">

					<span class="commenter">anonanona</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121807">
						October 2, 2009 5:03 PM					</a>

				</p>

				<p>@David</p>
<p>&#8220;pdf23ds: Have the proof verifiers been proved correct, and are we sure that proof is correct? If not, then we are entitled to suspect the verifiers might be buggy.&#8221;</p>
<p>And you might as well say, &#8220;What if the hardware on which the proof was run were buggy? Then the output is suspect!&#8221; My only response is, it is easier to check for errors in one verifier than it is to check for errors in multitudinous programs.</p>
<p>The link posted above by Tim I will repost here because obviously many of you have not read it:</p>
<p><a href="http://ertos.nicta.com.au/research/l4.verified/proof.pml" rel="nofollow ugc">http://ertos.nicta.com.au/research/l4.verified/proof.pml</a></p>
<p>Read it as it addresses many of your critiques.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121808">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121808">
						October 2, 2009 5:05 PM					</a>

				</p>

				<p>@ David</p>
<p>The first line of your recent post shows the most important issues. The 1st issue, proving the prover, is largely solved. When proving, one goes for a &#8220;sound&#8221; prover. Those like Isabelle have at their core an easily verified, very sound logic. It makes their results believable. Quite honestly, building on a hand-verified core based on formal logic is probably the best we can do there. Now onto the 2nd issue&#8230;</p>
<p>@ pdf23ds</p>
<p>I&#8217;m one of the guys who actually read the comments and many papers, like Guttman&#8217;s, on where formal methods screwed up. Many, MANY cases of it. The 2nd issue david mentions is responsible: problematic proofs. Proofs can be machine checked but very wrong.</p>
<p>The real-world system must be modeled accurately, and with the right amount of granularity. Issues with the prover, like inability to represent infinity, must be properly accounted for. In process of creating intermediate proofs, one mustn&#8217;t abstract away important properties. It&#8217;s all very tough and there still is no real standard methodology for doing it. Everyone is constantly inventing new tools, new logics, new approaches, using different programming languages etc.</p>
<p>All this nonsense about halting problems and stuff aside, are you at all surprised at the skepticism by some comments? I mean, mathemeticians have been screwing up simple proofs for well-understood phenomenon for years. This is a 100,000+ line proof of a complex system using brand new models of Haskell and C. While NICTA and UNSW is renown for quality and I&#8217;m a big fan of this, even I would like to see some VERY thorough independent review of those big ass proofs. Isn&#8217;t complexity the enemy of security? Where&#8217;s the &#8220;code review&#8221; of these proofs? Or even the code itself, which isn&#8217;t released?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121809">

			<div class="comment by-rjh ">

				<p class="commentcredit">

					<span class="commenter">rjh</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121809">
						October 2, 2009 5:05 PM					</a>

				</p>

				<p>@pdf23:</p>
<p>&#8220;I would guess that it&#8217;s possible to implement any computable algorithm that always terminates in a manner that can be proven to terminate.&#8221;</p>
<p>By definition, algorithms terminate.  That&#8217;s one of their properties.  See TAoCP Vol 1, page 4; algorithms always terminate.  By the Church-Turing conjecture, all algorithms are computable.  So let&#8217;s rewrite this as, &#8220;I would guess that it&#8217;s possible to implement algorithms in ways that can be proven to terminate.&#8221;</p>
<p>The Curry-Howard correspondence connects proofs of correctness with implementations in some pretty deep and surprising ways.  If you can prove it&#8217;s an algorithm, then you compile your proof and you&#8217;ve got executable code.</p>
<p>So you&#8217;re right, yes &#8212; I&#8217;m just not sure what you were trying to say.  It seems pretty tautological.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121810">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121810">
						October 2, 2009 5:08 PM					</a>

				</p>

				<p>&#8220;Have the proof verifiers been proved correct, and are we sure that proof is correct? If not, then we are entitled to suspect the verifiers might be buggy.&#8221;</p>
<p>The thing is, the way computers are written, there are lots of &#8220;abstraction boundaries&#8221;, between which bugs are a lot less likely than within those boundaries. Your program will very rarely produce the wrong output because of a compiler bug (though it&#8217;s not been unknown), and even more rarely produce the wrong output because of a kernel bug. Bugs in compilers and kernels tend to make programs crash.</p>
<p>The way most proof verifiers are written (including the one used here), there&#8217;s only a very small amount of code that is required to be trusted to be correct. All the rest of the code simply manipulates the interface exposed by the reliable core, and cannot have bugs that allow incorrect proofs. Since the core is general and simple, bugs in it would tend to show up rather frequently in higher-level mechanisms. So simply by using proof engine a lot, we <em>very</em> thoroughly test the core.</p>
<p>Of course there&#8217;s no proof. But you can be extremely confident. Even if there was a proof, we still couldn&#8217;t trust <em>that</em> proof absolutely; it would be changing our expectation of any bugs from .000001 to .000000001, which isn&#8217;t a significant difference for most practical purposes.</p>
<p>Nothing in the world is certain. Do we know for certain that Perelman&#8217;s proof of the Poincare conjecture is correct? It seems very likely, but there&#8217;s a very small chance that there&#8217;s some mistake in there that hasn&#8217;t been caught by anyone reviewing the proof. Do we know, absolutely certainly, that there are an infinite number of primes? The proof can be followed by a grade school student, but can we be absolutely sure? I think that the same things that make us sure about those proofs&#8211;being consistent with other mathematics, part of a fabric of coherent theory&#8211;make us sure (to a lesser, but still great extent) about the reliability of proof checkers.</p>
<p>&#8220;I can write a computable algorithm for testing Goldbach&#8217;s Conjecture that either will or will not always terminate.&#8221;</p>
<p>I anticipated that objection. Perhaps I should have said, for any algorithm that is <em>known</em> (i.e. can be proved) to always terminate, a program can implement that algorithm that can be proved to terminate. Which doesn&#8217;t actually sound all that impressive, now that I think about it. Proving that a program testing the GC would/wouldn&#8217;t terminate would subsume proving/disproving the GC. Hmm. I think there must be a way to make my statement stronger, but I can&#8217;t think of it.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121811">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121811">
						October 2, 2009 5:15 PM					</a>

				</p>

				<p>Nick,</p>
<p>&#8220;are you at all surprised at the skepticism by some comments?&#8221;</p>
<p>Not really. I guess I pretty much agree with your comment. I guess I was just making a more limited point about Isabelle itself, rather than the L4 verification project.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121812">

			<div class="comment by-aguirre ">

				<p class="commentcredit">

					<span class="commenter">Aguirre</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121812">
						October 2, 2009 5:16 PM					</a>

				</p>

				<p>Am enjoying the discourse.  A suggested topic for next week, that old favourite the &#8220;Come From&#8221; statement:</p>
<p><a href="http://www.fortran.com/come_from.html" rel="nofollow ugc">http://www.fortran.com/come_from.html</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121813">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121813">
						October 2, 2009 5:23 PM					</a>

				</p>

				<p>&#8220;By definition, algorithms terminate.&#8221;</p>
<p>OK, I&#8217;m confused here. You&#8217;re saying that an &#8220;algorithm&#8221; that terminates if it disproves the Goldbach conjecture is not an algorithm unless we can disprove the Goldbach conjecture? If such a thing is not an algorithm, what do you call it? Surely &#8220;program&#8221; is not the best word.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121814">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121814">
						October 2, 2009 5:48 PM					</a>

				</p>

				<p>By &#8220;algorithm that terminates if it disproves the GC&#8221; I mean one that tests even numbers sequentially until it finds one that doesn&#8217;t decompose into two primes, of course.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121815">

			<div class="comment by-anonanona ">

				<p class="commentcredit">

					<span class="commenter">anonanona</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121815">
						October 2, 2009 5:49 PM					</a>

				</p>

				<p>terminal &#8211; the end, the extremity<br />
terminate &#8211; to bring to the end, i.e., the terminal</p>
<p>So, I guess he means it&#8217;s not a real algorithm unless it runs on a real terminal. He is hardcore.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121816">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121816">
						October 2, 2009 6:12 PM					</a>

				</p>

				<p>@ Dave Walker</p>
<p>Your comments are misleading. I just read the VIPER paper. For one, it <em>wasn&#8217;t</em> formally verified. The authors dedicate the entire conclusion to saying their proof was partial, mainly model-checking, and there was no correspondence proof. Second, if you look at its features, it actually is useful. It was just very different and another technology to fall to politics and market forces.</p>
<p>If you want practical processors with formal methods, then you should look at AAMP7G (recent) by Rockwell-Collins and VAMP, which is in the MIPS family. AAMP7G is running separation kernels for safety/security-critical stuff. VAMP is MIPS-like, which might allow us to easily port RTOS&#8217;s to it, many supporting MIPS. Also, VAMP supports user/kernel modes and (i think) interrupts. What we need now is formally verified hardware assisted OS and IO virtualization, at least an IOMMU. Then I wouldn&#8217;t have to trust those binary blobs. 😉</p>
<p>@ pdf23ds</p>
<p>Your explanation of why we can trust sound provers like HOL was excellent. This same line of reasoning is why most hardware proof effort is aimed at the microcode and a few other specific units. In most cases, if the core works right, the rest is easy to build. Modularity increases overall complexity, but reduces difficulty of verification (any kind). Each component can be proven independently, and then their interactions can be modeled to prove overall system. This is partially why high assurance is moving to separation kernels.</p>
<p>More rigorous math:</p>
<p>verified processor (VAMP/AAMP7G) + verified IOMMU + verified RTOS (INTEGRITY-DO178B/seL4) + medium assurance good middleware (DO-178B networking, USB, Java, etc. stacks maybe?) + modular apps designed to take advantage of it all (perhaps in SPARKS Ada or OCaml/Haskell?) + (simpler) formal proof of their interactions = a system I could trust</p>
<p>Fortunately, all of this exists today. It just has to be properly integrated. Anyone in the know would realize that is a mind-boggling challenge, but I think the rewards will be worth it. At least to those of us who value security, safety and privacy.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121817">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121817">
						October 2, 2009 6:34 PM					</a>

				</p>

				<p>&#8220;Your explanation of why we can trust sound provers like HOL was excellent.&#8221;</p>
<p>Aww, thanks.</p>
<p>&#8220;At least to those of us who value security, safety and privacy.&#8221;</p>
<p>Hmm. I&#8217;m wondering how you would go about proving privacy. With things like the facebook datamining attack Bruce just wrote about, it seems like that would be a challenge <em>at least</em> several orders of magnitude more difficult than proving the absence of buffer overruns and null pointer dereferencing. What attack models do you account for? Physical access? Direct hard drive platter access? Do you assume access to semi-public data and prove the absence of ways to infer private data?</p>
<p>Would it be possible to design an unkeyloggable keyboard? (I&#8217;m sure. I wonder if they exist yet.)</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121818">

			<div class="comment by-rjh ">

				<p class="commentcredit">

					<span class="commenter">rjh</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121818">
						October 2, 2009 6:38 PM					</a>

				</p>

				<p>@pdf23ds:</p>
<p>&#8220;You&#8217;re saying that an &#8220;algorithm&#8221; that terminates if it disproves the Goldbach conjecture is not an algorithm unless we can disprove the Goldbach conjecture? If such a thing is not an algorithm, what do you call it? Surely &#8220;program&#8221; is not the best word.&#8221;</p>
<p>A sequence of instructions which terminates only if some property of the inputs holds true is usually called a semialgorithm.  There&#8217;s some computer science formalisms that define &#8220;semialgorithm&#8221; more specifically than this, but by and large you can call such problems semialgorithms.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121819">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121819">
						October 2, 2009 8:36 PM					</a>

				</p>

				<p>@ pdf23ds</p>
<p>It would be challenging to accomplish privacy in general. As you suspected, I&#8217;m thinking of specific attack models: protecting private GPG/PGP key; other encryption keys (i.e. truecrypt); defeat keyloggers; prevent screen spoofing (assumed feature of MLS security); anonymous web traffic; network is a black box via effective firewall (red/black separation); private communications over the internet. These are just some of the problems that I&#8217;ve been trying to solve in my own designs. Many others are working on them, and most of these are solved. I&#8217;ll be specific on one.</p>
<p>You mentioned unkeyloggable keyboard. I think what you want is a trusted path. Many hardware attacks, so the main idea is to prevent remote access software attacks, right? Thanks, again, to microkernels and separation kernels, this has been achieved. A basic design has these components: user application VM (usually Linux); GUI or screen renderer; mouse, keyboard and graphics driver. Only the GUI system can access the drivers, and the VM/apps must go through it. The communication policy of the trusted separation kernel (i.e. seL4), which can&#8217;t be overridden, ensures the security of this scheme. The GUI is low complexity (few bugs), gives input only to the partition/VM with focus, labels each window so the source is known, and is the only app with control over the screen (spoofing prevention).</p>
<p>Many defense-oriented OS&#8217;s have some sort of trusted path, such as BAE System&#8217;s STOP OS (excellent design, btw) and Sun&#8217;s Trusted Solaris 8. Their OS&#8217;s are so big, though, that they can&#8217;t be proven secure. The first good trusted path, imho, was the Nitpicker GUI by Dresden. It runs on their medium assurance L4/Fiasco microkernel. They use it in their Nizza architecture to prevent keylogging and spoofing. Google them and NICTA to see many awesome, practical schemes. Green Hill&#8217;s INTEGRITY Workstation also does things this way.</p>
<p>How would this work in practice? I mean, couldn&#8217;t the attacker just hack the main VM and disguise the malicious messages or get the key? No. Dresden gives an example of a digital signature for ecommerce. Most functionality would be in the untrusted vm. You&#8217;d do most of the order and total it. It would then send the critical shopping data to a small, trusted signing app in a separate partition, running right on the microkernel. You use the trusted path to switch to that app, enter your password to decrypt your signing key, visually verify what you are signing, sign it, and then the signature is sent back to the untrusted side. The secure kernel handles transfers, and the MMU isolates all these processes. I have a password manager scheme that works similarly, protecting my master password and only letting passwords out that I choose.</p>
<p>I hope these examples show why seL4 and the other high assurance separation kernels are so important. Using them, one only has to decompose and structure their app right to maintain confidentiality, integrity or availability. In the eSign app, you have strong assurance of confidentiality, esp. if private key is zeroized after use. In password manager, you have reduced risk. If your firewall sits in dedicated partition in between VM and networking stack, then viral infection or hack of VM can&#8217;t disable the firewall. The uses for MILS architecture are many, and what&#8217;s great is that it&#8217;s actually simple enough for most people to understand. I&#8217;ll post or email you links on MILS and usable high assurance products/projects if you request it. Here&#8217;s whats relevant to our current discussion.</p>
<p>TU Dresden OS Research and Demo<br />
<a href="http://demo.tudos.org/eng_features.html" rel="nofollow ugc">http://demo.tudos.org/eng_features.html</a></p>
<p>L4 Family Page (look at Perseus and uSINA)<br />
<a href="http://os.inf.tu-dresden.de/L4/use.html" rel="nofollow ugc">http://os.inf.tu-dresden.de/L4/use.html</a></p>
<p>OKL4 Hypercell (commercial, dual-license)<br />
<a href="http://www.ok-labs.com/releases/release/open-kernel-labs-new-secure-hypercell-technology-advances-development-of-en" rel="nofollow ugc">http://www.ok-labs.com/releases/release/open-kernel-labs-new-secure-hypercell-technology-advances-development-of-en</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121820">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121820">
						October 2, 2009 9:50 PM					</a>

				</p>

				<p>&#8220;Many hardware attacks, so the main idea is to prevent remote access software attacks, right?&#8221;</p>
<p>Well, preventing software attacks is certainly important, but what I had in mind was a smart keyboard that would set up some sort of SSL tunnel to the computer and encrypt all of its output so that hardware loggers would be ineffective. I&#8217;m not sure how cheaply this could be done, but perhaps would special purpose encryption chips it would be feasible for under $50. Of course, that has little to do with verification.</p>
<p>Interesting comment, though.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121821">

			<div class="comment by-gweihir ">

				<p class="commentcredit">

					<span class="commenter">Gweihir</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121821">
						October 2, 2009 10:58 PM					</a>

				</p>

				<p>So what? Interesting in an academic sort of way but without a lot of practical consequences.</p>
<p>The issue is that they proved the code conforms to its specification. There is a second step that is missing: Proving that the specification describes a &#8220;secure&#8221; kernel. This is currently beyond humans and machines would need artificial intelligence that not only works, but is incredible powerful.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121824">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121824">
						October 3, 2009 12:28 AM					</a>

				</p>

				<p>@ pdf23ds</p>
<p>There exists keyboards like you describe. The points of attack become the keyboard circuitry and the software driver that does decryption. Hacking the OS may compromise driver: software exploit defeating hardware security. An alternative scheme would be a dedicated PCI card and keyboard in a Master and Slave situation. Keyboard and card hardcoded w/ private/public key pairs; PCI card sends random session key on boot; decrypts character stream before sending to OS. Most such schemes are vulnerable to power line, tempest, vibration-type and other hardware attacks. As far as keyboard, video and mouse security, I&#8217;d only trust TEMPEST-certified, Type 1 products. And not entirely there.</p>
<p>@ Gweihir</p>
<p>In case you didn&#8217;t actually read the research before commenting, they did prove that the specification describes a secure kernel. They defined &#8220;secure&#8221; as guaranteeing isolation between components running on top of the kernel, with communication only happening through the kernel&#8217;s controlled, well-studied mechanisms. It&#8217;s called MILS architecture. They formulated this in Haskell and Isabelle, then wrote an executable specification in Haskell and Isabelle, connected the two, then wrote C/asm code, and connected the specs to an Isabelle model of the C code. Far from what you suggested, their focus from the beginning was clearly (and formally) defining how the software achieved safety/security goals.</p>
<p>For a better understanding of how this relates to security, look up MILS architecture or the Separation Kernel Protection Profile. Those are the security model. All you have to do is prove a few properties, and then you should be able to write programs that inherit that level of security via careful integration. The best example of a system where &#8220;secure&#8221; was precisely and mathematically defined before proofs was the INTEGRITY-DO178B Separation Kernel, which was awarded Common Criteria rating of EAL6+/High Robustness during the evaluation. This involved checking architecture, formally proving specs met requirements (SAIC Inc. did that), strong semi-formal argument that code consistent with specs, and extensive pen-testing by NSA.</p>
<p>In other words, one can model what security means for a particular piece of software. We don&#8217;t need any magical AI computers or esoteric math. Or a philosophically skeptical view of whether we can ever truly prove anything. We just need a precise and practical definition of security, and that&#8217;s exactly what they (and all other high assurance developers have) used.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121825">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121825">
						October 3, 2009 12:50 AM					</a>

				</p>

				<p>&#8220;Of course to prove that a program halts does not mean to write a program that determines if the program halts.&#8221;</p>
<p>I&#8217;m in pretty deep water here, but I understand that (due to the Curry-Howard isomorphism? constructive type theory?) every formal proof corresponds to a computer program. However, the halting problem says that for any program, some provably halting inputs will not be proved to halt. Does this imply that there are some provably halting programs that can&#8217;t be proved to halt using the Isabelle proof checker, and others using Coq, and HOL, and so on? Duuude.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121826">

			<div class="comment by-idbiip ">

				<p class="commentcredit">

					<span class="commenter">IDBIIP</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121826">
						October 3, 2009 3:23 AM					</a>

				</p>

				<p>I&#8217;m glad they mentioned looking for having integer overflows in there, because I remember this:</p>
<p><a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html" rel="nofollow ugc">http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121827">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121827">
						October 3, 2009 6:55 AM					</a>

				</p>

				<p>@ Nick P,</p>
<p>&#8220;In other words, one can model what security means for a particular piece of software. We don&#8217;t need any magical AI computers or esoteric math. Or a philosophically skeptical view of whether we can ever truly prove anything. We just need a precise and practical definition of security, and that&#8217;s exactly what they (and all other high assurance developers have) used.&#8221;</p>
<p>Sadly no we need more than &#8220;a precise and practical definition of security&#8221;. We need a dynamic frame work (think about, known knowns, known unknowns, unknown knowns and  unknown unknowns).</p>
<p>Due to unfortunatly being away from home at the moment due to health reasons my access to the Internet is a little limited, so I have not had the chance to go through the specification they used or other supporting information.</p>
<p>However I would be surprised if it considered side channels in any great detail, especially susceptance attacks, of which very very little is currently in the public domain (although I have been banging on about it for many years).</p>
<p>The simple fact is that a secure system is &#8220;fighting the last war&#8221; actively and  looking passivly for &#8220;oddities&#8221; that might or might not be a new war or prelude to one&#8230;</p>
<p>What is needed is a secure framework where each &#8220;user module&#8221; within it (both hardware and software) does not need to be designed securely just optimaly.</p>
<p>That is each user module is effectivly jailed by the frame work and the resourses it has access to are strictly controled by the framework under the guidence of a security hyporvisor that is driven from security rules system (which is the tough bit). The framework and hyporvisor are designed so that anomalies are detected and &#8220;limited&#8221; or &#8220;stoped&#8221; untill the security rules system certifies the anomalous behaviour.</p>
<p>Yes this means that the framework is both a hardware and software system.</p>
<p>As part of the framework a &#8220;security/forensic savant&#8221; is required that can freeze and copy the current state of a user module and any communications to/from it, automaticaly without the sandbox becoming aware that it monitoring is in progress (yup a seemingly very difficult problem).</p>
<p>We are starting to see the early stages of such frameworks however the ones I have looked at do not appear to recognise side channels in any meaningfull way.</p>
<p>I would hazzard from what has been said on this blog page that the OS under discussion would be capable of forming one part of a user module, and augmented to provide part of a framework.</p>
<p>As I noted earlier it is not possible to have a 100% secure system but you can certainly via a security ECC system constrain what goes on to limite the potential bandwidth of a side channel etc to an attacker (or ordinary user 😉</p>
<p>The real issue with security currently is &#8220;efficiency&#8221; or &#8220;bang for your buck&#8221;, as long as performance specmanship is the marketing tool of choice systems will probably never be secure&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121828">

			<div class="comment by-section9-bateau ">

				<p class="commentcredit">

					<span class="commenter">Section9-Bateau</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121828">
						October 3, 2009 6:56 AM					</a>

				</p>

				<p>&#8220;for the first time a team had been able to prove with mathematical rigour that an operating-system kernel—the code at the heart of any computer or microprocessor—was 100 per cent bug-free and therefore immune to crashes and failures.&#8221;</p>
<p>This has been done before, probably somewhere between a half dozen and a dozen times.  It is rare, but several projects come to mind off the top of my head (Blacker, GEMSOS, Cainware(as much as I&#8217;ve heard that is bad about it&#8217;s development), and others that their names are not even public.</p>
<p>Of course, most of these are &#8220;in the context of non-malicious, normally operating hardware&#8221; but still, we assume that with everything we deal with on a daily basis.</p>
<p>I&#8217;m sure I&#8217;ll have more comments, but just reading the first bit here was enough I had to get this fact in.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121830">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121830">
						October 3, 2009 1:59 PM					</a>

				</p>

				<p>@ pdf23ds,</p>
<p>&#8220;what I had in mind was a smart keyboard that would set up some sort of SSL tunnel to the computer and encrypt all of its output so that hardware loggers would be ineffective.&#8221;</p>
<p>That would be easy enough to do but actually not that usefull these days.</p>
<p>The problem is &#8220;end runs&#8221; around any security measure you put in place.</p>
<p>All security is about access to an object be it physical or informational.</p>
<p>In essence the access is a form of communication and Shannon had a reasonably good model for a point to point communications path.</p>
<p>However it ignored the problem of the end points, by assuming they where not in the attack model. Unfortunatly they cannot be secured unless they are part of the secure communications path&#8230;</p>
<p>With an IO device like a keyboard at some point a secure path ends and it is at this point it becomes vulnerable to plain text snooping (microphone, camera etc etc).</p>
<p>If you think about it the sound of your fingers pressing the keys is just one of a number of attack points you cannot easily defend against unless you yourself and the keyboard are in a secure environment (TEMPEST Cell/vault etc).</p>
<p>Likewise at the other end of the communications path you have to get the keypress information into the application, and in turn the application will normally give you feedback of which key has been pressed.</p>
<p>An attacker can intercept the &#8220;plain text&#8221; to the application (unless the app takes in keyboard cipher text directly) or from the application to you via the feedback path.</p>
<p>Then there is another problem on the secure comms path which is lack of entropy&#8230;</p>
<p>Unless the keyboard encryption takes into account this issue the result will be a simple substitution cipher on each key pressed&#8230;</p>
<p>Hey ho life is never easy when it comes to security even for the simplest of things 8(</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121832">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121832">
						October 3, 2009 2:26 PM					</a>

				</p>

				<p>@ pdf23ds,</p>
<p>&#8220;Hmm. I&#8217;m wondering how you would go about proving privacy.&#8221;</p>
<p>If you think of it falling on a scale from zero privacy to full privacy the end points are relativly easy to prove in terms of access.</p>
<p>However except for the end points (full / no access) I don&#8217;t think you can.</p>
<p>Partial privacy is about controled disclosure and is an altogether more complex problem.</p>
<p>Not only has it to do with primary access control but also about continuing access control by preventing duplication and disclosure by the entity given primary access to third parties or use for anything other than the autherised use.</p>
<p>In essence it&#8217;s the flip side of DRM&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121833">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121833">
						October 3, 2009 3:09 PM					</a>

				</p>

				<p>&#8220;The problem is &#8220;end runs&#8221; around any security measure you put in place.&#8221;</p>
<p>Right, I didn&#8217;t mean to deny any of that. It doesn&#8217;t necessarily mean that SSL keyboards wouldn&#8217;t be worth it.</p>
<p>&#8220;Then there is another problem on the secure comms path which is lack of entropy&#8230;&#8221;</p>
<p>Would that actually be a problem with an actual SSL tunnel? I thought the encryption used there was pretty good. Of course, there would be a big danger of having some proprietary, &#8220;our programmers couldn&#8217;t crack it&#8221; protocol whose only purpose is to give flimsy cover for marketing claims.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121834">

			<div class="comment by-pdf23ds ">

				<p class="commentcredit">

					<span class="commenter">pdf23ds</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121834">
						October 3, 2009 3:10 PM					</a>

				</p>

				<p>Like that USB key &#8220;security&#8221; Bruce blogged about.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121835">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121835">
						October 3, 2009 10:39 PM					</a>

				</p>

				<p>@ Clive Robinson</p>
<p>No doubt we need an architecture like that, but we have all tried and failed. Probably far off, and market forces will fight all progress unless OEM&#8217;s sign on. I&#8217;m not trying to say the MILS architecture is perfect: it&#8217;s just incredibly useful, easy for developers to understand, and in past few years a ton of RTOS&#8217;s, virtualization schemes and middleware have appeared for it. In other words, until we have that perfect dynamic security scheme, MILS is the best holdover for many problems.</p>
<p>As for side channels, I&#8217;m almost sure they weren&#8217;t covered. The separation kernel is about software, not hardware, security. The SKPP-compliant kernels address covert channels, but they do it by a fixed processor allocation scheme. That&#8217;s unrealistic. In my S.K. designs, I use fixed space partitioning but dynamic time. Covert and side channels still an issue.</p>
<p>@ pdf23ds</p>
<p>Read Clive&#8217;s post again. He basically said what I said, but gave more specifics about threats. Take the camera threat, in particular, very seriously. You beat a $80 keylogger and they just install a $100 color wireless microcamera. I&#8217;ve done it, and I was a rank amateur then. Many physical attacks. Your better off using a transparent keyboard and computer, and physically examining it before use if ur worried. That&#8217;s what I do when the stakes are high. 😉</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121836">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121836">
						October 3, 2009 10:56 PM					</a>

				</p>

				<p>@Section 9-Bateau:</p>
<p>It would appear that this is a repeat, but its not. Systems like GEMSOS aim for A1/EAL7, which is <em>weaker</em>: the requirements and design must correspond formally, but not the design and the code. The proof chain stops before you get to the code, and semi-formal &#8220;arguments&#8221; and testing  are used instead. That&#8217;s actually worse than BSD, which has many eyes and years of experience ironing out the bugs. Additionally, the results for most other A1/EAL5-7 products were never made public: no peer review of code for bugs. This is the first time this level of verification has been performed on a non-trivial operating system, and the source will be released. Next they will verify the assembler.</p>
<p>You are right about the hardware assumption. Fortunately, the separation kernels need minimal hardware. Mainly the CPU, MMU, Northbridge and RAM. The rest can crap out and the OS will still be fine, but useless. It&#8217;s the services layered on top of it, like device drivers and file systems, that will need reliable hardware. The cool thing about MILS is that the TCB for each partition is different: only what&#8217;s necessary (or in kernel mode) is included. So, even with the hardware assumptions, we still have a very high assurance kernel. When coupled with quality hardware and a high availability solution, the hardware assumptions are even more of a safe bet.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121837">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121837">
						October 3, 2009 10:57 PM					</a>

				</p>

				<p>@ Clive Robinson</p>
<p>Btw, sorry to hear about your health. Seems like its been going on for a while now. Best wishes to you for recovery.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121838">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121838">
						October 4, 2009 8:04 AM					</a>

				</p>

				<p>@ Nick P,</p>
<p>&#8220;In other words, until we have that perfect dynamic security scheme, MILS is the best holdover for many problems.&#8221;</p>
<p>I&#8217;ve just remembered we&#8217;ve had this conversation befor when talking about IO security 8)</p>
<p>I like MILS for many reasons, as you say it&#8217;s not perfect but then I doubt that anything ever will be 8(</p>
<p>However one nice feature is it is modular and as such would co-exist quite comfortably into the sort of framework I was discussing.</p>
<p>The downside (apart from side channels) is it does not quite go far enough in seperating applications from security.</p>
<p>My (somewhat quaint) view is that a framework should be such that the unix &#8220;small tools to do big jobs&#8221; &#8220;pipeline&#8221; philosophy would be extended. Such that the tools could be written without security being a consideration.</p>
<p>Application development would be split into the three logical parts of User  interface / application specific logic / extended OS functionality. That is the User interface carries on going the way of web development, application logic the way of &#8220;5th gen scripting of tools&#8221; and the likes of DB engines and other mainline back end services become part of the OS interface.</p>
<p>Oh and the business about Error Checking Corrrection (ECC) systems. It is inefficient (but who cares 😉 but NASA and the like use voting systems for reliability. What few people have voiced (but I hope have thought about) is applying the same philosophy to security.</p>
<p>That is three different teams build the application logic using different scripting languages, when run in parrelel the three systems should agree with each other on what is to be done. If they differ you have a problem in the specification or implementation either of which is a security risk and needs to be resolved.</p>
<p>The important issue is that security is and probably always will be a moving target. Even security practitioners have difficulty keeping up with it, you cannot expect jobbing programers to even remotly get close.</p>
<p>Therfore you have to remove the security asspects away from what they do and let them get on with what they are good at and let the security proffesionals get on with what they are good at.</p>
<p>Splitting things up the way I have suggested in the framework is currently the best way I can think to do it.</p>
<p>However ther is one proviso those &#8220;pesky programmers&#8221; will have to pull their socks up with regards error and exception handeling, which most code cutters are sadly deficient at currently 8(</p>
<p>A modularised development must have a proper exception handeling system to work effectivly. It would provide not just a major improvment in security but fault tolerant systems in general (but that&#8217;s another &#8220;beef&#8221; for another day 😉</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121839">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121839">
						October 4, 2009 8:49 AM					</a>

				</p>

				<p>@ pdf23ds,</p>
<p>&#8220;Would that actually be a problem with an actual SSL tunnel? I thought the encryption used there was pretty good.&#8221;</p>
<p>It is improving but it&#8217;s not perfect (but hey I and most other people had to learn by experiance 😉</p>
<p>One issue of all encryption systems is low entropy and what effectivly becomes code book encryption.</p>
<p>If you have only 96 keys then no matter how many bits in your key or block cipher you end up with 96 substitutions&#8230;</p>
<p>However the simple (and incorect) way to deal with this is either to use a stream cipher or a simple chaining block cipher.</p>
<p>Both of these have problems with synchronisation and authentication and for various reasons have other security faults.</p>
<p>There are ways to do it but&#8230;</p>
<p>Do you remember the problems with WEP&#8230;</p>
<p>There are subtalties that can get the best of us into trouble.</p>
<p>Oh and then there is traffic flow analysis to deal with this adds a whole host of other problems ontop of things.</p>
<p>And these are just some of the &#8220;publicaly known&#8221; problems.</p>
<p>On top of this there are side / covert channel issues.</p>
<p>One of which is hardware manufactures using spread spectrum techneiques to beat EMC masks rather than to reduce what is eminating.<br />
A knowledgable attacker will know the spreading sequence used and just despread to get the original signal back&#8230;</p>
<p>This has all sorts of advantages to the attacker as it enables you to pull out just one device hiding in amongst many&#8230;</p>
<p>Then there are little EmSec tricks like using low level RF carriers to illuminate a target device and get it cross modulated with things that are going on inside the target.</p>
<p>Oh and then there are suceptance attacks which I&#8217;m absolutly sure we will hear a lot more about in the future.</p>
<p>They are a form of &#8220;fault injection&#8221; attack, you inject &#8220;energy&#8221; into the target via some form of carrier (power supply, RF, sound etc). You modulate this carrier with your chosen attack waveform. Surprisingly this form of attack can work it&#8217;s way very deep into the hardware logic, thus geting you past the &#8220;clocking the inputs and outputs&#8221; method of limiting side / covert channels.</p>
<p>If you can find the correct waveform and a method of syncing it up it is theoreticaly (and practicaly) possible to alter the internal logic state in a predictable way so causing software to make incorect branches etc&#8230;</p>
<p>And there are a few other tricks to follow after that I can think of as well 8(</p>
<p>So you can see why some of our more security concious friends like vaults to work in 😉</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121840">

			<div class="comment by-thunderbird ">

				<p class="commentcredit">

					<span class="commenter">Thunderbird</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121840">
						October 4, 2009 1:31 PM					</a>

				</p>

				<p>Clive Robinson: &#8220;However I would be surprised if it considered side channels in any great detail, especially susceptance attacks, of which very very little is currently in the public domain (although I have been banging on about it for many years).&#8221;</p>
<p>Since I don&#8217;t find anything (except this blog) when I search for &#8220;susceptance attack,&#8221; I guess there is very little in the public domain.  What is a &#8220;susceptance attack,&#8221; if you don&#8217;t mind saying?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121841">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121841">
						October 4, 2009 1:41 PM					</a>

				</p>

				<p>@ Clive</p>
<p>Yes, we did have this discussion. And separating interfaces and security-critical code was part of it. Fortunately, MILS was specifically designed for this. The idea is that you certify one module, then modules that depend on it, then modules that depend on it. It&#8217;s like chaining a bunch of black boxes together, which (like you wanted) let&#8217;s developers focus more on their job than security. This contrasts with the [unevaluatable] monolithic approach.</p>
<p>Personally, I don&#8217;t think side channel attacks will be a big issue here. I know I&#8217;ll draw some heat on that, but most of the easy attacks facing average users are software-related: malware; spoofing for phishing; botnets in DDOS. MILS and certified middleware can be (and has been) used to defeat these threats. And if we&#8217;re worried about emanation security, we can do what I suggested before: just stay on the move with an energy-efficient laptop. Pull the batteries out and put the system in a safe when not in use. I&#8217;ve recently been toying with ways to secure the BIOS and bootcode. That issue must be resolved, imho.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121842">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121842">
						October 4, 2009 4:10 PM					</a>

				</p>

				<p>What Clive describes is usually referred to as TEMPEST, side channel attacks or emanation security (EMSEC). On most unofficial web sites, all the information is usually clumped together under one of those names. Clive is just using the proper terminology&#8230; yet another reason to expect he is or was an &#8220;insider.&#8221; We&#8217;re onto you Clive&#8230; 😛</p>
<p>If you want more information on it, you can start with the resources below. From my limited understanding, his susceptance attack means RF waves are injected into the device or wire in a certain way. Then, measurements are made of any resulting RF activity. Attackers analyze the results to see if any information leaked. This effect can be accidental too. Cell phones constantly emanate EM waves that, when mixed with devices, can cause leaks of confidential information. As an example, cell phones (one model/carrier in particular) weren&#8217;t allowed within 10-30 ft. of a STU-III secure telephone because the cellular transmission caused the STU circuitry to leak the secret keys as RF radiation. The manual I read said that if someone with a cellphone, talking or not, walked near a STU-III, then it was considered compromised. Injection attacks are very powerful. Note: I think these attacks are actually under the codeword TEAPOT rather than TEMPEST. Search words like TEAPOT and NONSTOP combined with words like TEMPEST, emanation, etc. Better results.</p>
<p>Sadly, I seem to have lost most of my EMSEC bookmarks a few restores ago. Good news is I remember some of the sites with the most info. Just dig through these as much as you like.</p>
<p>Complete Unofficial TEMPEST page (best starting place)<br />
<a href="http://www.eskimo.com/~joelm/tempest.html" rel="nofollow ugc">http://www.eskimo.com/~joelm/tempest.html</a><br />
Note: Is currently down. Check the Wayback Machine. Archive it yourself if possible. Best non-secret info source.</p>
<p>Books I&#8217;m Looking Into Getting To Improve EMSEC(Clive, what do you think about these?)<br />
&#8211; Architectural Electromagnetic Shielding Handbook by Hemming<br />
&#8211; Design of Shielded Enclosures by Gnecco, Certified TEMPEST Professional</p>
<p>Some Declassified TEMPEST Docs<br />
&#8211; <a href="http://cryptome.org/nt1-92-1-5.htm" rel="nofollow ugc">http://cryptome.org/nt1-92-1-5.htm</a></p>
<p>An example of TEMPEST products<br />
&#8211; <a href="http://www.cryptek.com/products/emanation_security_products/" rel="nofollow ugc">http://www.cryptek.com/products/emanation_security_products/</a></p>
<p>NSA&#8217;s List of Level 1 Certified Products (where I shop 😉<br />
<a href="http://www.nsa.gov/applications/ia/tempest/Level1Certified.cfm" rel="nofollow ugc">http://www.nsa.gov/applications/ia/tempest/Level1Certified.cfm</a><br />
Note: If you use NoScript, you will have to hit &#8220;allow nsa.gov&#8221;. Allow them to run scripts on your machine at your own risk&#8230; hehe</p>
<p>Google Books Injection Probe Example<br />
<a href="http://books.google.com/books?id=MuxJXKuHIpAC&#038;pg=PA461&#038;lpg=PA461&#038;dq=%22injection+probe%22+attack&#038;source=bl&#038;ots=E3BzXTfV_h&#038;sig=W6muyQoEneg1CV7K_TFiQebqe1s&#038;hl=en&#038;ei=1wbJSqyVLKSStgeHkPjtDg&#038;sa=X&#038;oi=book_result&#038;ct=result&#038;resnum=3#v=onepage&#038;q=%22injection%20probe%22%20attack&#038;f=false" rel="nofollow ugc">http://books.google.com/books?id=MuxJXKuHIpAC&#038;pg=PA461&#038;lpg=PA461&#038;dq=%22injection+probe%22+attack&#038;source=bl&#038;ots=E3BzXTfV_h&#038;sig=W6muyQoEneg1CV7K_TFiQebqe1s&#038;hl=en&#038;ei=1wbJSqyVLKSStgeHkPjtDg&#038;sa=X&#038;oi=book_result&#038;ct=result&#038;resnum=3#v=onepage&#038;q=%22injection%20probe%22%20attack&#038;f=false</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121843">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121843">
						October 5, 2009 1:15 AM					</a>

				</p>

				<p>@ Thunderbird, Nick P,</p>
<p>If you have a machine be it purely electronic or electromechanical or even just mechanical and you put it in a nicely controled RF field, it&#8217;s working will cause the field to be modulated by it&#8217;s workings.</p>
<p>This by the way works not just with metal but anything where it&#8217;s dielectric constant is sufficiently different from what surrounds it (so wood and plastic will effect some frequencies)</p>
<p>You are used to the idea of this interferance to an EM field with for instance X-Rays, Offset Radar, and more recently millimetric body scanners. You also get the same effect when you drive down a road under bridges etc and your VHF station flutters.</p>
<p>Oh and of course your eyes we see by reflection and transmission, although our eyes are not designed to see phase modulation and are fairly insensitive to amplitude modulation above a couple of Hz in the center of our visual field.</p>
<p>A clasic visable effect is looking at moonlight off of  lightly disturbed water such as the sea or a lake we see light twinkle as light waves add and subtract by comming into and out of phase by different path lengths.</p>
<p>Now think of those funny looking helix cowles ontop of &#8220;foul air&#8221; pipes where the wind causes them to spin and in the process causes the presure to drop in the pipe. When new they are often quite shiny and when turning slowly we can acuratly tell the speed of rotation either by reflection or transmission of light&#8230;</p>
<p>That is we can get usefull information on this simple mechanical system just by observing what it does to a surounding EM field&#8230;</p>
<p>One of the things we are going to hear more about is the effect wind turbines will have on TV pictures if we all start putting them up on our houses&#8230;</p>
<p>What is less commonly known although it should be obvious from basic physics lessons is that a current in a wire also modulates an EM field around it.</p>
<p>When not being used for EmSec or TEMPEST engineers refer to the effect as cross modulation, and it is generally considered a real pain to deal with for EMC testing.</p>
<p>Also it can be a real pain due to mechanical vibration on such things as coils and physical tuned circuits such as slots and cavities and even antenas.</p>
<p>However when used for EmSec / TEMPEST it has a variety of names (some of which Nick P mentioned).</p>
<p>However although using an EM or other energy source (remember mechanical sources such as sound 😉 directed at the target these are effectivly &#8220;passive&#8221; attacks. That is they do not usually effect the target equipment&#8230;</p>
<p>A suceptance attack however is used to &#8220;inject faults&#8221; into the target equipment.</p>
<p>That is you use your energy source at a high enough level such that it effects the way the equipment works.</p>
<p>This works with any kind of amplifier a classic example is leaving your GSM cell phone on near an audio amplifier that is not properly screened. You hear the &#8220;envolope&#8221; of the digital transmission in the speakers as a sort of rasping noise.</p>
<p>Now you have to apreciate that digital electronics is still analog electronics but with a lot of gain&#8230;</p>
<p>An example of this is with CMOS logic (old 4000 series) where you have an inverter (NOT NAND NOR XOR) and you connect a resistor from the output back to the input. It acts as an analog amplifier.</p>
<p>In the early days this trick was used for all sorts of clever tricks by engineers but it has mainly fallen by the wayside and the only place you commonly see it is with XTAL oscilators.</p>
<p>It even works with some TTL gates (74 series). If you wire up a Schmitt inverter as an XTAL osc running at 30MHz and capacitivly couple an audio signal into the input, this fractionaly changes the bias point of the gate input with the result the 30MHz signal gets sufficiently phase modulated that the third harmonic can be clearly heard on an FM radio. And thus you can use it as a low power FM transmitter or bug (a design for one using exactly this trick was published in an early electronics magazine around 1977)&#8230;</p>
<p>Now imagine what happens with a low power VHF transmitter and a PCB which is not properly screened&#8230;</p>
<p>It was not unknown back in the 70s/80s for microprocessor systems to fail when a security guard etc fired up their two way radio in or around a computer room. Or for VDU&#8217;s (any one else remember them) to have their screens break up or show odd charecters. If you read Clifford Stoll&#8217;s book about tracking down a german cracker he mentions &#8220;line noise&#8221; and simulating it by jangaling keys across the terminals of a break out block. It worked because back then what we now call EMC was a very real and anoying problem holding back the electronics industry.</p>
<p>That is all digital circuits are &#8220;susceptable&#8221; to interferance from energy fields if the proper steps are not taken.</p>
<p>Now imagine if you will an important item of security equipment a True Random Number Generator or TRNG. What would happen if you say subjected it to an EM field?</p>
<p>Well you can now read up on it as a couple of researchers at Cambridge Labs (UK) have recently presented a paper where they show the entropy went from 32bits down to 8bits. With just such a simple attack.</p>
<p>Now imagine if you will that by using a number of different EM frequencies you could target diferent parts of a circuit (you can due to track length issues). And that these EM fields where either pulse or phase modulated with an appropriate pattern?</p>
<p>It would be the same as directly injecting a signal onto an input gate as in the TTL FM bug above.</p>
<p>That is you could inject a &#8220;fault signal&#8221; of your own chosing into various parts of a &#8220;black box&#8221; system you wish to attack.</p>
<p>Now to make it realy usefull further imagine that by listening in to a different EM signal you could get information out that you could use to syncronise your &#8220;fault injection&#8221; waveform.</p>
<p>You potentialy have a way to effect the operation of the device you want to attack to make it do what you want it to do&#8230;</p>
<p>And yes these attacks do work I found ways to effect the Mondex electronic wallet and a hand held gambaling game to what would have been my advantage (if I&#8217;d been dishonest) back in the 1980s.</p>
<p>Now the cat is &#8220;officialy&#8221; out of the bag as far as accademics are concerned with the Cambridge Labs paper I expect there to be a whole bunch of other researchers jumping onto it.</p>
<p>That being said I did tell Ross Anderson many years ago about it when he was trying to find ways around DPA using unsyncronised logic.</p>
<p>If you want to know more have a hunt around for &#8220;injection locking&#8221; for such things as PAL/NTSC colour sub carrier syncronisation, PLL threahold extension, carrier resyncronisation in data coms and various forms of Spread Spectrum systems. Ian Hickman of Wireless World wrote a couple of articals on injection locking and practical experiments.</p>
<p>Also look up &#8220;parametric amplifiers&#8221; to see another exploitable effect.</p>
<p>The important thing to remember is these EM fields used for susceptance attacks do an &#8220;end run&#8221; around most EMC / TEMPEST / EmSec bandwidth limiting filters&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121844">

			<div class="comment by-pragmatist ">

				<p class="commentcredit">

					<span class="commenter">Pragmatist</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121844">
						October 5, 2009 8:40 AM					</a>

				</p>

				<p>Now all they need to do is get a computer chip that is proven to work correctly to run it on.</p>
<p>Oh wait, they don&#8217;t have those?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121845">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121845">
						October 5, 2009 9:16 AM					</a>

				</p>

				<p>I&#8217;ve been reminded by some one to include a link to the Cambridge Labs bods paper etc.</p>
<p>So if your interested follow this link,</p>
<p><a href="http://www.lightbluetouchpaper.org/2009/09/08/tuning-in-to-random-numbers/" rel="nofollow ugc">http://www.lightbluetouchpaper.org/2009/09/08/tuning-in-to-random-numbers/</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121846">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121846">
						October 7, 2009 6:31 PM					</a>

				</p>

				<p>@ Pragmatist</p>
<p>Actually, they do. I mentioned a few in my post. You can build your own out of simpler chips (see Magic1), which are easier for COTS vendors to get right. In addition, there are a few partially or fully verified designs: VIPER, VAMP, AAMP5, AAMP7G. You could also take an open core/spec, like OpenRISC or SPARC T1/T2, and reimplement it using a high assurance methodology with extreme testing.</p>
<p>In other words, nearly bug free processors are very possible. The market just doesn&#8217;t seem to want them. Only safety-critical or security-critical markets even consider it, and most of them are satisfied with a ARM chip from a good manufacturer. Unless you want to get one of the aforementioned designs, and run it on a high quality ASIC or FPGA, you will have to settle for a typical processor. 🙁</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121847">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121847">
						October 7, 2009 6:37 PM					</a>

				</p>

				<p>@ Clive Robinson</p>
<p>I appreciate your reply. Since I do software red/black vpn/firewall designs, that Cambrige research was particularly interesting. I was checking out cambrige just a week ago. I don&#8217;t know how I missed it. Thanks for the tip. 😉</p>
<p>Information about EMSEC is particularly hard to come by. One must solidly grasp many technical concepts related to EMF to put all the pieces together that are public. Those that don&#8217;t have access to more readable information that isn&#8217;t public. You never cease to amaze me with your knowledge on the subject. It leads me to believe that you are or were&#8230; well, you know where this is going. 😉 Funny thing is I actually keep a copy of each post you make on it for future reference.</p>
<p>I&#8217;m mainly a software &amp; systems guy, but I&#8217;ve recently been trying to branch out into secure hardware. Do you know any good publicly-available books on the subject? Something a somewhat technical, but not EE major, could understand and use to add at least a little EMSEC to their designs. If you&#8217;ve seen any you liked that are on Amazon or whatnot, I&#8217;d love to read up on it more.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121848">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121848">
						October 8, 2009 12:21 AM					</a>

				</p>

				<p>@ Nick P,</p>
<p>&#8220;Information about EMSEC is particularly hard to come by&#8221;</p>
<p>It is and it isn&#8217;t as you note a lot of the information is out there just not in an EmSec format.</p>
<p>However that may well change soon thanks to Russia effectively mandating TEMPEST type requirments on general use systems (not sure which will be quicker learning Russian or awaiting english translations 😉</p>
<p>EmSec / TEMPEST is an engineering subject where practical methods are driven by complexity. Not just of theoretical ideas but also due to interactions of all the components involved.</p>
<p>Thus it tends to be &#8220;rules driven&#8221; for design and likewise for certification, and the rules generaly suffer from &#8220;over kill&#8221; for good reason (ie a large amount of safety margin).</p>
<p>Actual testing can look like &#8220;witch craft&#8221; but in essence is quite simple.</p>
<p>Basicaly you have a &#8220;black box&#8221; system that has a number of ports through which energy can be transported.</p>
<p>The trick is to identify all th ports and all the energy.</p>
<p>The important thing to remember is that with energy &#8220;what goes in must come out&#8221;, but in maybe a different form&#8230;</p>
<p>For instance a simple device such as a loud speaker you have electrical energy in and sound, E fields, H fields, heat, etc coming out (emission).</p>
<p>But&#8230; the loud speaker like any transducer is a two way device sound energy in will produce electrical energy out (suceptance).</p>
<p>Unfortunatly all methods of transporting energy are &#8220;inefficient&#8221; and the &#8220;transmission loss&#8221; indirectly tells you they are transducers in their own right&#8230;</p>
<p>The trick with EmSec is ensuring that the energy coming out is in a form where it is not carrying &#8220;information&#8221; that would be of use to others.</p>
<p>Ultimately all energy ends up as back ground heat in a closed system due to entropy (moving from an organised to a disorganised state).</p>
<p>Without going into details the back ground heat is also &#8220;noise&#8221;, all physical items act as transducers and convert heat into an equivalent &#8220;thermal noise&#8221; (and vice versa). Thus at any given temprature there is a certain degree of background &#8220;thermal noise&#8221;.</p>
<p>Now &#8220;information&#8221; implies a &#8220;signal&#8221; and signals have certain charecteristics. One of which is bandwidth another is energy, and importantly a transmission medium to carry it.</p>
<p>If you limit any one of the three sufficiently then the &#8220;information&#8221; is not going anywhere but the energy has to&#8230;</p>
<p>The first idea of TEMPEST was to reduce the energy of the information signal below the back ground thermal noise (also called the noise floor).</p>
<p>Thermal noise is however a signal in it&#8217;s own right and therefor has bandwidth considerations, thus the wider the bandwidth the more thermal noise energy there is (as it is actually many independent signals the average goes up as the RMS of them all).</p>
<p>Thus at any given bandwidth you would expect an &#8220;average&#8221; thermal noise level. Which is where the -174dBm (in a 1 Hz bandwidth) you sometimes see quoted comes from.</p>
<p>The usuall way of limiting bandwidth is with filters.</p>
<p>However most engineers do not think of what a filter actually does.</p>
<p>By limiting the bandwidth the excess energy has to go somewhere and as most filters are made only of &#8220;reactive components&#8221; the net result is it gets reflected back towards the source.</p>
<p>One of the problems with this reflected energy is that it can without proper precautions end up on the &#8220;common ground&#8221; of the equipment.</p>
<p>The important weasle word is &#8220;common&#8221; which means that the energy can get back into any part of the black box contents via this common path&#8230;</p>
<p>Therefor it is better to use other types of filter that contain non reactive components that &#8220;disipate&#8221; the reflected energy as &#8220;heat&#8221;. Such filters also need to be designed to limit the ingress of energy and preferably divert it away to a suitable disapating component.</p>
<p>However all physical components have dimensions which has a side effect of making them reactive components which will radiate or pick up energy.</p>
<p>Thus components can &#8220;cross couple&#8221; energy to each other and bypass filtering components or get from one independent / isolated circuit to another.</p>
<p>To prevent this physical partitions are placed between components that have desirable charecteristics to reduce the type of energy being coupled from component to component.</p>
<p>Often designers will concentrate on one cross coupling effect and forget (or not know) about others.</p>
<p>Thus &#8220;rules of thumb&#8221; develop one of which is about cable seperation of 1meter between &#8220;red and green&#8221; or &#8220;red and black&#8221; cables (or plaintext circuits and cipher text circuits).</p>
<p>Obviously these &#8220;rules of thumb&#8221; have significant effects on the resources required to make equipment.</p>
<p>However two general rules apply at all times,</p>
<p>1, Reduce the energy.<br />
2, Reduce the bandwidth.</p>
<p>A lot of this aspect of EmSec can be found in practical guides to Electromagnetic Compatability (EMC).</p>
<p>However be warned that some &#8220;low resource&#8221; EMC solutions make EmSec problems considerably worse.</p>
<p>One such trick is to realise that the EMC limit masks are &#8220;wide band&#8221; and that most EMC &#8220;problem signals&#8221; are have a &#8220;narrow bandwidth&#8221; so spread spectrum techneiques are used to widen the signals bandwidth and thus lower it&#8217;s level to get below the mask.</p>
<p>This techneique although effective to get below an EMC mask is not resolving the EmSec issue of &#8220;radiated energy&#8221;. It is still being radiated and thus a &#8220;deconvolving receiver&#8221; can remove the effects of the spreading and get the original signal back.</p>
<p>But worse the process is syncronus to the EmSec target, which means that it helps reduce other non corelated signals. Thus lifting the target out of artificialy generated noise by other similar equipment.</p>
<p>Thus making,</p>
<p>&#8220;a single tree deep within clearly visable outside the forest, as though standing on a grassy knowl&#8221;.</p>
<p>There is a lot lot more to EmSec but knowing the fundementals in a practical view point will take you a lot further than the &#8220;rules of thumb&#8221; will.</p>
<p>Another good source of information is the ARRL and RSGB guides to equipment design / construction and antennas for amature radio enthusiasts.</p>
<p>However that as the say is but the first steps along the pathway.</p>
<p>Early TEMPEST did not consider &#8220;side channels&#8221; such as time based attacks.</p>
<p>There is a story about a tape based OTP system that unfortunatly had hold and release timing problems in the relays doing the XOR function. Thus it was possible to see which bits had been flipped and those that had not and thus get the plain text back&#8230;</p>
<p>This apparently gave rise to the notion of using additional relays to &#8220;re-clock&#8221; the output.</p>
<p>The more modern computer idea (for different reasons) is &#8220;pipelining&#8221;.</p>
<p>Thus another rule,</p>
<p>3, Clock your inputs and outputs.</p>
<p>Which limits the effects of timing jitter.</p>
<p>As you get to see more of these rules you start to get the feeling that you have two things working against you,</p>
<p>1, Complexity.<br />
2, Efficiency.</p>
<p>Both of these give rise to the majority of side channels that you will see in comercial equipment.</p>
<p>And the key to both is managment by effective design methodology. Which usually boils down to modularity where each module does one and only one job, and is effectivly segregated from the others via an effective framework.</p>
<p>As some say EmSec &#8220;ain&#8217;t rocket science&#8221; whilst forgeting to add the rider of &#8220;because that&#8217;s to easy&#8221; in comparison&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121849">

			<div class="comment by-joerg ">

				<p class="commentcredit">

					<span class="commenter">Joerg</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121849">
						October 15, 2009 9:31 AM					</a>

				</p>

				<p>Just another way of saying that any software free of bugs is also outdated 🙂 &#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121850">

			<div class="comment by-scp ">

				<p class="commentcredit">

					<span class="commenter">SCP</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121850">
						October 15, 2009 2:29 PM					</a>

				</p>

				<p>For those generally interested in Program Proof you may wish to track down details of the Tokeneer project.  This was formally specified (Z I believe), written in SPARK Ada, and proven (at the Ada level) to be compliant with its specification and free of specific classes of errors.  There should be links to it from <a href="http://www.sparkada.com" rel="nofollow ugc">http://www.sparkada.com</a>.</p>
<p>There also seems to be an awful lot of misdirection on proving program termination.  Those interested in high assurance programs typically avoid constructs that are difficult/impossible to analyze.  For a usefully large set of programs it is possible to analyze them to assure they complete as required  Have a look at <a href="http://www.absint.com" rel="nofollow ugc">http://www.absint.com</a>.</p>
<p>There are still issues around, but the use of &#8216;formal methods&#8217; and &#8216;program proof&#8217; is providing a useful and practical means of engineering high-assurance software.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-121851">

			<div class="comment by-d ">

				<p class="commentcredit">

					<span class="commenter">D</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121851">
						October 24, 2009 11:53 AM					</a>

				</p>

				<p>haha &#8220;assuming no increased complexity from the increased complexity&#8230;&#8221; that gave me a great smile and chuckle with my morning cup of joe, thanks for the post!!</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-121852">

			<div class="comment by-mohsin ">

				<p class="commentcredit">

					<span class="commenter">MOHSIN</span> •

					<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/#comment-121852">
						August 30, 2010 12:11 PM					</a>

				</p>

				<p>Prove that the program segment</p>
<p>y:=1<br />
z:=x+y<br />
is correct with respect to the initial assertion x=0 and the final assertion  z=1</p>
<p>THIS IS MY QUESTION,PLEASE SOLVE IT AND REPLY IMMEDIATELY</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

	<p class="subscribe-comments">
		<a href="https://www.schneier.com/blog/archives/2009/10/proving_a_compu.html/feed/">
			<img alt="Atom Feed" src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/rss.png">
			Subscribe to comments on this entry		</a>
	</p>

		<div id="respond" class="comment-respond">
		<h2 class="comments-open-header">Leave a comment <small><a rel="nofollow" id="cancel-comment-reply-link" href="/blog/archives/2009/10/proving_a_compu.html#respond" style="display:none;">Cancel reply</a></small></h2><form action="https://www.schneier.com/wp-comments-post.php" method="post" id="commentform" class="comment-form" novalidate><a href="https://www.schneier.com/wp-login.php?redirect_to=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2009%2F10%2Fproving_a_compu.html" title="Login">Login</a><p class="comment-form-author"><label for="author">Name</label> <input id="author" name="author" type="text" value="" size="30" maxlength="245" /></p>
<p class="comment-form-email"><label for="email">Email</label> <input id="email" name="email" type="email" value="" size="30" maxlength="100" /></p>
<p class="comment-form-url"><label for="url">URL:</label> <input id="url" name="url" type="url" value="" size="30" maxlength="200" /></p>
<p class="comment-form-cookies-consent"><input id="wp-comment-cookies-consent" name="wp-comment-cookies-consent" type="checkbox" value="yes" /> <label for="wp-comment-cookies-consent">Remember personal info?</label></p>

<p class="comment-form-author">

	<label for="comm_capt_challenge">
		Fill in the blank: the name of this blog is Schneier on ___________ (required):	</label>

	<input id="comm_capt_challenge" name="comm_capt_challenge" size="30" type="text" />
</p>

<div class="comment-form-comment">

	<label for="comment">Comments:</label>

	<textarea id="comment" name="comment" cols="45" rows="8" maxlength="65525" required="required"></textarea>

	<div id="preview-box" class="preview-box hide"></div>
	<img class="comment-loading hide" src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/loader.gif" />

</div>

<p id="allowed">

	<strong>Allowed HTML</strong>
	&lt;a href=&quot;URL&quot;&gt; &bull; &lt;em&gt; &lt;cite&gt; &lt;i&gt; &bull; &lt;strong&gt; &lt;b&gt; &bull; &lt;sub&gt; &lt;sup&gt; &bull; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &bull; &lt;blockquote&gt; &lt;pre&gt;
	<strong>Markdown Extra</strong> syntax via <a href="https://michelf.ca/projects/php-markdown/extra/">https://michelf.ca/projects/php-markdown/extra/</a>
</p>

<input type="hidden" id="wp_comment_nonce" name="wp_comment_nonce" value="4b1534b792" /><input type="hidden" name="_wp_http_referer" value="/blog/archives/2009/10/proving_a_compu.html" />
<input type="button" id="comment-preview" class="comment-preview comment-actions" value="Preview" />
<input type="button" id="comment-write" class="comment-write comment-actions hide" value="Edit" />

<p class="form-submit"><input name="submit" type="submit" id="submit" class="submit" value="Submit" /> <input type='hidden' name='comment_post_ID' value='3051' id='comment_post_ID' />
<input type='hidden' name='comment_parent' id='comment_parent' value='0' />
</p></form>	</div><!-- #respond -->
	
	<div class="stepthrough">
		<a href="https://www.schneier.com/blog/archives/2009/10/reproducing_key.html" rel="prev">← Reproducing Keys from Photographs</a>		<a href="https://www.schneier.com/blog/archives/2009/10/security_theate_3.html" rel="next">"Security Theater in New York City" →</a>	</div>

	
<p id="powered">Sidebar photo of Bruce Schneier by Joe MacInnis.</p>
		</div>

		
<aside>
	<div class="sidebar" id="sidebar-two">
		<section><div class="sidesection widget widget_schneier_about" id="schneier_about-2"><h3>About Bruce Schneier</h3><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/Bruce-Schneier.jpg" /><p><p class="small">I am a <a href="https://public-interest-tech.com/">public-interest technologist</a>, working at the intersection of security, technology, and people. I've been writing about security issues on my <a href="/">blog</a> since 2004, and in my monthly <a href="/crypto-gram/">newsletter</a> since 1998. I'm a fellow and lecturer at Harvard's <a href="https://www.hks.harvard.edu/faculty/bruce-schneier">Kennedy School</a>, a board member of <a href="https://www.eff.org/">EFF</a>, and the Chief of Security Architecture at <a href="https://inrupt.com/">Inrupt, Inc.</a> This personal website expresses the opinions of none of those organizations.</p>
</p></div></section><section><div class="sidesection widget widget_schneier_related_posts" id="schneier_related_posts-2"><h3>Related Entries</h3>
<ul>

	<li><a href="https://www.schneier.com/blog/archives/2021/03/illegal-content-and-the-blockchain.html">Illegal Content and the Blockchain</a></li><li><a href="https://www.schneier.com/blog/archives/2021/03/national-security-risks-of-late-stage-capitalism.html">National Security Risks of Late-Stage Capitalism</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/weis-2021-call-for-papers.html">WEIS 2021 Call for Papers</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/ransomware-profitability.html">Ransomware Profitability</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/presidential-cybersecurity-and-pelotons.html">Presidential Cybersecurity and Pelotons</a></li><li><a href="https://www.schneier.com/blog/archives/2021/01/police-have-disrupted-the-emotet-botnet.html">Police Have Disrupted the Emotet Botnet</a></li>
</ul>
</div></section><section><div class="sidesection widget widget_schneier_featured_essays" id="schneier_featured_essays-2"><h3>Featured Essays</h3>
	<ul>
		<li><a href="https://www.schneier.com/essays/archives/2016/04/the_value_of_encrypt.html">The Value of Encryption</a></li><li><a href="https://www.schneier.com/essays/archives/2016/03/data_is_a_toxic_asse.html">Data Is a Toxic Asset, So Why Not Throw It Out?</a></li><li><a href="https://www.schneier.com/essays/archives/2014/01/how_the_nsa_threaten.html">How the NSA Threatens National Security</a></li><li><a href="https://www.schneier.com/essays/archives/2009/01/terrorists_may_use_g.html">Terrorists May Use Google Earth, But Fear Is No Reason to Ban It</a></li><li><a href="https://www.schneier.com/essays/archives/2007/01/in_praise_of_securit.html">In Praise of Security Theater</a></li><li><a href="https://www.schneier.com/essays/archives/2006/08/refuse_to_be_terrori.html">Refuse to be Terrorized</a></li><li><a href="https://www.schneier.com/essays/archives/2006/05/the_eternal_value_of.html">The Eternal Value of Privacy</a></li><li><a href="https://www.schneier.com/essays/archives/2005/09/terrorists_dont_do_m.html">Terrorists Don&#039;t Do Movie Plots</a></li>	</ul>

	<p><a href="https://www.schneier.com/essays/">More Essays</a></p></div></section><section><div class="sidesection widget widget_schneier_archives" id="schneier_archives-2"><h3>Blog Archives</h3>
<ul>

	<li><a href="https://www.schneier.com/blog/calendar.html/">Archive by Month</a></li><li><a href="https://www.schneier.com/blog/newcomments.html/">100 Latest Comments</a></li></ul>

<h4>Blog Tags</h4><ul class="top-tags"><li><a href="https://www.schneier.com/tag/3d-printers/">3d printers</a></li><li><a href="https://www.schneier.com/tag/9-11/">9/11</a></li><li><a href="https://www.schneier.com/tag/aaron-swartz/">Aaron Swartz</a></li><li><a href="https://www.schneier.com/tag/academic/">academic</a></li><li><a href="https://www.schneier.com/tag/academic-papers/">academic papers</a></li><li><a href="https://www.schneier.com/tag/accountability/">accountability</a></li><li><a href="https://www.schneier.com/tag/aclu/">ACLU</a></li><li><a href="https://www.schneier.com/tag/activism/">activism</a></li><li><a href="https://www.schneier.com/tag/adobe/">Adobe</a></li><li><a href="https://www.schneier.com/tag/advanced-persistent-threats/">advanced persistent threats</a></li><li><a href="https://www.schneier.com/tag/adware/">adware</a></li><li><a href="https://www.schneier.com/tag/aes/">AES</a></li><li><a href="https://www.schneier.com/tag/afghanistan/">Afghanistan</a></li><li><a href="https://www.schneier.com/tag/air-marshals/">air marshals</a></li><li><a href="https://www.schneier.com/tag/air-travel/">air travel</a></li><li><a href="https://www.schneier.com/tag/airgaps/">airgaps</a></li><li><a href="https://www.schneier.com/tag/al-qaeda/">al Qaeda</a></li><li><a href="https://www.schneier.com/tag/alarms/">alarms</a></li><li><a href="https://www.schneier.com/tag/algorithms/">algorithms</a></li><li><a href="https://www.schneier.com/tag/alibis/">alibis</a></li><li><a href="https://www.schneier.com/tag/amazon/">Amazon</a></li><li><a href="https://www.schneier.com/tag/android/">Android</a></li><li><a href="https://www.schneier.com/tag/anonymity/">anonymity</a></li><li><a href="https://www.schneier.com/tag/anonymous/">Anonymous</a></li><li><a href="https://www.schneier.com/tag/antivirus/">antivirus</a></li><li><a href="https://www.schneier.com/tag/apache/">Apache</a></li><li><a href="https://www.schneier.com/tag/apple/">Apple</a></li><li><a href="https://www.schneier.com/tag/applied-cryptography/">Applied Cryptography</a></li><li><a href="https://www.schneier.com/tag/artificial-intelligence/">artificial intelligence</a></li><li><a href="https://www.schneier.com/tag/assassinations/">assassinations</a></li></ul><p><a href="https://www.schneier.com/blog/tags.html/">More Tags</a></p></div></section><section><div class="sidesection widget widget_schneier_latest_book" id="schneier_latest_book-3"><h3>Latest Book</h3><a href="https://www.schneier.com/books/click-here/"><img class="sidepic" alt="Click Here to Kill Everybody" src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2018/07/book-ch2-200w.png" /></a><p><a href="https://www.schneier.com/books/">More Books</a></p></div></section><section><div class="sidesection widget widget_schneier_promotion" id="schneier_promotion-2">
<a href="https://www.eff.org/issues/bloggers/legal/join">
	<img src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/join-eff@2x.png" id="effbutton" alt="Support Bloggers' Rights!" title="Support Bloggers' Rights!" /></a>

<a href="https://npo.networkforgood.org/Donate/Donate.aspx?npoSubscriptionId=8252">
	<img src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/support-epic@2x.png" alt="Defend Privacy--Support Epic" title="Defend Privacy--Support Epic" /></a>
</div></section>	</div>
</aside>

		<footer>
			<nav>
				<div class="nav" id="footer-nav">
					<div class="menu-main-menu-container"><ul id="menu-main-menu-1" class="menu"><li class="menu1 menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-50175 current-menu-item"><a href="https://www.schneier.com">Blog</a></li>
<li class="menu2 menu-item menu-item-type-post_type menu-item-object-page menu-item-50916"><a href="https://www.schneier.com/crypto-gram/">Newsletter</a></li>
<li class="menu3 menu-item menu-item-type-post_type menu-item-object-page menu-item-50166"><a href="https://www.schneier.com/books/">Books</a></li>
<li class="menu4 menu-item menu-item-type-custom menu-item-object-custom menu-item-50169"><a href="https://www.schneier.com/essays/">Essays</a></li>
<li class="menu5 menu-item menu-item-type-custom menu-item-object-custom menu-item-50170"><a href="https://www.schneier.com/news/">News</a></li>
<li class="menu6 menu-item menu-item-type-custom menu-item-object-custom menu-item-50171"><a href="https://www.schneier.com/talks/">Talks</a></li>
<li class="menu7 menu-item menu-item-type-post_type menu-item-object-page menu-item-50167"><a href="https://www.schneier.com/academic/">Academic</a></li>
<li class="menu8 menu-item menu-item-type-post_type menu-item-object-page menu-item-50174"><a href="https://www.schneier.com/blog/about/">About Me</a></li>
</ul></div>				</div>
			</nav>
		</footer>

		</div><!--#main-->
	</div><!--#wrapper-->

		<script type="text/javascript">
		(function () {
			var c = document.body.className;
			c = c.replace(/woocommerce-no-js/, 'woocommerce-js');
			document.body.className = c;
		})();
	</script>
	<script type='text/javascript' src='https://c0.wp.com/p/woocommerce/5.1.0/assets/js/jquery-cookie/jquery.cookie.min.js' id='jquery-cookie-js'></script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/vendor/socialshareprivacy/js/socialshareprivacy.js?ver=1.0.1' id='social-share-privacy-js'></script>
<script type='text/javascript' id='social-share-privacy-icons-js-extra'>
/* <![CDATA[ */
var schneierSocial = {"path":"https:\/\/www.schneier.com\/wp-content\/themes\/schneier\/assets\/vendor\/socialshareprivacy\/"};
/* ]]> */
</script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/vendor/socialshareprivacy/js/icons.js?ver=1.0.0' id='social-share-privacy-icons-js'></script>
<script type='text/javascript' id='schneier-comment-js-extra'>
/* <![CDATA[ */
var schneierComment = {"translateErrorSecurityAnswerWrong":"Your response to the challenge question ('The name of this blog is Schneier on ____') was not correct. Please try again.","ajax_url":"https:\/\/www.schneier.com\/wp-admin\/admin-ajax.php"};
/* ]]> */
</script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/js/comment.js?ver=1.0.1' id='schneier-comment-js'></script>
<script type='text/javascript' src='https://c0.wp.com/c/5.7/wp-includes/js/wp-embed.min.js' id='wp-embed-js'></script>

</body>

</html>
