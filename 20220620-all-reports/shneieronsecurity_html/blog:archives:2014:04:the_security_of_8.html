<!DOCTYPE html>
<html lang="en-US">

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<title>The Security of Various Programming Languages - Schneier on Security</title>
	<meta name='robots' content='max-image-preview:large' />
<link rel='dns-prefetch' href='//s.w.org' />
<link rel='dns-prefetch' href='//c0.wp.com' />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Feed" href="https://www.schneier.com/feed/" />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; Comments Feed" href="https://www.schneier.com/comments/feed/" />
<link rel="alternate" type="application/rss+xml" title="Schneier on Security &raquo; The Security of Various Programming Languages Comments Feed" href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/feed/" />
<link rel='stylesheet' id='wp-block-library-css'  href='https://c0.wp.com/c/5.7/wp-includes/css/dist/block-library/style.min.css' type='text/css' media='all' />
<style id='wp-block-library-inline-css' type='text/css'>
.has-text-align-justify{text-align:justify;}
</style>
<style id='woocommerce-inline-inline-css' type='text/css'>
.woocommerce form .form-row .required { visibility: visible; }
</style>
<link rel='stylesheet' id='schneier-css'  href='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/style.css?ver=1.0.0' type='text/css' media='all' />
<link rel='stylesheet' id='schneier-main-css'  href='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/dist/css/style.css?ver=1.0.2' type='text/css' media='all' />
<link rel='stylesheet' id='jetpack_css-css'  href='https://c0.wp.com/p/jetpack/9.5.2/css/jetpack.css' type='text/css' media='all' />
<script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js?ver=3.5.1' id='jquery-js'></script>
<link rel="https://api.w.org/" href="https://www.schneier.com/wp-json/" /><link rel="alternate" type="application/json" href="https://www.schneier.com/wp-json/wp/v2/posts/5316" /><link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://www.schneier.com/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://www.schneier.com/wp-includes/wlwmanifest.xml" /> 

<link rel="canonical" href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html" />
<link rel='shortlink' href='https://www.schneier.com/?p=5316' />
<link rel="alternate" type="application/json+oembed" href="https://www.schneier.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2014%2F04%2Fthe_security_of_8.html" />
<link rel="alternate" type="text/xml+oembed" href="https://www.schneier.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2014%2F04%2Fthe_security_of_8.html&#038;format=xml" />
	<noscript><style>.woocommerce-product-gallery{ opacity: 1 !important; }</style></noscript>
	<link rel="icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-32x32.png" sizes="32x32" />
<link rel="icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon" href="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-180x180.png" />
<meta name="msapplication-TileImage" content="https://149400697.v2.pressablecdn.com/wp-content/uploads/2020/06/cropped-favicon-1-270x270.png" />
		<style type="text/css" id="wp-custom-css">
			#schneier_promotion-2 img {
    max-width: 180px;
}		</style>
		</head>

<body class="post-template-default single single-post postid-5316 single-format-standard theme-schneier woocommerce-no-js">

	<div id="wrapper">
		<div id="main">

			<header>
				<div id="header">
					<h1>
						<a href="https://www.schneier.com/" rel="home">
							Schneier on Security						</a>
					</h1>
				</div>
			</header>

			<nav>
				<div class="nav" id="header-nav">
					<div class="menu-main-menu-container"><ul id="menu-main-menu" class="menu"><li id="menu-item-50175" class="menu1 menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-50175 current-menu-item"><a href="https://www.schneier.com">Blog</a></li>
<li id="menu-item-50916" class="menu2 menu-item menu-item-type-post_type menu-item-object-page menu-item-50916"><a href="https://www.schneier.com/crypto-gram/">Newsletter</a></li>
<li id="menu-item-50166" class="menu3 menu-item menu-item-type-post_type menu-item-object-page menu-item-50166"><a href="https://www.schneier.com/books/">Books</a></li>
<li id="menu-item-50169" class="menu4 menu-item menu-item-type-custom menu-item-object-custom menu-item-50169"><a href="https://www.schneier.com/essays/">Essays</a></li>
<li id="menu-item-50170" class="menu5 menu-item menu-item-type-custom menu-item-object-custom menu-item-50170"><a href="https://www.schneier.com/news/">News</a></li>
<li id="menu-item-50171" class="menu6 menu-item menu-item-type-custom menu-item-object-custom menu-item-50171"><a href="https://www.schneier.com/talks/">Talks</a></li>
<li id="menu-item-50167" class="menu7 menu-item menu-item-type-post_type menu-item-object-page menu-item-50167"><a href="https://www.schneier.com/academic/">Academic</a></li>
<li id="menu-item-50174" class="menu8 menu-item menu-item-type-post_type menu-item-object-page menu-item-50174"><a href="https://www.schneier.com/blog/about/">About Me</a></li>
</ul></div>				</div>
			</nav>

			
<aside>
	<div class="sidebar" id="sidebar-one">
		<section><div class="sidesection widget widget_schneier_search" id="schneier_search-3"><h3>Search</h3>
<p class="small">
	<em>Powered by <a href="https://duckduckgo.com/">DuckDuckGo</a></em></p>

<form method="get" action="https://duckduckgo.com/">

	<input type="hidden" name="kh" value="1" /><!-- use https -->

	<input id="search" name="q" size="15" maxlength="255" />

	<input type="submit" value="Go" /><br>

	<input type="radio" name="sites" id="searchblog" value="www.schneier.com/blog" />
	<label for="searchblog">Blog</label>

	<input type="radio" name="sites" id="searchessays" value="www.schneier.com/essays" />
	<label for="searchessays">Essays</label>

	<input type="radio" name="sites" id="searchall" value="www.schneier.com" checked="" />
	<label for="searchall">Whole site</label>

</form>
</div></section><section><div class="sidesection widget widget_schneier_social" id="schneier_social-2"><h3>Subscribe</h3>
<div id="subscription-buttons">

	<a href="https://www.schneier.com/feed/atom"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/rss-32px.png" alt="Atom Feed" /></a><a href="https://www.facebook.com/bruce.schneier"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/facebook-32px.png" alt="Facebook" /></a><a href="https://twitter.com/schneierblog/"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/twitter-32px.png" alt="Twitter" /></a><a href="https://www.amazon.com/Schneier-on-Security/dp/B0053HDDWW/"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/kindle-32px.png" alt="Kindle" /></a><a href="https://www.schneier.com/crypto-gram"><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/email-32px.png" alt="E-Mail Newsletter (Crypto-Gram)" /></a>
</div>
</div></section>	</div>
</aside>

			<div id="content">

				
		<p id="breadcrumbs">

			<a href="https://www.schneier.com">Home</a><a href="https://www.schneier.com/blog/archives/">Blog</a>		</p>

		
<article id="post-5316" class="post-5316 post type-post status-publish format-standard hentry category-uncategorized tag-academic-papers tag-programming tag-security-engineering">

	<div class="article">

		<h2 class="entry">The Security of Various Programming Languages</h2>
		<p>Interesting <a href="http://www.net-security.org/secworld.php?id=16694">research</a> on the security of code written in different programming languages.  We don&#8217;t know whether the security is a result of inherent properties of the language, or the relative skill of the typical programmers of that language.</p>
<p>The <a href="https://info.whitehatsec.com/Social-Statsreport2014.html">report</a>.</p>
<p>EDITED TO ADD (5/14): Direct link to <a href="http://info.whitehatsec.com/rs/whitehatsecurity/images/statsreport2014-20140410.pdf">The report</a>.</p>

		
			<p class="entry-tags">
				<span class="tags-links">Tags: <a href="https://www.schneier.com/tag/academic-papers/" rel="tag">academic papers</a>, <a href="https://www.schneier.com/tag/programming/" rel="tag">programming</a>, <a href="https://www.schneier.com/tag/security-engineering/" rel="tag">security engineering</a></span>			</p>

		
		
		<p class="posted">
			<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html" rel="bookmark">Posted on April 23, 2014 at 7:53 AM</a>			•
			<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html#comments">82 Comments</a>		</p>

		<aside><div class="schneier-share share" data-uri="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html" data-title="The Security of Various Programming Languages" data-order="facebook twitter tumblr" data-social-share-privacy="true" /></aside>
	</div>

</article>


	<h3 id="comments">Comments</h3>

	
		<article class="comment even thread-even depth-1" id="comment-220657">

			<div class="comment by-user090 ">

				<p class="commentcredit">

					<span class="commenter">user090</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220657">
						April 23, 2014 8:09 AM					</a>

				</p>

				<p>Their choice of languages is bases on popularity, but C isn&#8217;t included in comparison.</p>
<p><a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html" rel="nofollow ugc">http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220658">

			<div class="comment by-thierry ">

				<p class="commentcredit">

					<span class="commenter">Thierry</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220658">
						April 23, 2014 8:14 AM					</a>

				</p>

				<p>Sadly this report only mentions languages for Web sites and not for general purpose development. OpenSSL + C == Heartbleed&#8230;</p>
<p>Also the figures are too similar to be significant. And the PHP score is better than the Java one, while PHP does not check anything and allow mixing data of any kind, until something weird happens.</p>
<p>I would not trust that report that much. But there is a real need for good reports on the subject.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220659">

			<div class="comment by-benni ">

				<p class="commentcredit">

					<span class="commenter">Benni</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220659">
						April 23, 2014 8:25 AM					</a>

				</p>

				<p>Can some expert tell me what this openssl code is for<br />
I don&#8217;t know any ASM, but it seems to be some function caller for win 32 which was also compiled under unix:</p>
<p><a href="http://freshbsd.org/commit/openbsd/f868fc6f39a2c45a6c2bab70addc92525d467904" rel="nofollow ugc">http://freshbsd.org/commit/openbsd/f868fc6f39a2c45a6c2bab70addc92525d467904</a></p>
<p>So it turns out that libcrypto on i386 platforms, unconditionaly compiles this<br />
    little gem called OPENSSL_indirect_call(), supposedly to be &#8220;handy under<br />
    Win32&#8221;.</p>
<pre><code>In my view, this is a free-win ROP entry point. Why try and return to libc
when you can return to libcrypto with an easy to use interface?

Better not give that much attack surface, and remove this undocumented
entry point.

ok beck@ tedu@
</code></pre>
<p>+0  -39 lib/libssl/src/crypto/x86cpuid.pl<br />
+0  -39 1 file<br />
diff &#8211;git a/lib/libssl/src/crypto/x86cpuid.pl b/lib/libssl/src/crypto/x86cpuid.pl<br />
index c7a57a3..169036d 100644<br />
&#8212; a/lib/libssl/src/crypto/x86cpuid.pl<br />
+++ b/lib/libssl/src/crypto/x86cpuid.pl<br />
@@ -257,45 +257,6 @@ for (@ARGV) { $sse2=1 if (/-DOPENSSL_IA32_SSE2/); }<br />
    &amp;ret    ();<br />
 &amp;function_end_B(&#8220;OPENSSL_atomic_add&#8221;);</p>
<p>-# This function can become handy under Win32 in situations when<br />
-# we don&#8217;t know which calling convention, __stdcall or __cdecl(<em>),<br />
-# indirect callee is using. In C it can be deployed as<br />
-#<br />
-#ifdef OPENSSL_CPUID_OBJ<br />
-#  type OPENSSL_indirect_call(void *f,&#8230;);<br />
-#  &#8230;<br />
-#  OPENSSL_indirect_call(func,[up to $max arguments]);<br />
-#endif<br />
-#<br />
-# (</em>)  it&#8217;s designed to work even for __fastcall if number of<br />
-#  arguments is 1 or 2!<br />
-&amp;function_begin_B(&#8220;OPENSSL_indirect_call&#8221;);<br />
&#8211;   {<br />
&#8211;   my ($max,$i)=(7,);  # $max has to be chosen as 4<em>n-1<br />
&#8211;               # in order to preserve eventual<br />
&#8211;               # stack alignment<br />
&#8211;   &amp;push   (&#8220;ebp&#8221;);<br />
&#8211;   &amp;mov    (&#8220;ebp&#8221;,&#8221;esp&#8221;);<br />
&#8211;   &amp;sub    (&#8220;esp&#8221;,$max</em>4);<br />
&#8211;   &amp;mov    (&#8220;ecx&#8221;,&amp;DWP(12,&#8221;ebp&#8221;));<br />
&#8211;   &amp;mov    (&amp;DWP(0,&#8221;esp&#8221;),&#8221;ecx&#8221;);<br />
&#8211;   &amp;mov    (&#8220;edx&#8221;,&amp;DWP(16,&#8221;ebp&#8221;));<br />
&#8211;   &amp;mov    (&amp;DWP(4,&#8221;esp&#8221;),&#8221;edx&#8221;);<br />
&#8211;   for($i=2;$i&lt;$max;$i++)<br />
&#8211;       {<br />
&#8211;       # Some copies will be redundant/bogus&#8230;<br />
&#8211;       &amp;mov    (&#8220;eax&#8221;,&amp;DWP(12+$i<em>4,&#8221;ebp&#8221;));<br />
&#8211;       &amp;mov    (&amp;DWP(0+$i</em>4,&#8221;esp&#8221;),&#8221;eax&#8221;);<br />
&#8211;       }<br />
&#8211;   &amp;call_ptr   (&amp;DWP(8,&#8221;ebp&#8221;));# make the call&#8230;<br />
&#8211;   &amp;mov    (&#8220;esp&#8221;,&#8221;ebp&#8221;);  # &#8230; and just restore the stack pointer<br />
&#8211;               # without paying attention to what we called,<br />
&#8211;               # (__cdecl *func) or (__stdcall *one).<br />
&#8211;   &amp;pop    (&#8220;ebp&#8221;);<br />
&#8211;   &amp;ret    ();<br />
&#8211;   }</p>
<h2>-&amp;function_end_B(&#8220;OPENSSL_indirect_call&#8221;);</h2>
<p>&amp;function_begin_B(&#8220;OPENSSL_ia32_rdrand&#8221;);<br />
    &amp;mov    (&#8220;ecx&#8221;,8);<br />
 &amp;set_label(&#8220;loop&#8221;);<br />
Raw diff</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220660">

			<div class="comment by-j ">

				<p class="commentcredit">

					<span class="commenter">J</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220660">
						April 23, 2014 8:30 AM					</a>

				</p>

				<p>The article doesn&#8217;t seem to match up with the infographic:</p>
<blockquote><p>The bottom of the spectrum, or the most &#8220;secure,&#8221; also showed no significant difference between languages with the lowest averages of vulnerabilities per slot. Perl was observed as having 7 vulnerabilities per slot. ColdFusion was found to have the fewest with an average of 6.</p></blockquote>
<p>And yet the circles at the top of the article show ColdFusion with 7 and Perl with 6. I haven&#8217;t looked at the report itself to see which is actually correct.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220661">

			<div class="comment by-mirko ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.net-security.org' rel='external nofollow ugc' class='url'>Mirko</a></span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220661">
						April 23, 2014 8:36 AM					</a>

				</p>

				<p>The report had a few errors, including the infographic. We just uploaded an amended one.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220662">

			<div class="comment by-m-welinder ">

				<p class="commentcredit">

					<span class="commenter">M Welinder</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220662">
						April 23, 2014 9:02 AM					</a>

				</p>

				<p>Really?</p>
<p>As far as I know, no program written for a formal Turing machine has ever been implicated in any breach.  Programs as automatically protected against a range of systemic risks, such as buffer overflows.</p>
<p>And a fat load of good that does anyone in the real world.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220663">

			<div class="comment by-joe ">

				<p class="commentcredit">

					<span class="commenter">Joe</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220663">
						April 23, 2014 9:14 AM					</a>

				</p>

				<p>One has to take this with a grain of salt. Coldfusion is probably the most insecure web platform of all, hacking-wise. And it sure likes to crash a lot, not to mention all the SQL injection issues. Typed languages offer more protection against doing stupid things, unless the stupidity is encapsulated in buffer move macros and functions (Heartbleep, I mean you!). Obviously Facebook has been bitten too many times by PHP and has now put their typed version of the language out there for the public to use. And did anyone consider that a quasi-compiled web platform (JSP, .NET) might be safer than a purely interpreted language (Perl, PHP)? I don&#8217;t think this study was done with much thought.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220664">

			<div class="comment by-matt ">

				<p class="commentcredit">

					<span class="commenter">Matt</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220664">
						April 23, 2014 9:15 AM					</a>

				</p>

				<p>How are they sure they aren&#8217;t measuring the efficacy of their tools for finding bugs written in different languages?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220665">

			<div class="comment by-rsaunders ">

				<p class="commentcredit">

					<span class="commenter">RSaunders</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220665">
						April 23, 2014 9:53 AM					</a>

				</p>

				<p>It&#8217;s too bad you can&#8217;t program web sites in FORTRAN or PL/1.  No pesky, error-prone pointers in FORTRAN; and PL/1 on Multics used hardware to make it impossible for programmers to code the buffer overrun vulnerability that enables Heartbleed in the early 1970s (coming up on 50 years!).</p>
<p>There was cruft then as there is cruft now.  OpenSSL is well known for its cruft, and the LibreSSL people have been raising money to make a clean replacement for years.</p>
<p>The true problem is that people accept too much cruft in their world.  Users can&#8217;t help it, to them software is sufficiently-advanced-technology.  Developers and their managers need to hold themselves to a higher standard, like serious professionals in other fields.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220666">

			<div class="comment by-eric-wilson ">

				<p class="commentcredit">

					<span class="commenter">Eric Wilson</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220666">
						April 23, 2014 10:26 AM					</a>

				</p>

				<p>So the report is based on 30,000 websites who were selected on the basis that they were clients of WhiteHat Sentinel?</p>
<p>Even without that bit of information it was pretty obvious that this report was heavily biased towards large enterprise companies just by looking at their breakdown of languages by popularity.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220667">

			<div class="comment by-ian-woollard ">

				<p class="commentcredit">

					<span class="commenter">Ian Woollard</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220667">
						April 23, 2014 10:58 AM					</a>

				</p>

				<p>Pretty sure most of the common vulnerabilities are language specific, at least if you take a very wide definition of language (for example html is a language susceptible to Cross-Site Request Forgery attacks.)</p>
<p>The idea that programmers are going to be uniformly smart enough to correctly plug the holes in languages is most of the problem.</p>
<p>Basically, if you assume people don&#8217;t make mistakes, you&#8217;re going to have a hard time.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220668">

			<div class="comment by-neal-lester ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.mysafetyprogram.com' rel='external nofollow ugc' class='url'>Neal Lester</a></span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220668">
						April 23, 2014 11:24 AM					</a>

				</p>

				<p>Another analysis of the interaction between security and programming language design may be found here:</p>
<p>&lt;a href=&#8221;http://cacm.acm.org/blogs/blog-cacm/173827-those-who-say-code-does-not-matter/fulltext&gt;<a href="http://cacm.acm.org/blogs/blog-cacm/173827-those-who-say-code-does-not-matter/fulltext" rel="nofollow ugc">http://cacm.acm.org/blogs/blog-cacm/173827-those-who-say-code-does-not-matter/fulltext</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220669">

			<div class="comment by-douglas-knight ">

				<p class="commentcredit">

					<span class="commenter">Douglas Knight</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220669">
						April 23, 2014 11:57 AM					</a>

				</p>

				<p>These kinds of vulnerabilities might be the fault of the <em>library</em>, but how could XSS or SQL injection be the fault of the <em>language</em>?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220670">

			<div class="comment by-yesme ">

				<p class="commentcredit">

					<span class="commenter">yesme</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220670">
						April 23, 2014 11:58 AM					</a>

				</p>

				<p>Well, these are my 2cents.</p>
<p>Wether a language sucks or not depends IMO on the following conditions:</p>
<ul>
<li>Be simple and do what you expect it to do (sorry C++)</li>
<li>Clear and non cryptical syntax (again sorry C++)</li>
<li>Garbage Collected by default (euh&#8230; sorry C++ and C)</li>
<li>Productive (euh&#8230; sorry C++)</li>
<li>Easy to learn (euh&#8230; never mind)</li>
</ul>
<p>Of course Bjarne S. has a different view of the language. In <a href="http://harmful.cat-v.org/software/c++/I_did_it_for_you_all" rel="nofollow ugc">this interview</a> he explains the real reason for developing C++.</p>
<p>But the recently discovered holes (actually enlarged Boeing 747 hangar doors) in OpenSSL and GnuTLS could only have happened in C and C++.</p>
<p>That is a fact.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220671">

			<div class="comment by-anura ">

				<p class="commentcredit">

					<span class="commenter">Anura</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220671">
						April 23, 2014 12:08 PM					</a>

				</p>

				<p>These languages don&#8217;t really have any difference in protection against XSS vulnerabilities; that&#8217;s a problem of taking unsanitized input and writing it directly to the page. All of these languages have frameworks that make that unnecessary in most cases, but people end up writing HTML directly at least some of the time and they rarely sanitize input while doing so.</p>
<p>Things like SQL injections can be prevented by using safe methods to access the database which are usually available (e.g. parameterized queries, ORM), but all of them provide the ability to write direct SQL and people build SQL statements as strings with unsanitized user input.</p>
<p>There are also Cross Site Request Forgeries, which some frameworks have built in controls to protect against, but usually do not do by default. It&#8217;s a matter of adding a random token as a hidden input that is tied to the session to prevent someone from forging a form.</p>
<p>I don&#8217;t think this really measures the security of the languages themselves, so much as it measures the developers themselves.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220672">

			<div class="comment by-yesme ">

				<p class="commentcredit">

					<span class="commenter">yesme</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220672">
						April 23, 2014 12:49 PM					</a>

				</p>

				<p>Typo. I meant fully opened enlarged Boeing 747 hangar doors.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220673">

			<div class="comment by-caleb-cushing ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://xenoterracide.com' rel='external nofollow ugc' class='url'>Caleb Cushing</a></span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220673">
						April 23, 2014 1:09 PM					</a>

				</p>

				<p>I personally believe that the problem is neither language nor truly relative skill&#8230; it&#8217;s that the learning materials don&#8217;t teach in a secure by default manner.  Often they teach you insecure practices as they are the easiest. In fact I feel there are very few programming books at all that teach you how to program both securily (such as avoiding heartbleed) and security features (such as Access control), and this results in a large bulk of code being insecure.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220674">

			<div class="comment by-alon ">

				<p class="commentcredit">

					<span class="commenter">Alon</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220674">
						April 23, 2014 1:31 PM					</a>

				</p>

				<p>I couldn&#8217;t really trust any results from the article based on the obviously false statements they have made. They refer to ASP, Java, and .NET as &#8220;modern&#8221; while PHP, perl, and ColdFusion have &#8220;been around for decades&#8221;, even though Java appeared the same year as PHP and ColdFusion (1995), and ASP was released in 1996. Moreover, .NET is a framework, not a programming language, and the distribution of languages makes no sense. Where is C? C++? Python? Ruby on Rails?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220675">

			<div class="comment by-anura ">

				<p class="commentcredit">

					<span class="commenter">Anura</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220675">
						April 23, 2014 1:38 PM					</a>

				</p>

				<p>@Caleb Cushing</p>
<p>I think it&#8217;s a little of all three. When it comes to things like SQL injection, the tools to do things right are there, and it&#8217;s the fact that most language tutorials teach you the obsolete and insecure methods of running SQL statements. However, for things like CSRF, I do think it&#8217;s a language problem as the language makes you do extra work to protect against it. It&#8217;s also education, because if you have to do extra work, someone needs to teach you that.</p>
<p>With XSS, some people will at some point have to directly write HTML to the page based on user input. While frameworks can take care of most of it, there are going to be some circumstances where the tools provided are insufficient, and the problem is that the language features that write to the page don&#8217;t sanitize the input, and you usually have to call a separate function to do so. If instead of ASP.NET having Response.Write and having to call HttpServerUtility.HtmlEncode as well, we had Response.WriteText that encoded the text and Response.WriteRaw that didn&#8217;t, then you would force people to consider which one they wanted to use.</p>
<p>There is also the problem of people who know how to do things right, but get lazy or pressured for time and start making mistakes. This is why we need languages and frameworks to be designed to make the safe methods both the primary tools at both the higher and lower levels. Hell, there can even be warnings for unsafe methods for compiled languages like .NET and Java.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220676">

			<div class="comment by-anura ">

				<p class="commentcredit">

					<span class="commenter">Anura</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220676">
						April 23, 2014 1:40 PM					</a>

				</p>

				<p>@Alon</p>
<p>This is focused entirely on the most popular web programming languages (and .NET probably includes both VB and C#).</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220677">

			<div class="comment by-l ">

				<p class="commentcredit">

					<span class="commenter"><a href='https://www.fenrirproject.org' rel='external nofollow ugc' class='url'>L</a></span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220677">
						April 23, 2014 1:47 PM					</a>

				</p>

				<p>The article seems to only consider web-related languages. Web is a big thing today, but not everything, so talking about any native language is a little OT, but anyway&#8230;</p>
<p>Putting together C and C++, especially the newer C++11/14 shows that you do not know the language.</p>
<p>Sure it&#8217;s complex. But they are not the same.</p>
<p>C++ needs stricter coding rules, but I still consider it the best option, you can go low-level if you need it, there is not garbage collector, which is bad for any formal analysis of memory, is hardly predictable and slow, doesn&#8217;t have a whole virtual machine and doesn&#8217;t have the &#8220;everything is virtual&#8221; mentality. C++ compiler are the most advanced and developed today, too.</p>
<p>Those holes could only have happened in C, because both OpenSSL and GnuTLS are coded in C, because gotos in C++ are not so necessary anymore, because in C++ everybody uses vectors or strings which already provide .length() functionality, so you don&#8217;t actually have to reimplement it every time, because in C++ whenever you are using malloc/free you are most probably wrong, because MACROS should only be used as header guards in C++&#8230; because&#8230; C++ is not C.</p>
<p>If you think they are the same, do not write C++ code, it will be your worst thing ever.</p>
<p>Also, compilers have gotten really good, and we have a lot of tools for static analysis of C and C++ code. But people should use those&#8230;otherwise it&#8217;s pointless. Simply compiling with -Weverything can tell you a real lot, and help you improve.<br />
The TLS goto bugs would have been really easy to spot with just a &#8220;dead code elimination&#8221; warning&#8230; you know, the one that says &#8220;this code will never be executed&#8221;&#8230;</p>
<p>So you have a huge mass of unchecked, barely maintained macro-ridden code, with a style that has nothing to do with C++&#8230; and yet C++ is the same.</p>
<p>Programming correctly in C++ is harder than in java, ok. Still, no language can be idiot-proof. Idiots are always smarter. C++ used correctly takes away all the bad things from C.</p>
<p>Maybe something else is still safer, but C++ is NOT C.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220678">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220678">
						April 23, 2014 2:03 PM					</a>

				</p>

				<p>I&#8217;m busy most of the day so I&#8217;ll write my real post later on. For now, I&#8217;ll mention that there are a number of languages that prevent many problems in web apps by design via type system and/or compiler. Example below:</p>
<p><a href="http://www.impredicative.com/ur/" rel="nofollow ugc">http://www.impredicative.com/ur/</a></p>
<p>@ RSaunders</p>
<p>Looked at your comment and found a present for you:</p>
<p><a href="http://flibs.sourceforge.net/fortran-fastcgi-nginx.html" rel="nofollow ugc">http://flibs.sourceforge.net/fortran-fastcgi-nginx.html</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220679">

			<div class="comment by-snarki-child-of-loki ">

				<p class="commentcredit">

					<span class="commenter">Snarki, child of Loki</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220679">
						April 23, 2014 2:20 PM					</a>

				</p>

				<p>I can confidently predict that ZERO security holes will be found in APL.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220680">

			<div class="comment by-nauer-laiter ">

				<p class="commentcredit">

					<span class="commenter">Nauer Laiter</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220680">
						April 23, 2014 2:24 PM					</a>

				</p>

				<p>Rather loose in what they call a &#8220;language,&#8221; eh?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220681">

			<div class="comment by-yesme ">

				<p class="commentcredit">

					<span class="commenter">yesme</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220681">
						April 23, 2014 2:25 PM					</a>

				</p>

				<p>@L, the title suggests languages in general, the article is indeed about the web.</p>
<p>The funny thing is that everyone talks about C++11 these days as if it is some magic bullet. The reality however is that every library is still written in the old stuff so you need to know the whole lot. That&#8217;s the problem with backwards compatibility.</p>
<p>&#8220;C++ used correctly takes away all the bad things from C.&#8221;</p>
<p>The problem here is &#8220;used correctly&#8221;. But that&#8217;s als the case with C.</p>
<p>As a side note, the OpenBSD guys have the OpenSSL fork now working with -Wall -Werror. (btw, dead code detection flag doesn&#8217;t work with GCC)</p>
<p>My favorite systems language however is Go. Close to C but without the pitfalls.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220682">

			<div class="comment by-tl ">

				<p class="commentcredit">

					<span class="commenter">TL</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220682">
						April 23, 2014 3:43 PM					</a>

				</p>

				<p>@yesme &#8220;My favorite systems language however is Go. Close to C but without the pitfalls.&#8221;</p>
<p>I like C because of what it enables me to do, not the power that it takes away.</p>
<p>So many other languages are defined subtractively from C, taking away pointers, or goto statements, or explicit memory management. That means you have <em>less</em> power to control the machine.</p>
<p>If I was a surgeon, I wouldn&#8217;t want to wear oven mitts to perform an operation, so why would I want to use a computer language that blunts my capacity to define how the computer works?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220683">

			<div class="comment by-anura ">

				<p class="commentcredit">

					<span class="commenter">Anura</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220683">
						April 23, 2014 4:01 PM					</a>

				</p>

				<p>@L</p>
<p>Can you give me an example of a large C++ application that doesn&#8217;t use raw pointers or arrays? I will ignore the parameters of main being (int argc, char **argv) instead of (std::vector&lt;std::string&gt;).</p>
<p>@TL</p>
<p>The surgeon analogy is flawed as higher level languages generally take less effort to accomplish the same task without making a mistake. What exactly are you coding where raw pointers are preferable over a bounds checked, type-safe container?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220684">

			<div class="comment by-shawn-smith ">

				<p class="commentcredit">

					<span class="commenter">Shawn Smith</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220684">
						April 23, 2014 7:50 PM					</a>

				</p>

				<p>@Anura,</p>
<p>The first thing that pops into my head as to why I would use raw pointers is when working with display framebuffers on a ssssslllllloooooooowwwwww processor or memory-mapped I/O ports. And in those cases, why not go all out and move down to assembly? But other than that, yeah, I&#8217;ve got nothing.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220685">

			<div class="comment by-otto ">

				<p class="commentcredit">

					<span class="commenter">otto</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220685">
						April 23, 2014 8:04 PM					</a>

				</p>

				<p>They only mentioned PHP in the beginning of the article, and never again.  Really sticks out as kinda lazy.</p>
<p>PHP has a vibrant community, and excellent documentation. I use it for sysadmin production tasks (it&#8217;s multi-platform) and on embedded systems.  It&#8217;s fast to make changes (no compile or JVM) and easy to read, with control structures like C.  Untyped languages make it easier to get good code out the door faster.</p>
<p>You have to build security into your application from the beginning.  It&#8217;s not a language attribute.  The responsibility of the programming team is to design, code and test their application to survive in a hostile environment.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220686">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220686">
						April 23, 2014 8:48 PM					</a>

				</p>

				<p><b>On Secure Web Application Development Langauges</b></p>
<p>There are several approaches to this. The most common approach is to create frameworks that handle security aspects. Another is to use tools to analyze the web application to catch defects. Another is to use a middleware that mediates activity and applies security policy. Another is to extend an existing language to prevent security problems. Yet another is to create an entirely new language specifically for solving the problem. I&#8217;ll include examples of everything but the flaw finding checkers as there&#8217;s lists of them elsewhere.</p>
<p>The simplest is including security in a framework. There&#8217;s quite a few that do. The best effort for legacy apps is <a href="https://www.owasp.org/index.php/Category:OWASP_Enterprise_Security_API" rel="nofollow ugc">OWASP Enterprise Security API</a>. Combining that with a safe language would go a long way. There are a number of web frameworks for safe languages that leverage their type system for safety and/or security. Lesser known languages with such frameworks include <a href="http://ocsigen.org/overview/eliomapplications" rel="nofollow ugc">Ocaml</a>, <a href="http://www.yesodweb.com/" rel="nofollow ugc">Haskell</a>, <a href="https://code.google.com/p/ada-awa/" rel="nofollow ugc">Ada</a>, <a href="https://github.com/Eiffel-World/Eiffel-Web-Framework" rel="nofollow ugc">Eiffel</a>, and <a href="http://seventhings.liftweb.net/security" rel="nofollow ugc">Scala</a>. (Links are frameworks.) The resulting security level varies with each of these, of course. And any integration of external (unsafe) code is risky.</p>
<p>The gateway approach goes a long way back. It was the original security solution to all sorts of problems in the Orange Book days. There were mail guards, trusted network processors, database front ends, and so on. I even applied a version of this in older designs to secure client-server apps. The one example I know of for web apps is <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.57.9004&amp;rep=rep1&amp;type=pdf" rel="nofollow ugc">SPECTRE</a>. It works on legacy code written in multiple languages, but the gateway was built with Ocaml if I recall correctly.</p>
<p>The extension approach is halfway between a framework and a dedicated language. The idea is to modify the language-level to help it do its job better while leveraging existing code or experience. Examples for endpoint protection are <a href="http://www.cs.berkeley.edu/~daw/papers/joe-e-ndss10.pdf" rel="nofollow ugc">Joe-E</a> (server) and <a href="https://code.google.com/p/google-caja/" rel="nofollow ugc">Caja</a> (client). Of course, it&#8217;s the <em>interactions</em> that cause many web issues. The best project I&#8217;ve seen that extends languages &amp; tools for this is <a href="http://www.cs.cornell.edu/jif/swift/" rel="nofollow ugc">SWIFT</a>. It does both information flow control &amp; automatically partitions code between client &amp; server.</p>
<p>The new language approach is another route. This is usually chosen to get rid of the multiple languages problem, but sometimes for security benefit. <a href="http://www.cs.umd.edu/~nswamy/papers/fable-tr.pdf" rel="nofollow ugc">SELINKS</a> modifies the LINKS web language to boost security. <a href="http://opalang.org/" rel="nofollow ugc">Opa</a> integrates all the development while leveraging powerful type system to catch errors. <a href="http://www.impredicative.com/ur/" rel="nofollow ugc">Ur/Web</a> prevents an amazing amount of stuff using an advanced type system. There&#8217;s another being developed at INRIA based on F# that will probably be interesting given what ML-style languages have accomplished in this field.</p>
<p>The right choice depends on one&#8217;s requirements, of course. However, if we just look at technical data, the best choice is a combination of above tech and ideas. For legacy systems whose code can&#8217;t change, is to use something like SPECTRE along with security tech for that langauge/platform. If you can change the code, use one of the solid frameworks while refactoring out risky stuff. If it&#8217;s a new project, use one of the safer languages or SWIFT. Also, if there&#8217;s any native code, isolate it with a tech such as Native Client, write it in a language like Ada with checks on, or both.</p>
<p>I think it&#8217;s very possible to write secure web applications with little effort. These will be secure against known classes of attack, of course. New discoveries might invalidate the security. Nonetheless, starting with safe languages &amp; constructs for securely handling risky issues is a superior option in the long run regardless of what schemes are discovered. The reason is that the choice provides a strong foundation to build new technology on with lower odds of shooting one&#8217;s self in the foot.</p>
<p>So, now that you know this, go write some secure web apps to replace the popular ones! 🙂</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220687">

			<div class="comment by-anura ">

				<p class="commentcredit">

					<span class="commenter">Anura</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220687">
						April 23, 2014 8:52 PM					</a>

				</p>

				<p>@otto</p>
<p>PHP isn&#8217;t untyped, it&#8217;s weakly typed. Maybe confusingly typed is a better name for it&#8230; Or maybe we can call it a <a href="http://phpsadness.com/sad/47" rel="nofollow ugc">type dangerous language</a>.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220688">

			<div class="comment by-richard-schwartz ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://www.poweroftheschwartz.com' rel='external nofollow ugc' class='url'>Richard Schwartz</a></span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220688">
						April 23, 2014 9:08 PM					</a>

				</p>

				<p>Is it just me, or does anyone else have a problem with research that appears not to understand the difference between a language and a framework?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220689">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220689">
						April 23, 2014 9:28 PM					</a>

				</p>

				<p><i>The Study</i></p>
<p>The choice of .NET, Java, PHP, and ASP.net are good as they&#8217;ll represent most web applications. Coldfusion is OK as there&#8217;s at least a lot of legacy systems running it. The fact that they chose Perl instead of Ruby (i.e. Rails) is confusing as I almost never hear of a web app being written in Perl, although Rails became a tiny industry. Although, the Movable Type system that powers Bruce&#8217;s blog is Perl-based.</p>
<p>The overall vulnerability ratio along with their explanation (attack surface) seem accurate. It&#8217;s unsurprising that there wasn&#8217;t much difference between the major platforms because <em>they&#8217;re about the same in terms of features and how they implement them.</em> I&#8217;d like to see a similar analysis of web apps in Erlang, Ocaml, Haskell, Ada, or LISP. They handle things quite different &amp; have different levels of effort in safety/security. Of course, there are technologies designed specifically for secure web applications which are covered in above essay.</p>
<p>SQL injection, Cross-site scripting, and cross-site request forgery are still a big problem despite proven methods of dealing with them that aren&#8217;t such a pain. Problem must be in language, platform, libraries and/or processes. These issues simply shouldn&#8217;t be happening given what we know about preventing them.</p>
<p><i>Responses to individual commenters</i></p>
<p>@ Benni</p>
<p>That does look suspicious as heck. That it&#8217;s a bunch of assembler would make a mistake both easier to hide &amp; look like programmer error.</p>
<p>@ Weilinder</p>
<p>&#8220;As far as I know, no program written for a formal Turing machine has ever been implicated in any breach.&#8221;</p>
<p>Far as I know, no formal Turing machine has ever been implemented and practical at the same time. I&#8217;m glad you mentioned it, though, as I found a bunch of interesting research leveraging Turing machines for security. All this time hearing about the concept I never knew how much better it was for real security vs common machines!</p>
<p>@ Ian Woollard</p>
<p>Good point. Pushing more worries on a programmer while assuming they&#8217;ll do things right isn&#8217;t a good way to do things.</p>
<p>@ Neal Lester</p>
<p>It was a good read and a sound argument. I looked at author&#8217;s name after reading the article so it was a pleasant conclusion to see it was none other than the inventer of a good language. He doesn&#8217;t just preach a theory, he put it into practice. 🙂</p>
<p>@ Douglas Knight</p>
<p>&#8220;These kinds of vulnerabilities might be the fault of the library, but how could XSS or SQL injection be the fault of the language?&#8221;</p>
<p>See my above post on how certain languages&#8217; design decisions make many errors easy to prevent.</p>
<p>@ Anura</p>
<p>&#8220;I don&#8217;t think this really measures the security of the languages themselves, so much as it measures the developers themselves.&#8221;</p>
<p>I agree mostly. Although, naturally I&#8217;m also inclined to blame languages that make mistakes easier. We all had this discussion re system programming recently. Many of same points apply to secure web programming.</p>
<p>@ Caleb</p>
<p>&#8220;I personally believe that the problem is neither language nor truly relative skill&#8230; it&#8217;s that the learning materials don&#8217;t teach in a secure by default manner. &#8221;</p>
<p>It&#8217;s really the language/platform, Caleb. In some I posted above, you can practically throw a web application together while being sure it doesn&#8217;t have all kinds of problems. That someone has to pause with concern for every function they write to accomplish the same thing says their tool is inferior. If it can be automated away, it should be.</p>
<p>@ L</p>
<p>&#8220;Putting together C and C++, especially the newer C++11/14 shows that you do not know the language.&#8221;</p>
<p>&#8220;Programming correctly in C++ is harder than in java, ok. Still, no language can be idiot-proof. Idiots are always smarter. C++ used correctly takes away all the bad things from C.&#8221;</p>
<p>Most C++ code isn&#8217;t the newest one so it&#8217;s an unfair statement. That said, while there are many differences, C and C++ share many of the same risks from a security point of view. Particularly, many of the most common operations must be scrutinized to avoid code injections. A previous discussion on this blog covered many languages that are type and memory safe by default while allowing high performance code. Two were used to write operating systems, microcontrollers, etc. So, putting C &amp; C++ into the same category, while labeling them bad for security, makes sense to me. Compared to a language like Ada or PL/I, C++ is just turd polishing of C.</p>
<p>@ snarki</p>
<p>&#8220;I can confidently predict that ZERO security holes will be found in APL.&#8221;</p>
<p>I&#8217;m placing a bet on a code injection in the interpreter using a failed array bounds check. Just because it would be ironic and hilarious. 😉</p>
<p>@ otto</p>
<p>Check out Quercus&#8217;s implementation of PHP in Java. Combines best of both world&#8217;s. I kept it in my archives in case I was ever forced to use PHP I might avoid some of its security problems. &#8220;And trade them for Java&#8217;s&#8221; you might say? Yeah, it&#8217;s why decided against both but it&#8217;s nice to have a safer implementation of PHP with access to Java libraries.</p>
<p>@ Richard Schwartz</p>
<p>&#8220;Is it just me, or does anyone else have a problem with research that appears not to understand the difference between a language and a framework?&#8221;</p>
<p>Yeah, they kind of go hand in hand in web app development. A language with one might have shoddy security, while another framework provides excellent security. It&#8217;s why I mentioned both in my essay above. Analyzing one without the other makes little sense.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220690">

			<div class="comment by-anura ">

				<p class="commentcredit">

					<span class="commenter">Anura</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220690">
						April 24, 2014 3:11 AM					</a>

				</p>

				<p>@Nick P</p>
<blockquote><p>I agree mostly. Although, naturally I&#8217;m also inclined to blame languages that make mistakes easier. We all had this discussion re system programming recently. Many of same points apply to secure web programming.</p></blockquote>
<p>Naturally the same things apply, however in this case I think the frameworks and tools available are fairly even across the languages; .NET has pretty good tools available and there are good frameworks for Java and PHP as well. This is why I say that most of the differences you see between these languages in this particular test is going to be more about the developers than the languages themselves.</p>
<p>That said, .NET websites do have a tendency to be misconfigured to show the exception with the stack trace&#8230; combined with a debug build being deployed and I&#8217;ve seen cases where invalid input prints out the code that builds the SQL; very useful to an attacker.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220691">

			<div class="comment by-autolykos ">

				<p class="commentcredit">

					<span class="commenter">Autolykos</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220691">
						April 24, 2014 5:23 AM					</a>

				</p>

				<p>I agree that C makes it unnecessarily hard to write safe code. That argument, however, only translates to C++ if the guy writing the code still uses C++ as he would use C. But there&#8217;s no sane reason to. Classes in C++ increase safety a lot (especially if you are consequent about getters/setters and RAII) and hardly cost any performance at all (unless you go heavy on the virtual or write poor C&#8217;tors, D&#8217;tors and assignment operators). Most stuff in the STL is safe and convenient to use, while still being at least as fast as you could expect it to be if you write it yourself (unless you&#8217;re a true ASM whiz). If you ever have a raw pointer/array in any but the innermost and best encapsulated C++ code, you&#8217;re doing it wrong.</p>
<p>So the main argument against C++ is that it doesn&#8217;t <em>prevent</em> you from writing bad code if you really want to. But I don&#8217;t think a language should &#8211; compilers that think they are smarter than the programmer are a serious pain in the lower backside and will inevitably result in programmers trying to outwit the compiler once they feel the need to use the &#8220;unsafe&#8221; parts (you can see that a lot with PASCAL and Java).</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220692">

			<div class="comment by-mr-pragma ">

				<p class="commentcredit">

					<span class="commenter">Mr. Pragma</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220692">
						April 24, 2014 5:30 AM					</a>

				</p>

				<p>That &#8220;report&#8221; starts by mentioning which languages are the most used.<br />
Which basically comes down to saying that these languages don&#8217;t have security or safety in their mind in the first place (and yes, as if to shout out &#8220;we do not really know what we&#8217;re talking about&#8221; that company mixes up languages and frameworks on top of it).</p>
<p>But let&#8217;s look at it because actually the raison d&#8217;etre of a language <em>does</em> provide valuable hints at, among others, safety and security.</p>
<p>Nota bene: I&#8217;ll put C and C++ into one box and so I will do with Pascal and Modula, too. In both cases the languages are quite closely related and in fact the latter was inspired (or even guided) theoretically as well as practically by the former.</p>
<p>C (and consequently C++ by intention or not) was created as a system language; in fact, it was created for the purpose to create an OS (Unix) for a new architecture.<br />
While some like to bash C/C++ for its very raison d&#8217;etre I do agree with K&amp;R (and Stroustrup). Seen from the perspective of then, at that time, C was an elegant construct and a major progress. But there&#8217;s a but: That does include that C was meant to be an elegant super- and meta-assembler.<br />
I think that C still is a language of choice for low level routines close to hardware. Sure enough, though, C has not been designed for nor is it adequate for general programming, particularly when considering safety and security (which wasn&#8217;t a big issue for K&amp;R. At that time pretty everything was filled with trust and differentiating between different users and root was almost more than was considered needed).</p>
<p>Funnily Pascal which was developed at roughly the same time and for quite similar purposes, albeit more implicitly, took a very different approach. Where &#8220;power&#8221; was paramount &#8211; and natural &#8211; for K&amp;R, &#8220;safety&#8221; (in todays lingo) was paramount for Wirth. While some say that Wirths main reason was simplicity (with safety just a consequence), based on what his later work tells about Wirth, safety <em>was</em> important to Wirth, too; maybe not expressly but sure enough, safety (well, what we call safety today) <em>was</em> important to Wirth. And Wirth <em>did</em> know that his approach carried a hefty price tag concerning Pascals usability for low level systems programming &#8230; and he went on to create Modula which was way better suited without giving up Pascals advantages.</p>
<p>And like that it still is today. Pascal, Modula, Oberon &#8230; up to Ada and, to a degree, the strange cousin Eiffel do value safety highly but implemented different approaches to low-level close the the iron programming.<br />
And C/C++ and their many offspring still don&#8217;t care too much about safety. I take it as a strong hint that during decades that camp came up with only 1 &#8220;major&#8221; attempt at safety, Cyclone, and that Cyclone is a pretty much ignored and little taken care of creation.</p>
<p><em>If</em> this world were full of professional and professionally trained developers, C/C++ might be good solutions. Millions of bugs and eruptions like heartbleed, or openssl in general, however, very strongly suggest that this world has to do with a very considerable part of less capable developers.<br />
And btw: openssl is what the C/C++ developers that we happen to have around create when they expressly work on security sensitive stuff &#8230;</p>
<p>Java was created to run on anything that holds still long enough to inject a vm. If java had security and safety in mind (frankly, I doubt it, no matter what they tell me) then they relied mainly on bureaucracy to achieve it (Yes, I&#8217;m somewhat biased but then, who could seriously demand &#8211; and based on what? &#8211; to consider java anything but a funny experiment gone awry?) The mere fact of java being in Oracles hands (and the way they handled it) tells me loud enough to avoid java fervently.</p>
<p>On a sidenote: I sometimes wonder whether that whole language thing also tels a lot about usa and europe. In Europe the Wirth languages were created, OCaml, Erlang, and Ada (yes, right, Ada. It was ordered by the us dod but designed by a frenchman) while the usa has C and a bunch of commercial thingies like java, [whatever]script, etc. And no, I do not mean to imply any judgement; it merely strikes me as different cultures (or culture at all *g) like in France, Germany, Suisse, or in Russia vs. in usa, canada using rather different approaches following rather different criteria and wightings. I personally rest very strongly in the European camp although I profoundly respect K&amp;R and praise Tucker Taft et al. for what they have done with and for Ada (and for respecting some basic &#8220;holy credos&#8221; of J. Ichbiah in the first place).</p>
<p>My personal preference is Modula/Oberon (although compiler support is thin and for few architectures only) and Ada 2005 (yes, I <em>love</em> 2012). I have to (and want) to &#8220;confess&#8221;, though that I really like Adas very hands down practical approach and support for C.</p>
<p>Is language a decisive criteria for safety and security in the world we live in (as opposed to a heaven with professional C developers): You bet!<br />
When developing in Ada or Oberon a bug is a strange creature and a security flaw is bad design and rare. When developing in C I spent eternities with a debugger. Not because I&#8217;m a lousy coder but because safety and reliability meant a lot even when developing in C (and unit tests were not yet standard procedure).</p>
<p>I am, btw, not a yota less productive or fast in Ada or Modula or Oberon than in C or C++, quite the contrary. As far as scripting is concerned I like Python (extremely well thought out, very productive, brilliant minds and deep zen behind it and lots of batteries included). I wouldn&#8217;t think in terms of security of Python or, more generally, scripting, but one can create quite reliable utilities. And it needn&#8217;t be expressly secure (for that there is Ada or Modula etc.) but it mustn&#8217;t be a trouble ticket generator like Perl neither &#8230;</p>
<p>I hope I didn&#8217;t bore you but I&#8217;m concerned with those questions since more than a decade and I was and am under pressure to be productive yet deliver reliable and secure products. So I thought you might be interested in some of my thoughts.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220693">

			<div class="comment by-mr-pragma ">

				<p class="commentcredit">

					<span class="commenter">Mr. Pragma</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220693">
						April 24, 2014 5:44 AM					</a>

				</p>

				<p>Oh, and btw:</p>
<p>Would you kindly stop to insult us with the C11 and similar arguments?</p>
<p>Fact is that gazillions of lines of &#8211; often security relevant code (-&gt; openssl) &#8211; are written in not even C99 but, in fact, old K&amp;R (plus some funny compiler dialects (-&gt; pragmas)).</p>
<p>Similarly the argument of tools, discipline and whatnot are missing the point. C had decades to become more safe, in design as well as in practical use. Unfortunately, for some weird out of this world reason (because, listening to the C/C++ faction, each one of them seems to produce close to perfect, unit tested, statically analyzed and whatnot code) the sad fact is that very much &#8211; if not the vast majority &#8211; of C and C++ code is full of crap.</p>
<p>So, sorry, using C/C++ [current standard plus bla] is <em>not</em> the answer.</p>
<p><i>(Oh, and yes, offer me your other approach, too, namely kindly dare to tell me that I simply don&#8217;t know what I&#8217;m talking about. As a matter of fact I did teach C and C++. I didn&#8217;t throw away tens of years of language proficiency and more than 10.000 $ worth of tools for the fun of it but because I <em>had</em> to.)</i></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220694">

			<div class="comment by-l ">

				<p class="commentcredit">

					<span class="commenter">L</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220694">
						April 24, 2014 7:34 AM					</a>

				</p>

				<p>Calm down, I never said that you can&#8217;t write bad things in C++, and I never put it against ada, erlang or any other language.<br />
I simply said that IMHO C and C++ are structurally different languages. Even more if you consider pre-C99 and post-C++11.</p>
<p>Your argument is: today a lot of software is written in pre-C99, therefore C++ sucks. doesn&#8217;t make much sense, since memory management, length and a lot of other stuff are safe in c++. sure, other languages might be better. All i&#8217;m saying is that C and C++ are not the same.</p>
<p>Sure you can write C and C++ code with the same assembly, but I still think a correct c++ is way safer than a correct c. Of course having bad programmers will mean non-maintainable code and bugs in any language. New tools <em>do</em> help. But people need to use them. otherwise it&#8217;s like writing perfectly safe code with a (known) buggy compiler&#8230;</p>
<p>Still, for any (opensouce) big project today C/C++ is the only choice, since that&#8217;s what people know the most.</p>
<p>Purely functional languages are great and extremely safe, but you reach a fraction of developers. You must also take that into account: opensource works because lots of people can edit the code. Write in ada if you want. It will be great code. But with one or two contributors. Your project will take longer to develop, fix, will be harder to find contributors and maintainers.</p>
<p>It&#8217;s all about tradeoffs, IMHO c++ with a good maintainer is a good tradeoff. That&#8217;s all I&#8217;m saying. I never compared C++ to anything else than C, btw.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220695">

			<div class="comment by-peter-boughton ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://peterboughton.net' rel='external nofollow ugc' class='url'>Peter Boughton</a></span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220695">
						April 24, 2014 8:52 AM					</a>

				</p>

				<p><a href="#c5617561" rel="nofollow ugc">Joe wrote</a>:</p>
<p><i>&gt;Coldfusion is probably the most insecure web platform of all, hacking-wise.</i></p>
<p>I&#8217;m not an Adobe fan, but I&#8217;m pretty sure <em>EVERY</em> CF attack that has been reported in the past 24 months was due to an <em>UNPATCHED</em> server &#8211; that is, Adobe had already released the fix, but the server admins hadn&#8217;t bothered to apply it.</p>
<p>(Which isn&#8217;t to say some of the issues weren&#8217;t ones that never should have existed in the first place, but it&#8217;s unfair to entirely blame CF/Adobe.)</p>
<p><i>&gt;not to mention all the SQL injection issues</i></p>
<p>PEBKAC</p>
<p>The CFML language provides the tools necessary to prevent SQL injection.</p>
<p>The issue is primarily bad programmers, bad programming practices, and perhaps a touch of Adobe&#8217;s reluctance/inability to properly educate developers.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220696">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220696">
						April 24, 2014 9:24 AM					</a>

				</p>

				<p>@ Anura</p>
<p>&#8220;That said, .NET websites do have a tendency to be misconfigured to show the exception with the stack trace&#8230; combined with a debug build being deployed and I&#8217;ve seen cases where invalid input prints out the code that builds the SQL; very useful to an attacker.&#8221;</p>
<p>I&#8217;ve seen that! It was on a major web site whose name I can&#8217;t recall at the moment. I used a form of some type, then saw what looked like a debug dump. I was thinking &#8220;should the <em>user</em> be seeing all this crap? Or should it have been emailed to admin or developers?&#8221; Two options, one good &amp; one bad for security, which will .NET choose? Result: &#8220;Doh!&#8221; (Homer Simpson)</p>
<p>@ Autolykos</p>
<p>&#8221; That argument, however, only translates to C++ if the guy writing the code still uses C++ as he would use C.&#8221;</p>
<p>It&#8217;s an interesting claim. Most empirical studies I&#8217;ve seen of C++ support my comparison to C in vulnerability. However, the way C++ was being used <em>was</em> like an enhanced C. I&#8217;d actually like to see a vulnerability analysis of your safer style of C++ to see what it&#8217;s actual risk is.</p>
<p>@ Mr Pragma</p>
<p>&#8220;C (and consequently C++ by intention or not) was created as a system language; in fact, it was created for the purpose to create an OS (Unix) for a new architecture.<br />
While some like to bash C/C++ for its very raison d&#8217;etre I do agree with K&amp;R (and Stroustrup). Seen from the perspective of then, at that time, C was an elegant construct and a major progress.&#8221;</p>
<p>I actually agree with you about that. I only criticize C/C++ for current use. Back in the day, it made plenty of sense to make something like C at least.</p>
<p>&#8221; I take it as a strong hint that during decades that camp came up with only 1 &#8220;major&#8221; attempt at safety, Cyclone, and that Cyclone is a pretty much ignored and little taken care of creation.&#8221;</p>
<p>Don&#8217;t forget <a href="http://dlang.org/" rel="nofollow ugc">D</a>. That project puts in solid work to make a better, safer C++. They deserve some credit. Like you said, though, almost no take up.</p>
<p>&#8220;The mere fact of java being in Oracles hands (and the way they handled it) tells me loud enough to avoid java fervently.&#8221;</p>
<p>Absolutely. What they tried to do with Android speaks of their character plenty: they have none.</p>
<p>&#8220;On a sidenote: I sometimes wonder whether that whole language thing also tels a lot about usa and europe. &#8221;</p>
<p>Americans invented the first safe machine (B5000), the first implemented HLL (Short Code), the compiler (Grace Hopper), BNF form (Backus), analysis of fundamental algorithms (Knuth), formal code reviews (Fagan), first implemented theorem prover (Logic Theorist), functional programming (Lambda Calculus), the field of computer security (Anderson Report), formal vulnerability assessment (MULTICS evaluation), covert channel analysis (Kemmerer), and formal security assurance process (Orange Book). Americans also coinvented ALGOL, which set the stage for languages you named. If anything, I&#8217;d say certain Americans laid the foundation for safe/secure computing much like certain Europeans (esp British) laid the foundation for computing.</p>
<p>So what of today? I&#8217;m the authorative source on all things security research having reviewed literally thousands of papers spanning decades. Early on, most of it was predominantly in America with us being most concerned &amp; with lots of funding to solve the problems. Today, most of the research in security &amp; better programming is spread across US and Europe, with some in Asia &amp; Australia.</p>
<p>I can&#8217;t see a definitive pattern. There&#8217;s good work going on in both continents across the broad range of topics. My current European favorite is Xavier Leroy&#8217;s Gallium team in France because their group combines theory and practice pretty well. They also produced useful stuff for rest of us: Coq, Ocaml, CompCert C compiler, and MiniML compiler on the way. Not sure of an American favorite although there&#8217;s quite a few good ones. I&#8217;m not so biased in that I think international efforts are best for this field, esp when one considers the risk called subversion.</p>
<p>As for culture, there <em>does</em> seem to be a difference in culture. I wonder if it&#8217;s the capitalist/individualist vs socialist mindset. I noticed that tools such as Modula had a decent amount of takeup in Europe, whereas in US it was mostly C/C++. I know over here the profit and time to market pressure make a quality development process a liability. Well, at least appear to be to management. There&#8217;s also a ton of legacy code in C/C++ and people who can maintain it. So, these incentives seem to combine to prevent safer languages and platforms from taking off, while reinforcing unsafe practices. I&#8217;m not sure what it&#8217;s like in various European software shops. I&#8217;m guessing you&#8217;re European so maybe you could give me a perspective on that in whatever countries you&#8217;ve worked.</p>
<p>&#8220;My personal preference is Modula/Oberon (although compiler support is thin and for few architectures only) and Ada 2005 (yes, I <em>love</em> 2012).&#8221;</p>
<p>Same here. They seem to make all the right design decisions &amp; are quite versatile. Both sets of languages have been used on hardware ranging from desktops to microcontrollers. Ada was also used in a mainframe-type system (BiiN) and several highly secure systems (ASOS, SAT). There&#8217;s also empirical evidence backing Ada reducing vulnerabilities &amp; being more productive than C. The support for C is a practical decision that made sense.</p>
<p>&#8220;As far as scripting is concerned I like Python (extremely well thought out, very productive, brilliant minds and deep zen behind it and lots of batteries included). &#8221;</p>
<p>We think alike twice. Check out Stackless Python and Cython, btw. The Python camp just keeps on getting better.</p>
<p>&#8220;So I thought you might be interested in some of my thoughts.&#8221;</p>
<p>Very interesting post. 🙂</p>
<p>@ L</p>
<p>&#8221; doesn&#8217;t make much sense, since memory management, length and a lot of other stuff are safe in c++. sure, other languages might be better. All i&#8217;m saying is that C and C++ are not the same.&#8221;</p>
<p>They&#8217;re surely not the same as I&#8217;d take C++ over C wherever possible. Yet, it&#8217;s hard for me to believe C++ is as safe as you say when professional C++ developers and researchers are working their butts off to make it safe. The existence of MISRA C++, Ironclad C++, research into making it safe, and tons of vulnerability analysis tools make it hard for me to mentally connect &#8220;safe&#8221; and C++. Although, the newest standard might improve that situation. I havent&#8217; reviewed it as we already have safe, fast, readable languages with good IDE&#8217;s so why bother.</p>
<p>Funny thing is, I could teach an average C++ programmer how to safely use Modula-like language faster than I could teach them how to write secure C++. I did this more than once. Each time, I pointed it out to them &amp; enjoyed the look on their faces. One also commented that the safer language resembled the pseudocode he wrote and translated into C++. He said using the safer language eliminated most of that mental translation step. All of them also appreciated the near instant compile time as they could develop-compile-run without loosing mental flow. Ah, the joys of a very well-designed language. 🙂</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220697">

			<div class="comment by-mr-pragma ">

				<p class="commentcredit">

					<span class="commenter">Mr. Pragma</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220697">
						April 24, 2014 10:22 AM					</a>

				</p>

				<p>Nick P (April 24, 2014 9:24 AM)</p>
<p><i>&#8220;Back in the day, it made plenty of sense to make something like C at least.&#8221;</i></p>
<p>While this is only a small remark, seemingly not deserving further attention, I see more there.</p>
<p>First, of course, a cross architecture meta-assembler made lots of sense and was &#8211; and still is in certain areas &#8211; very useful.</p>
<p>Also, funnily, I find myself using C again when doing jobs close to hardware. Obviously Modula is perfectly capable to address that area, too, as has been proven by Wirths OS. Actually, however, I think it&#8217;s some kind of &#8220;mindset&#8221; issue. I <em>do</em> value Modula, Oberon, and Ada highly but I can&#8217;t help but associate those with Program development &#8211; and C with &#8220;close to the iron stuff&#8221;. It just feels more natural for me to do in C. Speaking in Wirth terms were he has the &#8220;System&#8221; module I go C directly.<br />
And while it always felt strange to trace, say, some client interface application in the debugger, I almost feel &#8220;Hell, why isn&#8217;t the compiler and editor right in the debugger environment?&#8221; when, say, coding some low level stuff on a microcontroller; it&#8217;s just natural there to think and work in bits and registers.</p>
<p><i>&#8220;Don&#8217;t forget D. That project puts in solid work to make a better, safer C++. They deserve some credit. Like you said, though, almost no take up.&#8221;</i></p>
<p>True. But frankly, I feel that D doesn&#8217;t get widely accepted and used for a reason. Looking closer I found the very core, the &#8220;C mindset&#8221; again in D. And in a way they even day it openly. &#8220;We want a better C++&#8221;. Frankly, I&#8217;m afraid, no matter how much one works around that approach one might create an indeed better C++ but one will not achieve to create anything really comparable to the Pascal &#8230; Ada &#8230; Eiffel line. If one <em>could</em> one would end with sth. like Modula or Ada but with C like notation (e.g. braces instead of begin &#8230; end).<br />
Just read their discussions. Yes, for instance, D offers DbC but you&#8217;ll find that a (by heart) C++ programmer (and that&#8217;s what most of them are) has a quite different approach to DbC than and Ada programmer. To put it losely, while DbC was a much welcomed and dearly missed (by many) in Ada (2012) it&#8217;s hardly more than a &#8220;cheap insurance&#8221; concept or, worse, a pimped up assert() for most D guys.</p>
<p>But granted, using D I felt way better than when dealing with C++ and all it&#8217;s, uhum, cousins (Have a look at Cyclone! Nice intention, typical C/C++ look approach).</p>
<p><i>&#8220;Americans invented the first &#8230;&#8221;</i></p>
<p>Oh well, there could be lots of debate there (Germans, for instance, might deservedly bring up Mr. Zuse) but that wasn&#8217;t my point anyway.</p>
<p>Yes, I agree, from what I see, in the usa the marketing push is stronger than across the ocean. French or German developers can be pushed only so far to produce sth. lousy but shiny and (why are they almost always overlooked?) the Russian are very favourably influenced by a very strong academic system and tradition. Actually, I think Russia is among the stronger supporters and users of Modula and Oberon (and probably would use more Ada if it hadn&#8217;t the ugly american dod smell&#8230;). I&#8217;d bet anytime that the quality of Russian code is considerably better than american code (on average).<br />
The French have some kind of &#8220;silicon valley&#8221; with INRIA and Germans probably have a more engineering like approach to code.</p>
<p>To put it in a funny looking way: One very often hears &#8220;it&#8217;s fun!&#8221; in software developer circles. Well, you won&#8217;t lose money placing bets that the ones saying that tend to be americans &#8230;<br />
Generally speaking (and knowing perfectly well that there are exceptions) I tend to trust European software way more and I tend to consider american developers to be &#8220;hackers&#8221; (that&#8217;s <em>their</em> term for themselves, not mine!). To summarize it bluntly I would assume that code from the usa has either been hacked for fun or hacked under marketing pressure. Apologies if anyone feels offended.</p>
<p><i>&#8220;&#8221;My personal preference is Modula/Oberon (although compiler support is thin and for few architectures only) and Ada 2005 (yes, I <em>love</em> 2012).&#8221;</p>
<p>Same here. They seem to make all the right design decisions &amp; are quite versatile.&#8221;</i></p>
<p>Maybe you&#8217;ll laugh at me but the only reason I&#8217;m not purely Ada but am rather almost fighting to use Oberon or Modula is elegance. I consider elegance and beauty to be trustworthy indicators of quality (which might also explain my love for Python for scripting) and I feel that Ada unfortunately feels like considerably less elegant and kind of nailed and hammered together. One reason for that might be Adas tendency to invent new names like &#8220;tagged&#8221; for well understood paradigms and structures. otoh, Ichbiah had a strike of genius when he invented the tick features.</p>
<p><i>&#8220;Funny thing is, I could teach an average C++ programmer how to safely use Modula-like language faster than I could teach them how to write secure C++. I did this more than once. Each time, I pointed it out to them &amp; enjoyed the look on their faces. One also commented that the safer language resembled the pseudocode he wrote and translated into C++. He said using the safer language eliminated most of that mental translation step. All of them also appreciated the near instant compile time as they could develop-compile-run without loosing mental flow. Ah, the joys of a very well-designed language. :)&#8221;</i></p>
<p>Yes, sir. That was well put.</p>
<p>I strongly suggest Mr. Dewar&#8217;s &#8220;lecture&#8221; (actually it&#8217;s more a casual style talk albeit with lots of depth and content) at MIT (<a href="http://www.youtube.com/watch?v=0yXwnk8Cr0c" rel="nofollow ugc">http://www.youtube.com/watch?v=0yXwnk8Cr0c</a>) to anyone seriously interested in solid software development.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220698">

			<div class="comment by-name-withheld-for-obvious-reasons ">

				<p class="commentcredit">

					<span class="commenter">name.withheld.for.obvious.reasons</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220698">
						April 24, 2014 1:49 PM					</a>

				</p>

				<p>@ Nick P, Pragma</p>
<p>The two of you represent what I would considered the &#8220;most&#8221; useful deliberation on programming and security. Notice, I didn&#8217;t phrase it as secure programming&#8211;that&#8217;s an oxymoron. Secure programming is not necessarily a centrality of any &#8220;secure&#8221; system. Recently a friend asked me if he was a risk for subjugation via a form on some web site&#8230;</p>
<p>I said, &#8220;Go to your computer, locate the cable that is approximately a 1/4&#8243; wide (6mm) that is either black, white, or a light tan. Follow it to the termination point, typically a wall, and immediately pull it out!&#8221;</p>
<p>There&#8211;now you&#8217;ve secured your system. (And still, there is a, albeit highly unlikely, risk of subversion.)</p>
<p>I noticed that Smalltalk is absent in the broad scope of tools for systems programming&#8230;there was an effort over a decade ago to get Smalltalk on embedded computing platform. But, just as I see Java as problematic, (sorry Nick P, I see the whole java eco-system as problematic&#8211;even with a JVP&#8211;it has created the same bad habits that C was known to do). Smalltalk shares what I see as problematic with VM cores. I don&#8217;t mean VM in the hardware sense, but in the sense of runtime cores that support some language/application environment.</p>
<p>In engineering there is always the compromise&#8211;I don&#8217;t care what technology or platform is selected, defined, utilized, or embraced&#8211;the architectural decisions that are visible at the &#8220;customer&#8221; level are always a compromise. Why, just as Bruce has said and is his mantra&#8211;there is no absolute security.<br />
Expectations almost never match reality&#8211;I call it &#8220;Engineering Relativity&#8221;.</p>
<p>I don&#8217;t have a &#8220;solution&#8221; for a problem that I and most of my colleagues didn&#8217;t create&#8211;or even know about. This kind of architectural hijacking by entities that represent &#8220;institutional&#8221; trust is a beast I didn&#8217;t envision battling as a young child embracing the religion of science as the the only true path. What a fool was I? What I do know, we are getting nowhere&#8211;the amount of progress that represents are &#8220;re-balancing&#8221; is nothing more than intellectual masturbation. Don&#8217;t get me wrong, I&#8217;m a big fan of masturbation, I just have a hard time getting my mind out of my trousers.</p>
<p>A year later and the broad scope of security issues that we KNOW about are still at issue&#8230;I need to go and read a EULA to remind me of the source of the problem. My rant for the week&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220699">

			<div class="comment by-mr-pragma ">

				<p class="commentcredit">

					<span class="commenter">Mr. Pragma</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220699">
						April 24, 2014 5:25 PM					</a>

				</p>

				<p>I&#8217;d like to add a point.</p>
<p>It&#8217;s about barriers and about them being mis-designed and misplaced.</p>
<p>Security &#8211; at least from one perspective &#8211; can be described as denying an attacker the means to attack (which again can be broken down into extending the time needed for attack, lowering the probability of success etc. but let&#8217;s stay simple here).<br />
So, a vulnerability is a means of (illegitimate) access and so is, say, (in a way) a properly secured and locked door with a window next to it that is made from soft wood and that lacks any security measures.</p>
<p>Accordingly, one way to &#8220;create&#8221; security is to <em>not</em> create weaknesses that offer means of illegitimate access.</p>
<p>Who is the foe and what is an attack? An attack can be described as an improper way of gaining access and a foe is anyone who employs methods to improperly gain access.<br />
But what if improper access is gained without malice intent? What if, stupid example, my trousers have a hole and I&#8217;m losing money while walking? What if a woman undresses for bed and doesn&#8217;t properly block any means of sight into the room?</p>
<p>Now, we&#8217;re pretty close to programmers &#8211; unintentionally &#8211; creating weaknesses which sooner or later will be used as means for improper access (or operations, or &#8230;).</p>
<p>Obviously, the woman should close the curtain properly and fully and so should the programmer. So why does neither of them always, reliably and fully? Is it the womans kink to be observed while undressing? Is it the programmers rational decision to create backdoors? Quite probably not &#8211; yet they do exactly that.</p>
<p>Or, to put it more bluntly, there is a trust problem namely, the problem to trust programmers that they are willing and capable to really fully understand each and every of their lines of code and to invest no matter what energy and means to code perfectly. Are they willing to do that? Quite possibly usually, yes. Are they capable to do that? Quite obviously frighteningly often, no.</p>
<p>To cut it short, an OS expecting the user (or program) to behave correctly, reliably and responsibly, got something very wrong. Maybe that approach would on another planet (like the one where those C/C++ developers who think they can and do create good code live *g).</p>
<p>Similarly, a language designer expecting the user, the developer, to behave correctly, reliably and responsibly, got something very wrong.<br />
Realistically &#8211; and having profoundly understood some human properties &#8211; a language designer has to assume that his &#8220;users&#8221; can &#8211; and will &#8211; engage in improper use of his language.</p>
<p>Finally (ignoring more steps in between) a developer expecting his users  to behave correctly, reliably and responsibly, got something very wrong.<br />
Realistically &#8211; and having profoundly understood some human properties &#8211; a developer has to assume that his &#8220;users&#8221; can &#8211; and will &#8211; engage in improper use or even abuse of his program &#8211; not rarely even with malice intent.</p>
<p>Accordingly, developers have to base their work on the assumption that, be it with malice intention or just incompetence or due to other factors (and there are many with humans &#8230;), their users (and often even the users/clients of their users; just think -&gt; server) can &#8211; and <em>will</em> misuse or even abuse their software.<br />
And so do Operating Systems. To achieve any not insignificant level of safety, reliability and security, their creators have to base their work on the assumption &#8230; can &#8211; and <em>will</em> misuse or even abuse their software.<br />
And finally, so do language designers &#8211; and the wiser ones did. They have to base their work on the assumption &#8230; can &#8211; and <em>will</em> misuse or even abuse their language.</p>
<p>Last but not least we should considerably extend our understanding by recognizing and acting accordingly. Usually we still think of a security problem in term of evil, dark dressed attackers. Actually though, a very considerable part of security problems do not arise out of malicious attacks but are based on negligence, easy going, opportunity; accordingly they can not be avoided by building ever stronger vault doors or, in computer terms, by ever stricter security regimes, by adding CAP facilities on top on MAC, etc. &#8211; but by <em>additionally</em> avoiding the unintentional creation of, in effect, back doors.</p>
<p>To put it bluntly: No matter how many new security regimes we invent, create (probably in C/C++/java &#8230;), and deploy, we can and will not stop the security bleeding using the very tools and paradigms that created them in the first place.</p>
<p>Stop using C/C++/java &#8211; or be hacked. Simple as that.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220700">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220700">
						April 24, 2014 10:39 PM					</a>

				</p>

				<p>@ Mr Pragma</p>
<p>re C</p>
<p>I meant about what you meant, despite using only one sentence. It&#8217;s quite useful for what it was designed to do even to this day &amp; has a ton of tool support + expertise. The need for such things is why I like developments such as Cyclone, Typed Assembler, LLVM, etc. Gives us alternatives to C to solve this problem. For instance, ignoring syntax risks, C forces a certain structure on your program that might pose risks upon integration with a safer HLL (e.g. infamous Ada-C linking vulnerability). Coding directly in assembler or something else ultra low level + efficient might avoid this.</p>
<p>I&#8217;ve even considered coding in LLVM assembler, compiling that to whatever ASM I&#8217;m using, &amp; integrating it inline in a safe language for performance critical part. That&#8217;s cross-platform, low level, easily optimized code without C&#8217;s structural decisions. C &amp; an FFI is certainly an easier option, yet I figured I could throw a tool together that automates hard parts of the LLVM option. Also, high level assemblers such as Hyde&#8217;s <a href="http://en.wikipedia.org/wiki/High_Level_Assembly" rel="nofollow ugc">HLA</a> &amp; <a href="http://en.wikipedia.org/wiki/Linoleum_(programming_language)" rel="nofollow ugc">Linoleum</a> have promise if further developed.</p>
<p>While your at it, check out PL/S. It&#8217;s a PL/I variant without a runtime that IBM uses for mainframe OS development. They&#8217;ve improved on it for years and consider it a trade secret of sorts. Here&#8217;s one <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=0CDYQFjAC&amp;url=http%3A%2F%2Fbitsavers.trailing-edge.com%2Fpdf%2Fibm%2F360%2Fpls%2FGC28-6794-0_PLSIIguideMay74.pdf&amp;ei=jMZZU6u4Gs3eyAHVgoDYDg&amp;usg=AFQjCNEYBE_oSUIThT4hW3oudu_AXAF0Vw&amp;bvm=bv.65397613,d.aWc" rel="nofollow ugc">paper</a> describing it. The cool thing about it is it&#8217;s still quite high level, yet it lets programmer specify per function how compiler handles certain things. So, it can be extremely efficient, safe, or some combo between. Also supports two different kinds of inline assembler according to one source.</p>
<p>&#8220;But frankly, I feel that D doesn&#8217;t get widely accepted and used for a reason. Looking closer I found the very core, the &#8220;C mindset&#8221; again in D.&#8221;</p>
<p>That&#8217;s the point. The safer languages didn&#8217;t replace C/C++. The one&#8217;s that did have takeup are too inefficient. So, it&#8217;s kind of a compromise where C/C++ people create a language they hope C/C++ people will like that&#8217;s quite efficient. This is case for D, Cyclone, and Ironclad C++. I&#8217;m not advocating these over better options. But, I do give them credit for taking initiative to win C/C++ crowds over &amp; getting rid of some big problems in C/C++.</p>
<p>&#8220;Frankly, I&#8217;m afraid, no matter how much one works around that approach one might create an indeed better C++ but one will not achieve to create anything really comparable to the Pascal &#8230; Ada &#8230; Eiffel line.&#8221;</p>
<p>I agree with that. Plus, I hate people reinventing the wheel. If they want to exceed those safe languages, go right ahead. <a href="http://lambda-the-ultimate.org/deca" rel="nofollow ugc">DECA</a> and <a href="http://hasp.cs.pdx.edu/habit-report-Nov2010.pdf" rel="nofollow ugc">Habit</a> come to mind. If they want to bring their C++ garbage in feature parity, it&#8217;s a waste of effort. They&#8217;re better off being clever bringing the safe languages into performance, tool, and library parity. <em>That</em> would be quite beneficial. I also like your &#8220;pimped up assert&#8221; comparison. Haha.</p>
<p>re Americans invented first</p>
<p>The point was less on absolute first and more to just show Americans have been pulling their weight on the issue for a while with many great contributions. That&#8217;s all I was saying. Over here (and in general), quality and security are still minority players in software market. So, much of America&#8217;s best work goes unused and, worse, unremembered by industry as a whole.</p>
<p>One example. I love listening to aspiring secure coders talk about canaries and other clever methods of dealing with stack overflow issues. Then, I point out MULTICS beat all the stuff by simply making stack flow <em>away</em> from control flow pointer. The &#8220;Holy S***&#8221; moment on their faces is priceless. Yet, it&#8217;s also sad as not one has ever heard that stacks can be made immune to overflow or even figured out the obvious themselves. &#8220;Why do we make attacker data flow toward the critical location?&#8221; The question never asked. Many, many, many things like this over here. World-wide, too, far as I know.</p>
<p>&#8220;Yes, I agree, from what I see, in the usa the marketing push is stronger than across the ocean. French or German developers can be pushed only so far to produce sth. lousy but shiny and (why are they almost always overlooked?)&#8221;</p>
<p>Interesting. At least I give them credit as often promote both TU Dresden (TUDOS projects) and INRIA&#8217;s work. Great work at both.</p>
<p>&#8220;the Russian are very favorably influenced by a very strong academic system and tradition. Actually, I think Russia is among the stronger supporters and users of Modula and Oberon (and probably would use more Ada if it hadn&#8217;t the ugly american dod smell&#8230;). I&#8217;d bet anytime that the quality of Russian code is considerably better than american code (on average).&#8221;</p>
<p>I didn&#8217;t know they used Modula and Oberon much over there. Matter of fact, now that you said it, I recall some Russian forums on the use of <a href="http://en.wikipedia.org/wiki/BlackBox_Component_Builder" rel="nofollow ugc">Blackbox Component Builder</a> for Component Pascal (Oberon successor). So, they&#8217;re using it and on the cutting edge of it.</p>
<p>It&#8217;s known that Russian programmers are skilled. The clever malware writers are often Russian &amp; continually invent clever tricks. The reason, though, might not just be education or culture. One Russian programmer said people often get only limited access to computers. (Cafes? Colleges?) There&#8217;s only so much time to type in the code, test it, and so on. So, he said Russians put much more effort into getting the code right the first time. Reminds me of the old batch processing systems here in the States where a single mistake might throw a whole, expensive batch. They started inventing language constructs and strategies to make them less likely. The Russians seem to be doing the same, yet with modern hardware and tools. Quite a powerful combination.</p>
<p>&#8220;Generally speaking (and knowing perfectly well that there are exceptions) I tend to trust European software way more and I tend to consider american developers to be &#8220;hackers&#8221; (that&#8217;s <em>their</em> term for themselves, not mine!).&#8221;</p>
<p>Ouch. We do have shops that focus on quality, even warranting code. That is <em>not</em> the majority by far. 🙁 Most are what Clive Robinson calls &#8220;code cutters&#8221; that just throw stuff together, hope it works, fix what they could that didn&#8217;t, and ship it. Industry focuses on shipping because customers demand it. Bugs get fixed over time. Note that I&#8217;ve seen the same thing over in Europe. Example is Windev in France: great tool at boosting productivity, yet has crapload of bugs that each take years to get fixed per users on their forums.</p>
<p>So, American software is only trustworthy if it&#8217;s from a shop that focuses on quality. That&#8217;s rare as it costs more &amp; takes longer to make. I appreciate your opinion on the Europeans and I plan to get more data on it in the future. I was even considering specific countries over there for subversion-resistant development due to culture maybe having a positive influence on the process.</p>
<p>re Ada, elegance</p>
<p>I understand the feeling, yet disagree. Elegance is usually a sign of good design. Yet, the real world often forces tough tradeoffs for optimal behavior. Scheme was elegant, but Common LISP was more useful in practice. Haskell was more elegant, yet Ocaml provided many of it&#8217;s benefits with faster execution &amp; easier training. So, I&#8217;ll trade away elegant if it&#8217;s practical to not be elegant.</p>
<p>Funny you mention tagged because the first time I saw that I said &#8220;wth is wrong with these people? why don&#8217;t they just call it what everyone does!?&#8221; I thought about rewriting some of that stuff just to make it use the real thing. Then, I looked at the complexity of an Ada compiler and changed my mind.</p>
<p>re Dewar lecture</p>
<p>I&#8217;ll try to check it out.</p>
<p>re expectations of OS, developer and user</p>
<p>Good points. These bad assumptions keep recurring.</p>
<p>&#8220;To put it bluntly: No matter how many new security regimes we invent, create (probably in C/C++/java &#8230;), and deploy, we can and will not stop the security bleeding using the very tools and paradigms that created them in the first place. Stop using C/C++/java &#8211; or be hacked. Simple as that.&#8221;</p>
<p>Nice. I add &#8220;unsafe architectures&#8221; while we&#8217;re at it.</p>
<p>@ name.withheld</p>
<p>&#8220;The two of you represent what I would considered the &#8220;most&#8221; useful deliberation on programming and security.&#8221;</p>
<p>Why thank you! 🙂</p>
<p>&#8220;I said, &#8220;Go to your computer, locate the cable that is approximately a 1/4&#8243; wide (6mm) that is either black, white, or a light tan. Follow it to the termination point, typically a wall, and immediately pull it out!&#8221;</p>
<p>Haha. There was <a href="http://www.dumbentia.com/pdflib/scissors.pdf" rel="nofollow ugc">this</a> old method.</p>
<p>&#8220;I noticed that Smalltalk is absent in the broad scope of tools for systems programming&#8230;&#8221;</p>
<p>I left it off on purpose. I wasn&#8217;t sure if it was useful for low-level, efficient, systems programming. I did go back and consider it for web applications, yet the web frameworks weren&#8217;t so impressive compared to others on the list. So, I just dropped it.</p>
<p>&#8220;But, just as I see Java as problematic, (sorry Nick P, I see the whole java eco-system as problematic&#8211;even with a JVP&#8211;it has created the same bad habits that C was known to do). &#8221;</p>
<p>No need to apologize. I&#8217;m not a Java fan. I do like the work on Java processors as they might allow efficient, type-safe system code with object support at instruction level. And half a dozen exist <em>right now</em> unlike both of our projects. I also noted that there&#8217;s secure kernels and OS architectures, plus great static checkers for it. Seemed promising as an interim solution.</p>
<p>My plan was to make a core runtime in pure assembler language behind an interface, then map Modula/Oberon to the Java processor bytecode. Oberon to Java &amp; a JVM on Oberon were both already done so this should be easy. Juice also did a Java applet alternative that sent Oberon abstract source tree&#8217;s, which were typechecked &amp; compiled locally. That in a capability architecture on a Java processor might be ridiculously robust compared to mainstream alternatives. The result would be a Wirth-like language used to program a relatively safe machine for low level, high level and web programming.</p>
<p>(Note: Ada to JVM has also been done. That would be the next step. Then, I could use an architecture like JX, SPIN, etc with Ada&#8217;s or SPARK&#8217;s type checking and no VM with huge attack surface.)</p>
<p>&#8220;I don&#8217;t mean VM in the hardware sense, but in the sense of runtime cores that support some language/application environment.&#8221;</p>
<p>It&#8217;s fine if it&#8217;s easy to analyze. Those language&#8217;s VM/runtimes aren&#8217;t. They&#8217;re too big with designs that allow native code, esp in libraries, to end run the type system. So, I don&#8217;t like them either. One exception is Lua as they kept theirs as simple as possible. So simple and consistent it might work without 100+ security holes.</p>
<p>&#8220;In engineering there is always the compromise&#8211;I don&#8217;t care what technology or platform is selected, defined, utilized, or embraced&#8211;the architectural decisions that are visible at the &#8220;customer&#8221; level are always a compromise.&#8221;</p>
<p>It sucks. The legacy problem is the biggest of all. I have no easy solution there except to secure what I can and have intrusion analysts carefully watch the rest.</p>
<p>&#8220;Don&#8217;t get me wrong, I&#8217;m a big fan of masturbation, I just have a hard time getting my mind out of my trousers.&#8221;</p>
<p>LOL. Most presenters &amp; audience members at DEFCON, Black Hat and RSA are big fans of mental masturbation. So, no worry about standing out too much long as you keep it mental.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220701">

			<div class="comment by-mr-pragma ">

				<p class="commentcredit">

					<span class="commenter">Mr. Pragma</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220701">
						April 25, 2014 7:10 AM					</a>

				</p>

				<p>@name.withheld</p>
<p>Thank you 😉</p>
<p>@Nick.P</p>
<p>Ad Assemblers, LLVM:</p>
<p>I&#8217;m not so sure about assemblers. They are by definition bound to an architecture and I also fail to see the advantage of using yet higher level assemblers. Maybe I&#8217;m just a little old style and pragmatic but if that kind of close to the iron is needed I&#8217;d rather use C, the meta assembler, and, if needed, hand-optimize its output.</p>
<p>There&#8217;s actually more to it (well, in <em>my</em> head, that is. ymmv). My rule of thumb is that actually we humans are way better in optimizing than computers; they otoh are just great in reliably and (with anal precision) doing what we humans tend to do not so well (like finding 10.000 occurrences of a string and not missing 1). I remember hand-optimizing the assembler output of the C compilers for some routines and achieving an improvement I&#8217;d rather not tell you so as to not be considered bragging. In simple words: We humans, at least often <em>can</em> very much optimize. But then, that&#8217;s rarely justified and the mere decision what and where to optimize is a good level of expertise and craftsmanchip.</p>
<p>As for LLVM I&#8217;m inclined to be quite enchanted. The idea is great, I love it. My only reservation about LLVM is based on the language it&#8217;s coded in and consequently the question of reliability and trustworthyness.</p>
<p>But, no doubt, those guys have had a very striking and brilliant idea and along the path they&#8217;ve made some very good and bright decisions (the interim-code, the dual exe and interpreted offer, and some more and all that well thought out down to &#8220;details&#8221; like data types and very flexible). Praised be they!</p>
<p>Ad &#8220;D, Cyclone, and Ironclad C++&#8221;:</p>
<p>Well, for a starter, D still has rather limited library support and that&#8217;s the or at least a major holy grail in the C/C++ world (explaining in part its slow take up).<br />
Find me a C/C++ guy who doesn&#8217;t blow the &#8220;C/C++ has the most libraries available&#8221; fanfare when looking at language alternatives and I show you a man that can still be shown the light and whose brain hasn&#8217;t turned into stone yet *g</p>
<p>And btw. I think, the libraries point is extremely short sighted and exaggerated.<br />
For (at least) 2 reasons:<br />
&#8211; Modula, Oberon, Ada, Eiffel and particularly Pascal certainly don&#8217;t arrive naked. They are stuffed with quite well sized libraries and on top usually allow you to use C libraries, too</p>
<ul>
<li>What&#8217;s the worth of a gazillion of libraries if many of them are written by &#8220;have fun!&#8221; 14 years old experimenters and even the well established ones can&#8217;t be trusted?! Need I offer a hint to openssl again?</li>
</ul>
<p>Oberon and Ada may offer way less libraries but what you get can be trusted to a large degree. Ok, The Pascal GUI thingies are of lesser quality but then that&#8217;s just GUI thingies anyway. And you know what? I use Freepascal/Lazarus for GUI thingy stuff anyway because I trust that way more than, say, gtkAda; I trust the Ada part but I definitely don&#8217;t trust the gtk part (and gnome is to be avoided like rattlesnakes on crack).</p>
<p>Usually when I&#8217;m confronted with &#8220;But C/C++ has gazillions of libraries!&#8221; my response is short: &#8220;And as many bugs. Thanks, no&#8221;</p>
<p>Ad &#8220;Habit and high security language&#8221;:</p>
<p>Frankly, I consider that approach as yet another example of &#8220;Let&#8217;s build an even stronger vault door!&#8221; (for a thin walled wooden box).</p>
<p>Pretty much all security related problems we experience don&#8217;t arise out of doors being to weak but out of carton or thin wooden walls, or in computer lingo, out of crappy code.</p>
<p>Even evil attackers do <em>not</em> successfully attack systems because these systems have been built properly but, alas, there were 10 minor errors in 5 mio lines code. The entry points that are attacked are plenty and they are created plentiful by crappy code.</p>
<p>Let me offer OpenBSD as an example. OpenBSD is (at least mainly) coded in C. And most of it is rather old code. And it&#8217;s a Unix. Yet it&#8217;s &#8211; rightfully &#8211; considered secure (well, for a standard OS and compared to other standard OSs).</p>
<p>How come? Because they <em>do care</em> about reliability and security for a start. Because they aren&#8217;t about politics (GPL, bazar, democracy in engineering, more women in IT, bla bla) but about engineering. Because they damn know what they do and they carefully select who gets writing access and they have a very capable benevolent dictator.<br />
And because it&#8217;s not at all a coincidence that it was the OpenBSD guys who immediately reacted a) panicked and b) constructive and c) professional to heartbleed. While the rest of the world convened gremia and conferences and discussed and blabla&#8217;d the OpenBSD guys reacted properly and did the thing that was to be done.</p>
<p>I could vomitt seeing that OpenBSD does the shitwork while the lisucks foundation is celebrated for politicising and monetizing the openssl disaster.</p>
<p>Boeing and Airbus do, but we generally do not need anal panic perfection. Our problem isn&#8217;t 1 error per 1 mloc. Our problem is x error per 1 kloc. Our problem is x * n errors in our code, the libraries, the servers, the OSs.<br />
Accordingly the solution isn&#8217;t &#8220;something even more anal than Ada/Spark&#8221; but &#8220;something less crappy and error prone than C/C++/java/php/perl&#8221;. In other words: We can quite quickly achieve a <em>way, way more secure</em> digital world by coding in Modula, Pascal, Oberon, Ada, Eiffel, Erlang, Ocaml, etc.</p>
<p>And yes, let&#8217;s enhance formal verifiability for Ada, Oberon, Ocaml and let&#8217;s create even better unit test facilities and support, etc.</p>
<p>Bluntly put my point is: Currently we use trouble generators to produce software and we use quite good quality tools/languages for high reliability/safety/security systems.<br />
How about using decent languages instead of trouble generators to produce the 90% of software that is not highly sensitive and to even further enhance the excellent language/tools like Ada and Oberon for critical systems?!</p>
<p>Ad &#8220;Ada and elegance&#8221;:</p>
<p>Sorry, no. There is <em>no</em> reason for Ada to invent yet another bunch of terms for well established ones. Similarly there was no bloody reason for Wirth to carry over the ugly and cumbersome (* &#8230; *) comment notation up to Oberon. Neither was there reason for Ada, even later versions, to stubbornly stick to their single line comments only attitude. &#8220;&#8211;+&#8221; almost begs for indicating multiline comments (or commenting out code sections).</p>
<p>Ad &#8220;Dewar video&#8221;:</p>
<p>Oh, that wasn&#8217;t directed at you but rather as a general rather short, very convenient and casual yet valuable and insightful primer/reminder.</p>
<p>Ad &#8220;my own language (version) / tool chain / similar&#8221;:</p>
<p>I strongly advise against that. It requires way more expertise, craftsmanship, some magic, and major amounts of time and resources to do that <em>properly</em>. And there is no need. IMO those resources/time/abilities would be better put at things like paranoically verifying LLVM (or transcoding it to e.g. Ada), porting a modern version of Oberon to more architectures, implementing ssl in Oberon or Ada, etc. etc.</p>
<p>Or, if you aren&#8217;t easily frightened <em>g</em> you could design and implement a good mixture of Oberon (OS) and Unix in e.g. Ada.</p>
<p>Why? Because the whole chain is rotten. Unix is, the servers are, and the libraries are. And that chain is the <em>massive</em> iceberg of virtually all existing systems. That&#8217;s on what your Oberon, Ada, Ocaml software runs on. No matter how well designed and implemented your, say, online shop server is; it&#8217;s doomed to be an open gaping security vulnerability because of that iceberg.</p>
<p><i>&#8220;&#8221;</i></p>
<p><i>&#8220;&#8221;</i><br />
<i>&#8220;&#8221;</i></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220702">

			<div class="comment by-my-name-is-not-important ">

				<p class="commentcredit">

					<span class="commenter">my name is not important</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220702">
						April 25, 2014 2:16 PM					</a>

				</p>

				<p>@Thierry:</p>
<p><i>&#8220;Sadly this report only mentions languages for Web sites and not for general purpose development. OpenSSL + C == Heartbleed&#8230;&#8221;</i></p>
<p>No. OpenSSL + lazy coders -&gt; Heartbleed. Would you say OpenBSD, mostly written in C, is unsecure?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220703">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220703">
						April 25, 2014 3:05 PM					</a>

				</p>

				<p>@ my name is not important</p>
<p>&#8220;Would you say OpenBSD, mostly written in C, is unsecure?&#8221;</p>
<p>Yes I <a href="http://www.cvedetails.com/vulnerability-list/vendor_id-97/Openbsd.html" rel="nofollow ugc">would</a>. They&#8217;re certainly not secure. Although, they are better than any other group at preventing and fixing software defects in a C-based, monolithic OS.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220704">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220704">
						April 25, 2014 4:38 PM					</a>

				</p>

				<p>@ Mr Pragma</p>
<p>&#8220;I&#8217;m not so sure about assemblers. They are by definition bound to an architecture and I also fail to see the advantage of using yet higher level assemblers. Maybe I&#8217;m just a little old style and pragmatic but if that kind of close to the iron is needed I&#8217;d rather use C, the meta assembler, and, if needed, hand-optimize its output.&#8221;</p>
<p>A secure system is <em>always</em> tied to the architecture. The architecture is where security-enhancing abstraction gaps often break down. You mentioned using C for these parts, yet we&#8217;ve already talked about how dangerous it is. It would be nice to have a safe way to code these components that&#8217;s low level, efficient, &amp; supports some safety assurances. Cyclone, Popcorn+TALx86, <a href="http://www.irit.fr/~Martin.Strecker/Publications/c0compil.pdf" rel="nofollow ugc">C0</a> from Verisoft, and so on support low level programming with increased safety. So, that&#8217;s why I&#8217;m keeping them in mind.</p>
<p>One thing I&#8217;m considering is picking an architecture with nice properties, building a safe low-level VM + OS kernel on it, targetting something like Oberon to that, and then building the rest modularly in that typed language. Microsoft&#8217;s Verve OS, the Modula 3 SPIN OS, &amp; the Java JX OS make me think it&#8217;s doable. My concern here is to essentially raise the assembler up to something safer, then code everything in entire system in that from drivers to apps so they all integrate into same security/integrity scheme. Otherwise, attackers will just hit lowest layer &amp; will have plenty to hit.</p>
<p>&#8220;As for LLVM I&#8217;m inclined to be quite enchanted. The idea is great, I love it. My only reservation about LLVM is based on the language it&#8217;s coded in and consequently the question of reliability and trustworthyness.&#8221;</p>
<p>It&#8217;s definitely a concern. Might be fixed later. My old method would be to implement the stages in Standard ML, then compile <em>that</em> to executable with FLINT certifying compiler. Results in safe &amp; correct code. Yet, many prefer hand-optimization opportunities and I prefer control over how compiler handles each thing to avoid compiler introducing vulnerabilities.</p>
<p>So, I draw on an old idea: VLISP. It was a rigorously verified Scheme 48 interpreter &amp; compiler for x86, PPC, and ARM. The idea with VLISP would be to implement the compiler stages in SML or Ocaml for algorithmic correctness first, then convert each to VLISP procedures. The builder uses the REPL to interact with the compiler. You could, say, create a compilation profile with certain options for certain modules &amp; tell it to compile. Then, you might review or even edit the results of that before feeding it to next compiler stage. That a LISP gives total access to internal state &amp; allows one to change programming live means more options like these could be created. The use of VLISP means it will be done correctly.</p>
<p>&#8220;Usually when I&#8217;m confronted with &#8220;But C/C++ has gazillions of libraries!&#8221; my response is short: &#8220;And as many bugs. Thanks, no&#8221;&#8221;</p>
<p>Lol</p>
<p>&#8220;Frankly, I consider that approach as yet another example of &#8220;Let&#8217;s build an even stronger vault door!&#8221; (for a thin walled wooden box).&#8221;</p>
<p>Hardly. In Habit&#8217;s case, they know the low level stuff is where many of the problems are. So, they started with Haskell, built an OS in it (House), and are applying what they learned to a Haskell variant (Habit) designed specifically for low level coding &amp; assurance activities. They also found a sweet spot (H-Layer) for separation of safe and unsafe constructs, while maintaining a protected interface between the two.</p>
<p>If anything, writing most or all code in a such a way boosts many properties at once. OpenBSD you reference has had over 200 security issues. Many are impossible in Haskell, with others maybe being minimized. So, much like Ada or Modula boost safety over C, there are languages with even more advanced type systems trying to take it to next level. Habit/Haskell is one line of inquiry. There&#8217;s others, but they&#8217;re too alpha quality to name.</p>
<p>&#8220;Because they <em>do care</em> about reliability and security for a start. Because they aren&#8217;t about politics (GPL, bazar, democracy in engineering, more women in IT, bla bla) but about engineering. Because they damn know what they do and they carefully select who gets writing access and they have a very capable benevolent dictator.&#8221;</p>
<p>&#8220;And because it&#8217;s not at all a coincidence that it was the OpenBSD guys who immediately reacted a) panicked and b) constructive and c) professional to heartbleed. While the rest of the world convened gremia and conferences and discussed and blabla&#8217;d the OpenBSD guys reacted properly and did the thing that was to be done.&#8221;</p>
<p>These are quite true, though. The attitude, controls, and commitment of the team results in plenty of good quality/security decisions.  Their response to Heartbleed was sheer excellence. The dedication was quite obvious with 100+ commits a week. My jaw dropped when I saw all that activity.</p>
<p>&#8220;Accordingly the solution isn&#8217;t &#8220;something even more anal than Ada/Spark&#8221; but &#8220;something less crappy and error prone than C/C++/java/php/perl&#8221;. In other words: We can quite quickly achieve a <em>way, way more secure</em> digital world by coding in Modula, Pascal, Oberon, Ada, Eiffel, Erlang, Ocaml, etc.&#8221;</p>
<p>I agree. However, I do want these more anal languages + tools for at least the core kernels, runtimes, and interfaces that underly the &#8220;less crappy&#8221; languages you mentioned. I also prefer an incremental option: implement critical component using something decent right now, then improve its assurance with the over-the-top methods later if it&#8217;s justified. For the core kernels, runtimes, and/or compiler validators, it would seem quite justified to design them with that in mind.</p>
<p>&#8220;And yes, let&#8217;s enhance formal verifiability for Ada, Oberon, Ocaml and let&#8217;s create even better unit test facilities and support, etc.&#8221;</p>
<p>Good news is there&#8217;s plenty potential. The Ada people are leading with their Ada 2012 and SPARK 2014 standards. Ocaml&#8217;s compiler was engineered in stages well enough that a DO-178B tool was written in Ocaml with supposedly easier source to machine code validation. (Manual in DO-178B). Modula&#8217;s standard library was formally verified free of certain defects. So, there&#8217;s been efforts &amp; I also hope that more come about.</p>
<p>&#8220;How about using decent languages instead of trouble generators to produce the 90% of software that is not highly sensitive and to even further enhance the excellent language/tools like Ada and Oberon for critical systems?!&#8221;</p>
<p>Exactly!</p>
<p>&#8220;IMO those resources/time/abilities would be better put at things like paranoically verifying LLVM (or transcoding it to e.g. Ada), porting a modern version of Oberon to more architectures, implementing ssl in Oberon or Ada, etc. etc.&#8221;</p>
<p>It&#8217;s a good point I&#8217;m debating with myself over. My suggestion to name.withheld was that I port Modula/Oberon to an existing processor that&#8217;s safer at instruction level with hardware POLA support (eg object descriptors). Main candidates are a Java processor (without the Java), SAFE processor (tagged &amp; high level), CHERI processor (segmented MIPS), or Itanium (memory keyed). Might then retarget something like SPIN OS, JX architecture, EROS kernel, or Active Oberon System to it. Whole effort would be <em>way</em> less work than a full OS, secure ISA, etc. Then, could build on this medium assurance system using safe language code with protections on. Unsafe code, where necessary, can be isolated in modules/segments and thoroughly analyzed.</p>
<p>&#8220;Why? Because the whole chain is rotten. Unix is, the servers are, and the libraries are. And that chain is the <em>massive</em> iceberg of virtually all existing systems.&#8221;</p>
<p>I agree. It&#8217;s why I&#8217;ve mostly avoided UNIX in my discussions as I&#8217;m not sure designing a secure UNIX can be done. The UCLA Secure UNIX project found all sorts of issues in it. That&#8217;s when you could describe it&#8217;s system calls in an academic paper rather than a book. 😉 Microkernel designers and CHERI/Capsicum are doing fine work on securing UNIX-type systems so I&#8217;ll leave it to them. I&#8217;m looking into system designs that are more assurable. The less work the better because this kind of thing becomes a LOT of work &amp; luck, as you&#8217;ve pointed out.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220705">

			<div class="comment by-david-thornley ">

				<p class="commentcredit">

					<span class="commenter">David Thornley</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220705">
						April 25, 2014 5:43 PM					</a>

				</p>

				<p>To defend C and C++ here:</p>
<p>If the Wikipedia article is accurate (and it agrees with other things I have read), it worked like this:</p>
<ol>
<li>The heartbeat request is received with short text and big character count.</li>
<li>OpenSSL then gets enough memory for the character count, not bothering to zero out the extra memory.  It copied the text into that space.</li>
<li>OpenSSL then wrote out the memory with the character count, including the text and who knows what else.</li>
</ol>
<p>This is not a buffer overflow (although such things are annoyingly hard to prevent in C).  This is an uninitialized memory exploit.</p>
<p>Does anybody else feel nervous when, in a security application, anything gets hold of uninitialized memory?  You never know where it&#8217;s been.  If the allocated memory had been zeroed out, all a heartbleed request could get is a whole bunch of zeros, less than useful when hacking a system.</p>
<p>In other words, all the OpenSSL people had to do to avoid this was to use the function calloc() instead of the function malloc(), since calloc() zeros memory.  (There&#8217;s other ways to do it, such as memset(), but calloc() is easy, and you can easily search the program for &#8220;malloc&#8221; and correct every occurrence).  (Assuming, of course, that they bothered to put calloc() into the nonstandard memory manager they wrote themselves and relied on.)  In C, for all its faults, there was a way to prevent heartbleed was a style rule that could be enforced with a text editor.  Given that the OpenSSL people botched that, I wouldn&#8217;t trust them not to screw up Ada.</p>
<p>As far as C++ goes, I distrust anybody who uses &#8220;C/C++&#8221;, since they usually are thinking of them as similar languages.  C++ started as C with Simula 67 classes bolted on, but it&#8217;s evolved far beyond that.  As an example, I&#8217;m going to show how to avoid buffer overruns with a C++ style guide.  (I&#8217;m ignoring multithreading here, as it is possible to create an overflow with a race condition with the simplified instructions I&#8217;m giving.)</p>
<p>Do not use arrays or null-terminated strings.  Just don&#8217;t.  Use only C++ containers and strings from the standard libraries (you can supplement the containers, just don&#8217;t use anything that isn&#8217;t bounds-checked).  As the second part of this, do not use &#8220;[]&#8221; for subscripting.  That may or may not be bounds-checked.  Use &#8220;.at()&#8221; for subscripting; that is guaranteed to throw an exception if it&#8217;s out of bounds.  Finally, never do pointer arithmetic.  There:  no buffer overflows, using a purely syntactic style guide.  (Some APIs, particularly those involving C, do require C-style strings and arrays.  Pass data with the .data() or .c_str() calls, and when you receive such data wrap it up in the appropriate container immediately.)</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220706">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220706">
						April 25, 2014 7:03 PM					</a>

				</p>

				<p>What surprises me is people talking about &#8220;Secure Languages&#8221; as though they exist&#8230; they don&#8217;t, plain and simple.</p>
<p>If you look at the computing stack, you will see the name of the game from the lowest levels upwards is abstraction. However there is a price to pay in that at each level of abstraction you become progressivly more constrained and thus successivly less flexible in what you can conveniantly do.</p>
<p>We tend to talk of assembler being the lowest level language, it&#8217;s not by a long way. Assembler is defined by the CPU microcode, that in turn is defined by the available RTL, which in turn is based on logic macros etc etc.</p>
<p>And if you know how, on many modern CPUs you can change the microcode as it&#8217;s nolonger &#8220;hard-coded&#8221; in the way it used to be. Which if you know how to do it makes an interesting attack vector which would be difficult if not impossible to detect&#8230;</p>
<p>The point to remember though is as you abstract you limit your options, thus the closer you get to any definition of &#8220;secure&#8221; the less freedom you have. However being heavily constrained does not mean that the programer can not program insecurely, it at best only makes it harder, and as we know humans are fairly good at breaking the shackles that others apply to them.</p>
<p>As some one else has observed the car manufactures went through various stages. However a question has arisen from this, which is,</p>
<ul><i>Do we drive more recklessly as cars become safer to drive?</i></ul>
<p>And the answer to this appears to be &#8220;yes&#8221;, which if software goes the same way sugests the gains in security will not be that great if we do use more secure languages&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220707">

			<div class="comment by-db ">

				<p class="commentcredit">

					<span class="commenter">DB</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220707">
						April 25, 2014 10:41 PM					</a>

				</p>

				<p>@ David Thornley</p>
<p><i>&#8220;Does anybody else feel nervous when, in a security application, anything gets hold of uninitialized memory?&#8221;</i></p>
<p>Yes&#8230; I also feel even more nervous when, in a security application, anything <i>frees</i> memory without zeroing it out.  And if it was a private key, maybe it should be written with random data several times first too&#8230;  although ideally maybe that should be abstracted as a &#8220;secure erase&#8221; option that lower levels take care of, in case the low level medium needs things done differently than plain overwriting&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220708">

			<div class="comment by-yesme ">

				<p class="commentcredit">

					<span class="commenter">yesme</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220708">
						April 25, 2014 10:45 PM					</a>

				</p>

				<p>For the people talking about the UNIX legacy, here is an interesting <a href="http://doc.cat-v.org/bell_labs/good_bad_ugly/slides.pdf" rel="nofollow ugc">presentation</a> about that subject. Especially look at page 16 and 22/23.</p>
<p>@Clive Robinson</p>
<p>Plan-9 showed that having tools with less options are actually better than having tools with lots of options. Two examples of this: The GNU Autotools vs BSD Make and &#8220;<a href="http://harmful.cat-v.org/cat-v/" rel="nofollow ugc">cat -v</a>&#8220;.</p>
<p>Freedom comes with a price and in the case of computing that price is ambiguity.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220709">

			<div class="comment by-wael ">

				<p class="commentcredit">

					<span class="commenter">Wael</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220709">
						April 26, 2014 2:10 AM					</a>

				</p>

				<p>I would like to see someone write an efficient video device driver in PHP or .NET. How about a web application in assembler? Or a microcode snippet in Java?</p>
<p>I mentioned &#8220;E&#8221; before, so rather than talk about it again, how about looking at it from a different perspective and define the characteristics of a &#8220;Secure&#8221; programming language instead. We can follow by prototyping it on something like LLVM, then when it looks good, call it &#8220;S&#8221;? I still think it&#8217;ll have some issues. The programming language itself will have to be accompanied by mandatory static analysis engine and a dynamic runtime checker (a security specific one), I would imagine&#8230; I ignored the effects of HW, The OS, the protocols, etc&#8230; just to keep focus on the language. Better light a match than curse darkness, eh? Oh, I almost forgot! It&#8217;s got to be a general purpose language, too!</p>
<p>Then  there is the other approach. Pick the language of your choice and remove all the &#8220;bad&#8221; things from it, probably call it &#8220;C&#8211;&#8220;, how is that for evolution?</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220710">

			<div class="comment by-carlos ">

				<p class="commentcredit">

					<span class="commenter">Carlos</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220710">
						April 26, 2014 5:14 AM					</a>

				</p>

				<p>&#8220;Garbage Collected by default (euh&#8230; sorry C++ and C)<br />
Productive (euh&#8230; sorry C++)&#8221;</p>
<p>Actually, and this may have been said already (I didn&#8217;t read all the comments yet) but C++ does those two very well. Better than C, for productivity, I&#8217;d say.</p>
<p>But don&#8217;t take my word for it&#8230;<br />
<a href="http://channel9.msdn.com/Events/Build/2014/2-661" rel="nofollow ugc">http://channel9.msdn.com/Events/Build/2014/2-661</a></p>
<p>And as for what Mr. Stroustrup wanted and wants for C++, instead of some interview from somewhere on the interweb, lets give a hand to the man himself:<br />
<a href="http://channel9.msdn.com/Events/GoingNative/2013/Opening-Keynote-Bjarne-Stroustrup" rel="nofollow ugc">http://channel9.msdn.com/Events/GoingNative/2013/Opening-Keynote-Bjarne-Stroustrup</a></p>
<p>Oddly enough, both videos were made by evil proprietary Microsoft&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220711">

			<div class="comment by-yesme ">

				<p class="commentcredit">

					<span class="commenter">yesme</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220711">
						April 26, 2014 6:16 AM					</a>

				</p>

				<p>@Carlos</p>
<p>Come on, you cherry picked these two things?</p>
<ul>
<li>Garbage Collected: I meant mandatory. That&#8217;s the only way to do it right and avoid bugs.</li>
<li>About productivity: Compile and compile and compile&#8230;</li>
</ul>
<p>Just look at the big picture. C++ sucks. Big time.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220712">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220712">
						April 26, 2014 9:12 PM					</a>

				</p>

				<p>@ Wael</p>
<p>&#8220;I would like to see someone write an efficient video device driver in PHP or .NET. How about a web application in assembler? Or a microcode snippet in Java?&#8221;</p>
<p>I&#8217;m not sure what the point of that is but I bet I could do all the above. I&#8217;d write a generator of low level assembler or C in each language. Then, I&#8217;d write the driver, web app, and microcode in language of your choice with output being something efficient. 😛</p>
<p>&#8221; probably call it &#8220;C&#8211;&#8220;&#8221;</p>
<p>Already <a href="http://www.cminusminus.org/" rel="nofollow ugc">taken</a>.</p>
<p>&#8220;I ignored the effects of HW, The OS, the protocols, etc&#8230; just to keep focus on the language.&#8221;</p>
<p>Haha. The trick is designing them all together to complement each other. This was done in a number of projects with more on the way. Approximate this if it isn&#8217;t possible. Once you&#8217;re done, it won&#8217;t run Windows or Linux apps. Be lucky if it runs any mainstream app. Just means you gotta write a bunch more code. 🙂</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220713">

			<div class="comment by-wael ">

				<p class="commentcredit">

					<span class="commenter">Wael</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220713">
						April 26, 2014 11:41 PM					</a>

				</p>

				<p>@Nick P,</p>
<p>The point is there is no single language that&#8217;s fit for everything. If you are suggesting that the generator you develop generates secure &#8220;C&#8221; code, then maybe you found a way around the problem 😉<br />
Was not aware &#8220;C&#8211;&#8221; was taken, oh link master&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220714">

			<div class="comment by-mr-pragma ">

				<p class="commentcredit">

					<span class="commenter">Mr. Pragma</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220714">
						April 27, 2014 5:26 AM					</a>

				</p>

				<p>Nick P</p>
<p><i>&#8220;&#8221;Would you say OpenBSD, mostly written in C, is unsecure?&#8221;</p>
<p>Yes I would. They&#8217;re certainly not secure. Although, they are better than any other group at preventing and fixing software defects in a C-based, monolithic OS.&#8221;</i></p>
<p>Right. There is a great project that is anal about safety &amp; security, there&#8217;s great coders, there&#8217;s the right attitude (! &#8211; often underestimated an importance) &#8230; and yet there&#8217;s bug and, although rarely, even a vulnerability. And that&#8217;s guys who <em>do</em> recognize at least a part of C being problematic and find fixes.</p>
<p>Simple thing: <em>Evidently</em> even great designers and coders, even with the best attitude, <em>can not produce reliable software in C</em>!</p>
<hr />
<p>You are right about a lot of things and quite obviously you have done your research and did it well. I think the (not too big) differences between your and my point of view mainly stems from our goals. You are looking for perfection (well understood, a worthy goal) while I&#8217;m looking how to efficiently and quickly create less problems and vulnerabilities.</p>
<p>In other words, you might be (roughly) summarized as &#8220;I want to be able to create a really highly secure system&#8221; while I might be summarized as &#8220;98% of the current systems can not be made even reasonably well and even a perfectly build server (or program) will rather soon be cracked due to the iceberg below &#8211; that must change!&#8221;</p>
<p>It seems only natural to me that we have a lot in common. After all we look at the same problems and we look roughly in the same direction searching better paradigms and tools.</p>
<p>I&#8217;m shocked by OpenBSD. I mean, you can hardly find better guys, better capability, more experience, better attitude, more of good intention and readiness to go the extra mile &#8211; and yet OpenBSD in the end can&#8217;t deliver better than the crappy, vulnerable next door toy.</p>
<p>For me that&#8217;s a shocking and frightening proof how right my iceberg asessment is.<br />
(And don&#8217;t get me wrong. This is <em>by no means</em> in any way against OpenBSD. Those guys are to be praised and they just proved their high quality again!)</p>
<p>In a way the language question must be: Is it reasonably possible to produce high quality code with the kind of developers and teams that are available?<br />
With Modula, Ocaml, Ada it is. With C/C++/java it&#8217;s not. There can not even be a discussion about that after the openssl eruption.</p>
<p>And btw. part of the problem is that people are <em>abusing</em> C. Because, again, C was designed as a meta-assembler for low-level OS stuff. Yes, the Unix guys <em>then</em> used it for the whole system and even more. But then, <em>at that time</em> that seemed appropriate. Neither were significantly better alternatives established, nor was security a major concern.</p>
<p><i>&#8221; that I port Modula/Oberon to an existing processor that&#8217;s safer at instruction level with hardware POLA support (eg object descriptors). Main candidates are a Java processor (without the Java), SAFE processor (tagged &amp; high level), CHERI processor (segmented MIPS), or Itanium (memory keyed). Might then retarget something like SPIN OS, JX architecture, EROS kernel, or Active Oberon System to it.&#8221;</i></p>
<p>While I personally feel again that you are targetting too much for perfection, I roughly agree. But I think that a solution must, at least first, address the billions of IA32 and Arms out there.</p>
<p>Or in other words: I feel that our problem is not so much that some postgraduate specialists at some intelligence service can hack our boxes. The problem is that thousands and thousands of college boys can make it their hobby to &#8211; successfully &#8211; attack our systems.</p>
<p>And btw. almost everyone is mad at the crackers. I feel we shouldn&#8217;t forget to be mad at ourselves, too! After all, we sent the crackers invitations by building and using the mega-crap load in the first place. Even worse, not few in our circles still insist on continued use of C, C++, java &#8230;</p>
<p>@David Thornley (April 25, 2014 5:43 PM)</p>
<p><i>&#8220;&#8230; all the OpenSSL people had to do to avoid this was to  &#8230;&#8221;</i></p>
<p>But they didn&#8217;t. And that&#8217;s almost certainly not because they are worse developers than others.</p>
<p><i>&#8220;Do not use arrays or null-terminated strings. Just don&#8217;t. Use only C++ containers and strings from the standard libraries &#8230;&#8221;</i></p>
<p>Read that paragraph of yours again. It&#8217;s basically saying: Don&#8217;t use C++, rather use Modula, Ada, etc. Because that&#8217;s what it&#8217;s coming down to in all but name. Basically you say &#8220;Use C++ notation and syntax to program in e.g. Modula&#8221;. And you know what? That&#8217;s still worse than Modula or Ada because while it avoids some of C/C++ many traps there are still some more.</p>
<p>Let me, just as one point, suggest that you think about &#8220;readability&#8221;. Because, you see, for instance the openssl source files were written once but &#8211; at least should and quite probably &#8211; have been read many times. Even worse, often they have been read by someone else.</p>
<p>@Clive Robinson (April 25, 2014 7:03 PM)</p>
<p>You are right. But &#8230;</p>
<p>It seems most security related problems aren&#8217;t introduced by bad microcode or gate design.</p>
<p>While I don&#8217;t perfectly agree with Nick P and feel that he is too much on the perfection side and, in my view, somewhat ignorant of the billions of bleeding boxes out there, I also feel that he is right insofar as we must at least strive for and work on secure languages.</p>
<p>Maybe it&#8217;s, at least in part, a wording problem. Maybe one shouldn&#8217;t say &#8220;secure language&#8221; but rather &#8220;not bloody insecure vulnerability generators&#8221;.</p>
<p><i>&#8220;The point to remember though is as you abstract you limit your options, thus the closer you get to any definition of &#8220;secure&#8221; the less freedom you have.&#8221;</i></p>
<p>There you&#8217;re wrong. There are quite some languages out there that do not limit ones more (than C/C++). For example Ada. I&#8217;d have a hard time finding something I could do in C++ but not in Ada. And if you told me one I&#8217;d comfortably find some examples for things one can do well and reliably in Ada but not in C++.</p>
<p>And that&#8217;s me who is not a fervent &#8220;100% Ada (or whatever) only!&#8221; guy. I had my reasons to mention Ada&#8217;s interface for C favourably.</p>
<p>@Wael</p>
<p>You are right. No language is &#8220;the right one&#8221; for <em>everything</em>. And even within one area, say dynamic web pages, one must differentiate. For many sites some language toy might be good enough, for my bank I would hate to see some php page.</p>
<p>But there are languages for &#8220;almost everything&#8221; that have a good track record. Granted Ada won&#8217;t (and shouldn&#8217;t) replace Verilog (but Verilog might learn and take sth. from Ada). Nor would anyone in his right mind create the website of the local baker in Ada (or C++ for that matter).</p>
<p>But one <em>can</em> &#8211; and reasonably &#8211; do &gt;90% of an OS, basically every server, and pretty every application in a good &#8220;general&#8221; language.</p>
<p>As usual GUI is an ugly, ugly, area that spoils a lot. Although I have found some limited kind of peace with Freepascal/Lazarus for GUI stuff (although I certainly dislike it but it seems to be the best compromise).</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220716">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220716">
						April 27, 2014 12:35 PM					</a>

				</p>

				<p>@ Wael</p>
<p>&#8220;The point is there is no single language that&#8217;s fit for everything. &#8221;</p>
<p>Definitely true. It&#8217;s why I&#8217;m looking into improvements on assembler and C just as I look into better system languages. I think all will be useful or necessary at some point. Esp considering the legacy problem.</p>
<p>&#8220;Was not aware &#8220;C&#8211;&#8221; was taken, oh link master&#8230;&#8221;</p>
<p>Haha I knew my buddy Wael loved him some links. 😉 C&#8211; was more stolen than taken. You can take it back if you like. They&#8217;re just programmers so should be an easy fight. I got your back.</p>
<p>Sidenote. Original reply was on mobile hence hasty. That you mentioned microcode made me want to point out that there are people trying to do for hardware what languages like Ada or Haskell try to do for software. <a href="http://www.bluespec.com/high-level-synthesis-tools.html#bsv-lang" rel="nofollow ugc">Bluespec Language</a> and tools come to mind as they&#8217;re used in CHERI clean-slate project &amp; industry. One newcomer out of academia is <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CCsQFjAA&amp;url=http%3A%2F%2Fwww.cs.ucsb.edu%2F~benh%2Fresearch%2Fpapers%2Fli11caisson.pdf&amp;ei=UiRdU-vKPKjSyAHLm4CwCg&amp;usg=AFQjCNEArvoH_91blfmBI-ez7n8Zdg9ggw&amp;bvm=bv.65397613,d.aWc" rel="nofollow ugc">Caisson</a>, which aims at secure info flow. Have fun with those.</p>
<p>@ Mr Pragma</p>
<p>&#8220;Right. There is a great project that is anal about safety &amp; security, there&#8217;s great coders, there&#8217;s the right attitude (! &#8211; often underestimated an importance) &#8230; and yet there&#8217;s bug and, although rarely, even a vulnerability. And that&#8217;s guys who <em>do</em> recognize at least a part of C being problematic and find fixes. Simple thing: <em>Evidently</em> even great designers and coders, even with the best attitude, <em>can not produce reliable software in C</em>!&#8221;</p>
<p>Well said. Same thing I think about them. They&#8217;re quite excellent at making a known bad approach to security almost come out good. Almost. (evil grin)</p>
<p>&#8220;You are right about a lot of things and quite obviously you have done your research and did it well. I think the (not too big) differences between your and my point of view mainly stems from our goals. You are looking for perfection (well understood, a worthy goal) while I&#8217;m looking how to efficiently and quickly create less problems and vulnerabilities.&#8221;</p>
<p>You&#8217;ve correctly described the two goals. We&#8217;re both looking for the same thing, though, in that we share one. A baseline that prevents many problems &amp; enhances development is desirable. (our shared goal) Hopefully, this baseline can also be a foundation for even higher assurance work. (my extra goal) The best comparison I can give you is Ada vs SPARK. SPARK largely is Ada. That means you can start with Ada for your goal, then use SPARK for (part of) mine. The strategy achieves ease of learning, easy integration with main Ada app, and extra assurance just where you need it. Ada also supports assembler &amp; hardware interfaces when needed.</p>
<p>So, as we talk about various levels from assembler to quite HLL&#8217;s, I&#8217;m thinking of how to apply this concept. So, you say assembler, I think typed assembler. You say C, I&#8217;m considering things like Cyclone or C0. I&#8217;m thinking &#8220;How can we improve whatever we&#8217;re using at a certain level with minimal impact on developers AND integrate it into rest of code body without problems?&#8221; Integration is especially important. For instance, there was a vulnerability for years (might still exist) that occurred when Ada programs linked in C code due to interaction between how each internally structures code or data. A secure Ada program using a library in C would easily be compromised, yet you were safer if including assembler. (Imagine that.)</p>
<p>So, while it comes off setting perfection the minimum, I&#8217;m actually just looking for a holistic solution that has quality tools for each job that integrate well and allow selective application of high assurance to various components or layers. Let me give you another quick example you might not have ever heard of: <a href="http://mca-ltd.com/martin/Ten15/introduction.html" rel="nofollow ugc">Ten15</a>. They achieved my requirement in a radical way by making a special target language [1] (in a VM) that could safely integrate code written in LISP, Ada, and ML. Quite an amazing feat. You could code on low-level component in a primitive language, code a crypto library in SPARK, code the app in Modula, and link them all together with safety enforced at lowest (software) level. The FLEX computer also enforced this in hardware, so that&#8217;s doable too.</p>
<p>[1] &#8220;Another way of looking at this is that Ten15 was an idealized abstraction of high-level languages, whereas other virtual machines have usually been idealized abstractions of assembly-level languages.&#8221; (Ten15 developer)</p>
<p>So, I&#8217;m just looking at each layer and trying to make them work together. Java largely isn&#8217;t getting torn up because it&#8217;s a bad language. It&#8217;s the integration points and mapping between paradigms (eg JVM code calling native libraries) that get hit the most. Our language solutions to safer apps would likely have the same problem manifest in a different way. So, I feel the solution will require at a minimum at least one &#8220;programming in the large&#8221; safe HLL, a way to write efficient unsafe code with manageable risk (eg better than C), a way to integrate assembler where necessary, and a way to link these together without introducing any extra risk.</p>
<p>Even in this scheme, I&#8217;m still with you on giving the average developer a language that isn&#8217;t a &#8220;trouble generator.&#8221; We&#8217;ve acknowledged Ocaml, Ada, Modula, etc as meeting that requirement in various ways. Higher assurance tech or languages can integrate with any so long as the core of it is type-safe, memory-safe, and has simple calling conventions.</p>
<p>&#8220;With Modula, Ocaml, Ada it is. With C/C++/java it&#8217;s not. There can not even be a discussion about that after the openssl eruption.&#8221;</p>
<p>You&#8217;d think&#8230;</p>
<p>&#8220;Yes, the Unix guys <em>then</em> used it for the whole system and even more. But then, <em>at that time</em> that seemed appropriate. Neither were significantly better alternatives established, nor was security a major concern.&#8221;</p>
<p>Indeed. That&#8217;s what people loving C and UNIX must realize: they came from a different world that wasn&#8217;t full of complexity and black hats. Their design decisions were <em>fundamentally wrong</em> for the new situation. Even back then, there were alternatives that would&#8217;ve made most black hats retire. Should be clear to smart developers that, even if they maintain legacy stuff, they should be doing new projects in a different way that&#8217;s geared to current environment.</p>
<p>&#8220;hile I personally feel again that you are targetting too much for perfection, I roughly agree.&#8221;</p>
<p>Not perfection: safety from ground up with no bypasses via abstraction gaps and integration points. I can&#8217;t understate this problem. I&#8217;ve seen safe languages and VM&#8217;s bypassed steadily at various layers from unsafe libraries to SMM mode. One of my efforts concerns languages. Another concerns making architecture that closes the risky abstraction gaps &amp; supports safety/security at ISA level. Hence, as we discuss safe languages, I look for a way to integrate them with safe architectures to force the attacker to work in the straight-jacket of type-safety &amp; POLA regardless of what component they target.</p>
<p>Seeing as systems from 60&#8217;s-80&#8217;s already did this, I might as well take a stab at it myself as I look at these software issues. I would feel shame if my 21st century design was inferior in safety to computers designed in the days of rotary phones. Ex: Burroughs B5000 came out around 1961, with touch-tone phones hitting market in 1963. Yes, touch tone phones were cutting edge when many of our software problems were solved by proper architecture. Today, we have Siri and 40&#8217;s-50&#8217;s security architecture. Read: insecurity architecture.  (Sighs)</p>
<p>Of course, like you said, it&#8217;s a hell of a lot of work to do such a vertically integrated solution. So, I usually just do an abstract version on paper, post the idea on this blog, and hope someone else with more resources will build it. So, whether I build it or not, I still think the ideas are worth posting on a blog claiming 250,000 readers. Regulars here often see products or papers pop up with specific things that were published here. So, I know we have an effect whether they give credit or not. 😉</p>
<p>&#8220;But I think that a solution must, at least first, address the billions of IA32 and Arms out there.&#8221;</p>
<p>You&#8217;re right. Due to architecture, the solution will necessarily be different than one that&#8217;s ground up. The best work in this area uses hardware extensions &amp; software tricks to protect memory, control flow, etc. The best software-only solutions are microkernel-type work such as Dresden&#8217;s TUDOS and language-level work such as SPIN/JX. Thing is, the legacy code on these architectures is an instant bypass of anything you write in a safe language. So, both my goals can&#8217;t be achieved there. However, our shared goal of using tools that produce fewer defects is achievable here at each layer where people are willing to sacrifice backwards compatibility and/or their favorite language/tool/methodology.</p>
<p>&#8220;And btw. almost everyone is mad at the crackers. I feel we shouldn&#8217;t forget to be mad at ourselves, too! &#8221;</p>
<p>In a previous comment here, I squarely <a href="https://www.schneier.com/blog/archives/2011/06/yet_another_peo.html#c556377" rel="nofollow ugc">blamed</a> the users for demanding garbage. Then we all got what <em>they</em> demanded. Developers, both commercial and FOSS, haven&#8217;t helped much on this. It&#8217;s why, if not liability or regulation, I&#8217;m for some nonprofit or service model that changes the incentives. That&#8217;s research in progress.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220717">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220717">
						April 27, 2014 1:09 PM					</a>

				</p>

				<p>@ Wael, Mr Pragma, Clive and others</p>
<p><b>Creators admit UNIX and C were a hoax</b></p>
<p><a href="https://www.gnu.org/fun/jokes/unix-hoax.html" rel="nofollow ugc">https://www.gnu.org/fun/jokes/unix-hoax.html</a></p>
<p>Posted a version here before but worth sharing again as it&#8217;s so good. Funniest thing about it is that it could&#8217;ve been true. Wait, is that funny or deeply disturbing given widespread use of UNIX/C? I&#8217;ll let you decide.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220718">

			<div class="comment by-mr-pragma ">

				<p class="commentcredit">

					<span class="commenter">Mr. Pragma</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220718">
						April 27, 2014 1:27 PM					</a>

				</p>

				<p>Nick P</p>
<p>Allow me to (only seemingly) ignore what you wrote and to introduce yet another angle into the discussion.</p>
<p>Frankly, I think, many such discussions and reflections are misguided by having fallen prey to a major problem of a different kind, lies (of all sorts and in diverse incarnations, PR Bullsh*t being just one example).</p>
<p>One point I hear again and again is &#8220;No single language can solve all problems&#8221;.</p>
<p>Well this is true. And at the same time it&#8217;s not.<br />
It&#8217;s not because of the implicit deduction virtually almost linked to it: And therefore we need many languages. Add some &#8220;democracy&#8221; bla bla and you arrive at &#8220;We need many languages and all of them are equal(ly justified)&#8221;.</p>
<p>That&#8217;s bullsh*t.</p>
<p>As an example look at C, the meta-assembler. Nothing, f*cking nothing, did prohibit us from learning and coming to the conclusion that the idea of a meta-assembler was brilliant but it&#8217;s implementation, C, at least seen from today, was is not the pea of wisdom. Nothing kept us away from creating a better meta-assembler, say, based on a stripped down and then extended/specialized somewhat Modula.</p>
<p>In other words: Looking where bugs are, at what their favourite &#8220;bio environment&#8221;, we would have found out that it&#8217;s (unrestrained and uncontrolled) pointers, uncontrolled arrays, uncontrolled *allocs and frees, etc.<br />
And something else and more important. We would have found out that humans are not good at meticulously keeping in mind and staying in control of thousands or millions of tiny things &#8211; but computers are.</p>
<p>Another example, making a large step into a more modern era, say, the 90ies: multithreading. A classical bio-environment for errors and bugs. Funnily Modula, Ada, Oberon saw and understood that and took care of it &#8211; C/C++/java went the other way of adding complexity and problems.</p>
<p>Another major problem area that is in some kind of not-completely-truth fog: <em>Who</em> is producing software?<br />
Well, for the by far largest part it&#8217;s employed developers and open source developers.</p>
<p>And both groups have a major problem. The former almost always are under pressure to produce yet more code and features and versions (read: to create shit just stable enough to not crash right away and such being sellable). The latter are of, to word it very diplomatically, mixed quality.</p>
<p>There is very little middle ground, say proven good open source developers or employed developers with a reasonable time budget and responsible product managers.</p>
<p>THAT&#8217;s the world we need to take care of (not some few high-sec white castles).</p>
<p>And for that world it would, in fact, be <em>very positive</em> to have not one but some few quite similar languages.</p>
<p>It would be great and it would greatly contribute to less buggy software if there was a Modula style meta-assembler, a Modula style general language (say, sth. like Oberon or Ada), and a Modula style scripting language, maybe with inferred typing and some sugar coating.<br />
And that whole shebang cross platform.</p>
<p>Granted, a large part of the open source guys would be pissed of by the compiler saying again and again &#8220;Njet!&#8221; and would give up (which I, frankly, would consider a major advantage), and many product managers would just hate a 10% longer development cycle &#8211; but we would have generally was better software (and after a while even product managers would start to understand that reuseability might have a slightly higher start up cost but would pay for itself multiple times over with further releases).</p>
<p>Funnily, Wirth understood and addressed even that point, albeit indirectly, by complaining about universities being way too much influenced by corporation interests.</p>
<p>But frankly, I&#8217;m getting tired because in the end this discussion doesn&#8217;t make sense. It won&#8217;t change a thing. Just look at the openssl disaster. The outcome: some very few guys, not at linucks but at a BSD, and not at the big BSD but at the small one, take serious steps. And the <em>big thing</em> is some linucks foundation PR, politics, big names, big companies, bla bla and lots of money burnt.</p>
<p>I&#8217;ve learned that lesson and have started quite a while ago to address the customers (they exist and thanks to nsa/Snowden our customer base even grows considerably) who really, really, need reliable software, secure servers, etc.<br />
So, seen from that perspective, let them C/C++/java guys go ahead and create crap &#8211; and customers for us. 😉</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220719">

			<div class="comment by-wael ">

				<p class="commentcredit">

					<span class="commenter">Wael</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220719">
						April 27, 2014 2:41 PM					</a>

				</p>

				<p>@Nick P,</p>
<blockquote><p>Creators admit UNIX and C were a hoax</p></blockquote>
<p>Good one and almost believable! Reminds me of: “Truth is stranger than Fiction, but it is because Fiction is obliged to stick to possibilities; Truth isn&#8217;t.”<br />
― Mark Twain</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220720">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220720">
						April 27, 2014 4:52 PM					</a>

				</p>

				<p>@ Wael</p>
<p>Nice quote. I&#8217;ll have to remember that one.</p>
<p>@ Mr Pragma</p>
<p>&#8220;Allow me to (only seemingly) ignore what you wrote and to introduce yet another angle into the discussion.&#8221;</p>
<p>LOL. Many people ignore what I write. Least you have the courtesy to add something to the discussion while you do it. 😉</p>
<p>&#8220;Nothing kept us away from creating a better meta-assembler, say, based on a stripped down and then extended/specialized somewhat Modula.&#8221;</p>
<p>Some, including Wirth, took that approach so I&#8217;d say it&#8217;s provably true.</p>
<p>re humans vs computers at managing many tiny things; multithreading in various languages</p>
<p>Nicely put for both issue and example.</p>
<p>&#8220;Well, for the by far largest part it&#8217;s employed developers and open source developers.And both groups have a major problem. The former almost always are under pressure to produce yet more code and features and versions (read: to create shit just stable enough to not crash right away and such being sellable). The latter are of, to word it very diplomatically, mixed quality.&#8221;</p>
<p>Yes</p>
<p>&#8220;THAT&#8217;s the world we need to take care of (not some few high-sec white castles).&#8221;</p>
<p>I certainly see your point &amp; focus. Traditionally, when tools &amp; efforts are put into one, they spill over into the other. My research showed much [effective] security/safety tech came from people building castles. Just got copied &amp; integrated into mainstream. I&#8217;m with you in that I think it&#8217;s better for majority of R&amp;D investment to go to improving COTS capabilities rather than high assurance. It will have that much of a payoff when the quality/security increases in commercial sector. So, I&#8217;d say 95%+ R&amp;D effort on improving COTS capabilities with rest focused on pushing envelope for reliability/security (eg high assurance).</p>
<p>&#8220;It would be great and it would greatly contribute to less buggy software if there was a Modula style meta-assembler, a Modula style general language (say, sth. like Oberon or Ada), and a Modula style scripting language, maybe with inferred typing and some sugar coating.<br />
And that whole shebang cross platform.&#8221;</p>
<p>We&#8217;re thinking on similar lines. The more mentally and technically they&#8217;re connected the better across the board. Each a different level of abstraction, safety, productivity, and effeciency. Each consistent &amp; easily integrated. Just imagine the effect that would have on tooling as well. A change to one might easily be ported to the other. Would be comparable to maintaining one to two product lines rather than half to a whole dozen like now.</p>
<p>&#8220;Granted, a large part of the open source guys would be pissed of by the compiler saying again and again &#8220;Njet!&#8221; and would give up <i>(which I, frankly, would consider a major advantage)</i>&#8221;</p>
<p>What I call the Theo de Raadt approach to ensuring OSS code quality. (paraphrasing) &#8220;If you don&#8217;t like our approach, there&#8217;s the door and there&#8217;s a cliff. Take your pick.&#8221;</p>
<p>&#8220;Funnily, Wirth understood and addressed even that point, albeit indirectly, by complaining about universities being way too much influenced by corporation interests.&#8221;</p>
<p>Even funnier, he proved it by developing custom computers that ran a good chunk of the university with software coded in safe, modular, performing languages. While university traded that for COTS garbage, it did prove that safer and more reliable systems were doable for a tiny fraction of what COTS market spent developing their own software. Those fools would&#8217;ve probably saved so much money over time if they had partnered with other universities &amp; got grants to just extend systems like Lilith/Oberon into what they needed. Admittedly, I&#8217;m just hypothesizing based on Windows, IBM, and RDBMS luxurious licensing fees extended over decades by lock-in. 😉</p>
<p>&#8220;But frankly, I&#8217;m getting tired because in the end this discussion doesn&#8217;t make sense&#8230;I&#8217;ve learned that lesson and have started quite a while ago to address the customers (they exist and thanks to nsa/Snowden our customer base even grows considerably) who really, really, need reliable software, secure servers, etc.<br />
So, seen from that perspective, let them C/C++/java guys go ahead and create crap &#8211; and customers for us. ;)&#8221;</p>
<p>Smart idea. It&#8217;s been my preferred approach as well. Another guy here (RobertT) said the same thing about Snowden leaks effect on his business. I&#8217;m in a tough area for IT in general so I haven&#8217;t noticed the benefits. Yet. I&#8217;ll add that your choice of market segment gives you the added benefit of avoiding potential tarnishing of your name when forced to write garbage code for unwise clients. There&#8217;s something inherently enjoyable about doing the majority of work for clients that want good work done and are willing to pay for it. And your references are almost always positive. 🙂</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220721">

			<div class="comment by-david-thornley ">

				<p class="commentcredit">

					<span class="commenter">David Thornley</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220721">
						April 27, 2014 5:53 PM					</a>

				</p>

				<p>@Mr. Pragma:</p>
<p>The OpenSSL folks didn&#8217;t even take advantage of the minimal safety abilities C provides.  Does that suggest, to you, that they would have done anything sensible in any other language?  One little style rule, enforceable by a simple search, would have made the bug unexploitable.  (Yes, it would have been better to not leave used memory lying around.  That takes a little attention, and I&#8217;m looking at what can be done as a matter of habit and easily checked mechanically, and would have left Heartbleed a stupid but harmless error.)</p>
<p>This suggests to me that, if the OpenSSL team couldn&#8217;t be bothered to take advantage of any safety features, they would have managed to screw up in any language powerful enough to write the software in.  Your complaint suggests that you want a language with more safety guards to be unbolted and kicked into the corner, and I frankly don&#8217;t see the point.</p>
<p>I&#8217;m very puzzled by the references to C++.  I&#8217;m referring to the use of bog-standard C++ features that I use on a daily basis.  This is not any attempt to use Ada or Modula or other language, or an attempt to do anything besides idiomatic and readable C++ (although the .at() member function is not all that heavily used), but a brief lesson on what C++ offers, and indeed has offered as long as it&#8217;s been standardized (about 16 years now).  The 2011 standard offers more stuff, but I thought I&#8217;d stick to basics.</p>
<p>The fact that you seem to think this is something out of the ordinary indicates that you really don&#8217;t know what you&#8217;re talking about in regards to C++.  If you wanted to look into it, you might be surprised; after all, you did think that perfectly ordinary C++ code looked like something from a language you like a lot better.  If you care to bring up other areas where you think C++ may have security weaknesses, perhaps I can find other boringly normal C++ code that fixes those problems.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220722">

			<div class="comment by-mr-pragma ">

				<p class="commentcredit">

					<span class="commenter">Mr. Pragma</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220722">
						April 27, 2014 5:59 PM					</a>

				</p>

				<p>Nick P</p>
<p><i>&#8220;The more mentally and technically they&#8217;re connected the better across the board. Each a different level of abstraction, safety, productivity, and effeciency. Each consistent &amp; easily integrated. Just imagine the effect that would have on tooling as well. A change to one might easily be ported to the other. Would be comparable to maintaining one to two product lines rather than half to a whole dozen like now.&#8221;</i><i></p>
<p>Yep. And each one could strike the right balance in power, convenience, etc.<br />
While the meta-assembler would be much about power but not at all targetting general applications and caring little about convenience (which is an added plus because we certainly don&#8217;t want hobbyist fumbling sat OSs), the scripting would be quite sugared and convenient, even lending itself to &#8220;quick hacks&#8221;), yet, enabling a pragma (&#8220;strict&#8221;) immediately point out potential problems and what needed to be better specified to survive the standard compiler (which again throws in a free &#8220;concept language and tester&#8221;).</p>
<p>I&#8217;m wondering that Modula and Oberon are severely ill and all but left alone (although it seems ETHZ is reviving Oberon &#8211; great!) and even Ada with all the players like Boeing pumping gazillions into it is widely ignored (well, compared to php, ruby, [insert worthless toy or &#8220;web basic&#8221;]).<br />
I&#8217;m smelling corporate interests &#8230;</p>
<p>As you happened to mention it, directly or indirectly, more than once:</p>
<p>I&#8217;m sorry but afaic that whole L4 based &#8220;security&#8221; stuff (calling itself &#8220;fiasco&#8221;; any further questions?) is doubtlessly well intended but those guys very evidently haven&#8217;t heard the shot. Security by using C++, virtualization and linucks? Uhum &#8230; Frankly, that reminds me of a term Bruce (iirc) phrased, &#8220;security theater&#8221;; that should be left to tsa rather than to universities.</p>
<p>Oh and btw., once more something nice (coming from Spain), &#8220;MarteOS&#8221; (Ada for RTOS) is hardly breathing and, so it seems, lacking support. But OK, &#8220;linucks inside&#8221; sound nicer and MarteOS doesn&#8217;t offer that &#8230;</p>
<p>As you are doing so much research in that area: Any hints towards a free RTOS (or mini OS) with a reasonable set of drivers, a reasonable set of supported architectures (min. IA32, Arm, and preferably some more) supporting Oberon or Ada?</i></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220723">

			<div class="comment by-mr-pragma ">

				<p class="commentcredit">

					<span class="commenter">Mr. Pragma</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220723">
						April 27, 2014 6:08 PM					</a>

				</p>

				<p>David Thornley (April 27, 2014 5:53 PM)</p>
<p>You love C++ and think it&#8217;s a great language? No problem, just go ahead. And don&#8217;t be bothered by the fact that even highly reputable ITC researchers and very experienced C++ user consider it next to impossible to even know C++ completely &#8230; Sure enough they also just don&#8217;t know what they&#8217;re talking about.</p>
<p>And no, I will not engage in a discussion with someone seriously thinking (I&#8217;m polite) C++ is a great language and can be used for reliable, safe, secure software.</p>
<p>This blog is about security. So, kindly accept accept that decision of mine. Sure enough there are plenty &#8220;C++ is great&#8221; blogs and fora.</p>
<p>Thank you and have a nice week.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220725">

			<div class="comment by-clive-robinson ">

				<p class="commentcredit">

					<span class="commenter">Clive Robinson</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220725">
						April 27, 2014 7:13 PM					</a>

				</p>

				<p>@ Mr. Pragma,</p>
<ul><i>There you&#8217;re wrong. There are quite some languages out there that do not limit ones more (than C/C++). For example Ada. I&#8217;d have a hard time finding something I could do in C++ but not in Ada.</i></ul>
<p>There is a lot more to consider than the &#8220;programer view&#8221; when looking at security. I often mention &#8220;Efficience -v- Security&#8221; as an area that is a major cause for concern, especialy where side channels are concerned.</p>
<p>One of the problems with languages that do a lot of &#8220;in the background&#8221; activities such as garbage collection, bounds checking , etc is it provides signals that can be both recognisable and regular to the software flow. Which makes for reliable triger points for amongst other things DPA.</p>
<p>Perhaps not so oddly th saying about &#8220;Freedom and Security&#8221; applies as much to design and development as much to life in society.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220726">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220726">
						April 27, 2014 10:14 PM					</a>

				</p>

				<p>@ David Thornley</p>
<p><a href="http://www.modulaware.com/mdlt28.htm" rel="nofollow ugc">Here</a> is an old critique of C++ that you might find interesting. Scroll down the page until you see the bold heading &#8220;C++? A critique of C++&#8221; It&#8217;s a nice essay about the purpose of programming languages, desirable traits, many C++ traits, and whether they help or hinder the process.</p>
<p>One presenting Oberon-2 as a C++ alternative mentioning specifics with example code<br />
<a href="http://www.modulaware.com/mdltws.htm" rel="nofollow ugc">http://www.modulaware.com/mdltws.htm</a></p>
<p>Author of CVSup saying why he choose Modula-3 over C or C++<br />
<a href="https://modula3.elegosoft.com/pm3/intro/questions/whym3.html" rel="nofollow ugc">https://modula3.elegosoft.com/pm3/intro/questions/whym3.html</a></p>
<p>Ada 95 compared to C++<br />
<a href="http://archive.adaic.com/intro/ada-vs-c/ada-vs-c.html" rel="nofollow ugc">http://archive.adaic.com/intro/ada-vs-c/ada-vs-c.html</a></p>
<p>Both have been updated since then, with Ada in 2005 and 2012. Yet, some of the points made still apply. New C++ standard might help with some issues.</p>
<p>Free Pascal lists advantages (short).<br />
<a href="http://www.at.freepascal.org/advantage.html" rel="nofollow ugc">http://www.at.freepascal.org/advantage.html</a></p>
<p>A former Delphi (Pascal RAD) developer on why it won&#8217;t die. Implies good things.<br />
<a href="http://stevepeacocke.blogspot.com/2013/05/delphi-why-wont-it-just-die.html" rel="nofollow ugc">http://stevepeacocke.blogspot.com/2013/05/delphi-why-wont-it-just-die.html</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220727">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220727">
						April 28, 2014 12:39 AM					</a>

				</p>

				<p>@ Mr Pragma</p>
<p>&#8220;I&#8217;m wondering that Modula and Oberon are severely ill and all but left alone (although it seems ETHZ is reviving Oberon &#8211; great!) &#8221;</p>
<p>The problem there is, sadly, Wirth. He&#8217;s great at coming up with things. Maintaining things? Quite the opposite. His pattern is to invent a good language/toolset, build a bunch of stuff in it, and then dispose of it. He &amp; his disciples did this for Pascal, Modula, Oberon, Oberon-2, Active Oberon, Component Pascal, and the recent one I can&#8217;t remember. Each time, the old one just becomes legacy software. Only one that&#8217;s really thriving that I know of is Free Pascal because it built on Delphi&#8217;s legacy. Wirth&#8217;s &amp; Co&#8217;s inventiveness is the main obstacle to the success of Wirth-based technology. Life&#8217;s ironies yet again.</p>
<p>&#8220;I&#8217;m sorry but afaic that whole L4 based &#8220;security&#8221; stuff (calling itself &#8220;fiasco&#8221;; any further questions?) is doubtlessly well intended but those guys very evidently haven&#8217;t heard the shot. Security by using C++, virtualization and linucks? Uhum &#8230; Frankly, that reminds me of a term Bruce (iirc) phrased, &#8220;security theater&#8221;; that should be left to tsa rather than to universities.&#8221;</p>
<p>Lol at Fiasco name. Yeah, maybe that wasn&#8217;t a great choice. Yet, they&#8217;re using an approach that has worked well in the past for few that used it. The few systems evaluated to high assurance (eg B3/A1, EAL6-7) took a similar approach. Tannenbaum also makes a good <a href="http://www.cs.vu.nl/~ast/reliable-os/" rel="nofollow ugc">case</a> for them. Thing is, they can be combined with safe language tech. Coarse-grained protection is done by microkernel, with fine-grained protection done by functions. For example, Ada runtimes running on a microkernel side-by-side with apps in untrusted OS partition is already commercial practice. Similar things exist in a few open source projects.</p>
<p>The key points of such an architecture are to keep the TCB tiny and simple, while using hardware protection mechanisms where possible. I have a hard time arguing against that.</p>
<p>&#8220;As you are doing so much research in that area: Any hints towards a free RTOS (or mini OS) with a reasonable set of drivers, a reasonable set of supported architectures (min. IA32, Arm, and preferably some more) supporting Oberon or Ada?&#8221;</p>
<p>For Ada, there was the Army Secure Operating System, Secure Ada Target, FLEX, and BiiN projects. SAT &amp; BiiN were mostly prototypes, others commercial &amp; delivered. All gone. MarteOS was the only recent project I was aware of. For Oberon, the Oberon System seems to meet your requirements. Latest incarnation is A2 Bluebottle OS. (<a href="http://www.oberon.ethz.ch/" rel="nofollow ugc">group page</a>) I&#8217;d analyze and trim that joker to get what&#8217;s worth keeping. Then, expand on that one application at a time. (Esp starting with network appliance or console type apps.)</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220728">

			<div class="comment by-name-withheld-for-obvious-reasons ">

				<p class="commentcredit">

					<span class="commenter">name.withheld.for.obvious.reasons</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220728">
						April 28, 2014 6:26 AM					</a>

				</p>

				<p>@ et al<br />
Just wanted to way in&#8211;was on a Tools Task Force back in the &#8217;90s for a large systems manufacturer. My task, along with other members, was to hash out the development environment in a meaningful way. Historically (the experience that was common) was to &#8220;find&#8221; or &#8220;locate&#8221; anomolies based on waterfall approach that repetitively cycled through system test and patches. It was useful to have a robust change control and configuration management system in place along with the appropriate toolchain.<br />
Large scale development environments use CASE-based and UML modeling tools to drive top level architecture(s) from specification to operation&#8211;being able to generate documentation, versioning, and bug tracking within one environment can be a powerful system&#8230;but&#8230;when it comes to developing platforms that pay specific attention to quality, performance, and integrity that delivers to the customer is a rare beast. I&#8217;ve seen it once&#8211;and&#8211;I also saw it &#8220;subverted&#8221; by a espionage from a foreign government. A separate project that included another operating system project (AFS/NFS services on OS/400). During a routine parsing of the development tree I noticed time stamps for access times changing. &#8220;Must be a backup running in operations?&#8221; Oops, no one in the ops center&#8211;but there is a test running on the project host&#8211;but what is this network bionomial distribution test running on the &#8220;Winter&#8221; machine&#8230;but why is it stating all the directories of our research system?<br />
Oh oh, there&#8217;s a remote network connection to the &#8220;Plasma&#8221; project system&#8211;and it terminates well outside the country. Does the project lead know what&#8217;s up&#8211;I check with the two assigned o the project and the response suggests they&#8217;re clueless.<br />
Back to the problem, having the host servicing the &#8220;Plasma&#8221; project to provide mirrored port do a full ethernet dump/trap. Okay, the data is being scooped up by a scripted series of events triggered by the host for the &#8220;Winter&#8221; project. Maybe the source for the &#8220;Winter&#8221; project will provide a clue&#8211;what is this in the PPT code&#8211;it is a worm crawling our server, collecting filesystem namespace data, and shipping it offshore. Do I stop tracking this and report it or do I continue to investigate? Okay, I&#8217;ll check into it&#8230;look the worm is using DNS to enumerate the remote collection site&#8211;it&#8217;s some university&#8230;but why? This is a &#8220;secret&#8221; project&#8211;my boss is not going to be happy. And, Jimmy, the lead on the &#8220;Winter&#8221; project is going to feel a bit used&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220729">

			<div class="comment by-david-thornley ">

				<p class="commentcredit">

					<span class="commenter">David Thornley</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220729">
						April 28, 2014 12:45 PM					</a>

				</p>

				<p>@Nick P:</p>
<p>Thank you for the list of references.  The ones that actually talk about C++ seem to be from the early or mid 1990s, when C++ lacked a lot of the abilities it has now.</p>
<p>The first one had some good criticisms, but got into a lot of style issues that the author disagreed with, which rather diluted the effect.  There were valid criticisms of multiple inheritance in C++, for example, mixed in with complaints such as C++ allowing unnamed function parameters (such as a declaration like &#8220;int f(int);&#8221;*).  It made it difficult to read.  Had the author divided substantive criticisms (such as the rather vague specification of C++&#8217;s virtual functions) from desires that the language be designed to the author&#8217;s aesthetics, it would have been much more useful.</p>
<p>The valid criticisms have generally been addressed by features in C++ standards (complaints about the insecure C-style arrays and strings have been addressed with std::vector and std::string, in the 1998 Standard, while the vagueness of C++&#8217;s virtual functions was not really addressed until the 2011 standard), and general agreement to Not Do That (such as the multiple inheritance facilities, which are normally used only with strict rules).  There are things the language does not enforce, but any reasonable peer review will, and I don&#8217;t think I want to use security software that lacked peer review.</p>
<p>Similarly, Ada 95 compares very favorably with pre-standard C++, but not so much with current C++.</p>
<p>I&#8217;m not saying here that C++ is necessarily a good language for security software (that&#8217;s beyond my expertise), but rather that this thread has not come up with valid reasons why it isn&#8217;t.</p>
<p>*Yes, something like &#8220;int f(int);&#8221; is unhelpful.  However, so is &#8220;int f(int i);&#8221;.  While there are languages that enforce some sort of name, I know of none that can enforce a meaningful name.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220730">

			<div class="comment by-mr-pragma ">

				<p class="commentcredit">

					<span class="commenter">Mr. Pragma</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220730">
						April 28, 2014 2:24 PM					</a>

				</p>

				<p><i>&#8220;Ada 95 compares very favorably with pre-standard C++, but not so much with current C++&#8221;</i></p>
<p>That changes, and brutally so, when comparing current C++ to current Ada (2012) or even just Ada 2005.</p>
<p>And that&#8217;s what one compares, right. Yesteryears to yesteryears and todays to todays.</p>
<p>I do btw not see a problem with C++. When one is young, that is. Hundreds of debugging sessions and hundreds of bugs later, a <em>professional</em> developer (as opposed to e.g. a for fun hacker) starts to think.<br />
Some million stolen credit cards number later a pro starts to think.<br />
After Snowden a pro starts to think.<br />
And after openssl even the smarter amateurs start to think.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220731">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220731">
						April 28, 2014 5:54 PM					</a>

				</p>

				<p>@ David Thornley</p>
<p>&#8220;The first one had some good criticisms, but got into a lot of style issues that the author disagreed with, which rather diluted the effect.&#8221;</p>
<p>It seems to be unavoidable to have one without the other when getting posts criticizing a language. The problem is that reviewers disconnected enough for true neutrality and focus on facts often have so little experience with the languages their views don&#8217;t apply to real-world use. So, for me, I just recognize there will likely be bias or subjective stuff if the writer is a veteran programmer, then mentally filter it out. Nearly unavoidable.</p>
<p>&#8220;There are things the language does not enforce, but any reasonable peer review will, and I don&#8217;t think I want to use security software that lacked peer review.&#8221;</p>
<p>This is the problem. There are many such things that aren&#8217;t a problem in some other languages even without peer review. I learned this moving from an industrial-grade BASIC &amp; 4GL&#8217;s to C++ over ten years ago. The easy things were harder to do, programs crashed more (esp using 3rd party libraries), compiles for large modules went from a few seconds to minutes, compiles screwed up more in general, debugging took longer, and I had to make huge checklists of what to avoid. So, I hombrewed a BASIC-to-C++ solution for a while and later switched to Delphi which eliminated many of those problems. I felt the language designs of each contributed to the experiences and results.</p>
<p>&#8220;Similarly, Ada 95 compares very favorably with pre-standard C++, but not so much with current C++.&#8221;</p>
<p>I&#8217;m aware it&#8217;s improved over time, esp if one counts Boost. So did Ada with update in 2005 and 2012. Here&#8217;s a <a href="http://www.adacore.com/knowledge/technical-papers/safe-secure/" rel="nofollow ugc">page</a> that breaks down each langauge feature and how safety is enhanced with language design. You could look at these to make a mental comparison between that and how average and good C++ programmers would do such things. The biggest addition in Ada 2012 is design by contract (<a href="http://www.drdobbs.com/architecture-and-design/ada-2012-ada-with-contracts/240150569" rel="nofollow ugc">Dr Dobbs article</a>).</p>
<p>While trying to find that info for you, I also stumbled upon this article which has an Ada bias, but mentions plenty of improvements in both C++11 and Ada2012 while making comparisons:</p>
<p><a href="http://electronicdesign.com/embedded/c11-and-ada-2012-renaissance-native-languages" rel="nofollow ugc">http://electronicdesign.com/embedded/c11-and-ada-2012-renaissance-native-languages</a></p>
<p>It looks like they&#8217;ve been learning from each other a bit. In previous research I particularly liked C++11 standardizing rvalues, smart pointers, strongly-typed enums, lambdas, and static-asserts. These features, imho, will contribute the most to robust code with the exception of rvalue as it&#8217;s just a nice performance boost. Yet, when I look at Ada 2005 and 2012, the better safety is usually on Ada side. Concurrency stands out with new standard being inferior to both current Java standard and Ada&#8217;s model from the 90&#8217;s. Seeing how important concurrency is, lacking productive and safe ways of doing it is quite a drawback.</p>
<p>(Irony is many server-side software directly impacted by such issues are written in C++. Might explain the number of concurrency related bugs &amp; vulnerabilities in them over time.)</p>
<p>&#8220;I&#8217;m not saying here that C++ is necessarily a good language for security software (that&#8217;s beyond my expertise), but rather that this thread has not come up with valid reasons why it isn&#8217;t.&#8221;</p>
<p>I certainly see what you&#8217;re saying. My stance is it&#8217;s a bad language for software period, unless it&#8217;s extending a legacy C++ app. C++ was proven in at least two empirical studies to have higher quality and maintainability than C. That&#8217;s it. Other studies showed other languages I mentioned were better than C++ in safety, maintainability, and productivity. Many anecdotes also support this from ex-C++ programmers. Modern imperative languages, esp C# &amp; Scala, add even more features supporting effective language use. Old languages in Pascal, Ada, and even BASIC lines continue to be enhanced in those attributes.</p>
<p>So, given a safe, quick to compile, quick to run, efficient, C FFI-supporting language with good tool and platform support it&#8217;s hard for me to justify using a language (C++) inferior in every way besides potential efficiency &amp; C integration. Whether high-level or low-level development, there&#8217;s langauges (esp Ada) that are superior across the board with acceptable performance. The only drawbacks that would make me settle on C++ would be talent availability, amount of existing code in C++, and/or useful library code in C++.</p>
<p>Interesting enough, there are still arguments against C++ in those few situations. The safer languages can use C++ library code by compiling C++ with &#8220;extern C,&#8221; then calling resulting code via FFI &amp; wrapping it in type-safe interface. I did that plenty in BASIC. Existing code in C++ can be done that way or use cross-language development techniques (esp message passing) to extend it using safe language. If it must be <em>changed</em>, yeah that takes C++ experts with good knowledge of code base &amp; tool support.</p>
<p>Regarding talent, a few companies using odd languages pointed out that avoiding mainstream stuff filters out the kind of people they&#8217;d rather not have. As in, exceptional developers can often pick up a new language with minimal training. And although Ada is tough, the Wirth-style languages are simple enough for a programmer to learn key concepts in a day &amp; master in mere months to a year. It&#8217;s why they have had a strong presence in Comp Sci education over the years. The students get to focus on applying concepts &amp; solving problems rather than fighting with syntax and compiler. If good talent isn&#8217;t available, then one would be <em>even better off</em> using a language that enforces plenty safety as low talent coders certainly won&#8217;t pull it off in C++.</p>
<p>So, my default has been to oppose C++ in any new projects unless it&#8217;s proven to be necessary. I&#8217;ve seen few justifications for loss of clarity, safety &amp; maintainability that comes with it. Reading the CVE&#8217;s in commercial and open source software supports my point. None are <em>secure</em>, yet using one of my C++ alternatives can knock out a number of errors with zero effort &amp; reduce others with less effort. Combined with other benefits, the case against C++ seems pretty clear to me.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220732">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220732">
						April 28, 2014 6:40 PM					</a>

				</p>

				<p>@ name.withheld</p>
<p>Good hunting. 🙂 The scenario is quite believable. When I based much work on security/separation kernels, I leaned heavily on lessons learned in high assurance evaluations under Orange Book, European standard, and Common Criteria. The requirements involved total lifecycle protection &amp; many assurance activities. However, I noticed that the development &amp; SCM tools themselves were trusted. I criticized this saying much can be bypassed by compromising these. The use of independent evaluation &amp; diverse implementations of tools (esp checkers) helps for sure. Yet, I still saw plenty risk.</p>
<p>My compromise was to leverage my existing cheats. Ideally, the SCM, filesystem, network, IDE&#8217;s, distribution, etc would all be A1/EAL7 evaluated if they&#8217;re developing a similar grade product. The cheat was to embed high assurance in just a few components: a client-side trusted terminal device, a client side secure network device, a centralized router/firewall/gateway, and a SCM server (or cluster). Except for SCM, each already existed in an A1 product. That saves some effort, eh?</p>
<p>The SCM server is special. It has very minimal functionality with most work being done by untrusted COTS systems. The SCM server just accepts requests, validates them, logs them in append-only file system, and then processes them according to both security policy &amp; SCM functionality (eg scripts). An assured pipeline approach was taken whereby dedicated functions were performed on dedicated, fast devices that booted quickly. SCM would reset a device to a clean state, send a piece of data to it with an order to perform a function, over a safe interface of course, and then store the results with some metadata in its append-only storage. This scheme prevents many attacks by design, while making others easier to detect &amp; recover from.</p>
<p>Oh, I forgot to mention that a regular Windows or UNIX system was used for each developer with corresponding benefits. Completed code was sent through a guard (even a simple Pump) to the trusted client. Two screens are used to make a visual comparison easier. Per security policy, SCM only accepts code from trusted device &amp; no Internet access is allowed to it (or its helpers). Signed releases are obtained either manually over standard media or automatically via transmission over data diode to untrusted server. That server is optionally public facing for app or data dissemination. Most devices involved are small, cheap PC&#8217;s so justify using so many of them. Today, it would be PCI card, pico-ITX, or 1U type systems.</p>
<p>Might have solved your problem.</p>
<p>@ Clive</p>
<p>&#8220;One of the problems with languages that do a lot of &#8220;in the background&#8221; activities such as garbage collection, bounds checking , etc is it provides signals that can be both recognisable and regular to the software flow. Which makes for reliable triger points for amongst other things DPA.&#8221;</p>
<p>It&#8217;s <em>definitely</em> true as I criticized Freenet for using Java both due to attack surface &amp; how it obscures covert channels. Of course, one can use a safer language &amp; still assess covert flows in a number of ways. If language basically just introduces checks, one can create a more detailed view that shows <em>all</em> code including checks &amp; calls to any runtime. If using structured programming, the analysis can be done quite easily. There&#8217;s still issues such as out of order execution, caching, etc.</p>
<p>This leads me to another possibility. There is existing work in languages and runtimes designed to detect, prevent or mitigate covert channels of various kinds from software to hardware. Quite a few methods for storage and timing channels in sequential code. At least two for concurrent. Such techniques can be mapped to whatever safer language is to be used. Tools would analyze code using such a framework &amp; produce a report of potential covert channels in the code. The developer could then take steps from there. Seems straightforward enough.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220733">

			<div class="comment by-mathias-hollstein ">

				<p class="commentcredit">

					<span class="commenter"><a href='http://tron-delta.org' rel='external nofollow ugc' class='url'>Mathias Hollstein</a></span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220733">
						April 30, 2014 11:35 AM					</a>

				</p>

				<p>First let me say that I agree with Thierry, Joe and others who already mentioned that such research should be taken with a grain of salt.</p>
<p>The study itself tells the reader that basically every language can be used I a secure fashion although there is a clear connection between flawed systems and languages used.</p>
<p>As one commenter on German site heise.de already mentioned there are well designed languages and ones that are not so well designed. User »EinmalMitProfisArbeiten« also mentioned that languages like C should not be compared to interpreted ones like PHP and that skilled developers are able to separate well designed languages and tools from ones that do not match this criteria.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220734">

			<div class="comment by-wael ">

				<p class="commentcredit">

					<span class="commenter">Wael</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220734">
						May 2, 2014 3:37 AM					</a>

				</p>

				<p>I don&#8217;t know if it makes sense to talk about the &#8220;security of a programming language&#8221;. C, for example was not designed to be secure. Security &#8220;enhancements&#8221; were later additions and were not built-in from the start. Same applies to C++. How could one expect a &#8220;secure&#8221; language to allow the following expressions to compile and function as expected? Funny thing is that there are some uses for such constructs, although not common and considered &#8220;hacks&#8221;&#8230;Such use of expressions tempts programmers to get &#8220;cute&#8221;, and perhaps is another reason for subtle &#8220;security issues&#8221;&#8230;</p>
<blockquote><p>
#include &amp;#60iostream&amp;#62<br />
using namespace std;</p></blockquote>
<blockquote><p>
int main(int argc, const char * argv[])<br />
{<br />
    int array[10];<br />
    const char * name = &#8220;Schneier&#8217;s Blog&#8221;;</p>
<p>    // Set array elements to 0,1,2,&#8230;,9<br />
    for(int i=0; i&amp;#60 10; ++i)<br />
        array[i]=i;</p>
<p>    // This compiles<br />
    for(int z=0; z&amp;#60 10; ++z)<br />
        cout &amp;#60&amp;#60 z[array] &amp;#60&amp;#60 endl;</p>
<p>    // This too (same idea&#8230;)<br />
    cout &amp;#60&amp;#60 4[name];</p>
<p>    return false;<br />
}</p></blockquote>
<p>basically x[y] = y[x] because arrays are understood as pointers. I used to ask this question in interviews. Not many people got it right. Probably a lysdexic (or is it dyslexic?) would get it right by mistake 😉</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220735">

			<div class="comment by-yesme ">

				<p class="commentcredit">

					<span class="commenter">yesme</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220735">
						May 2, 2014 4:29 AM					</a>

				</p>

				<p>@Wael</p>
<p>The problem starts with line 1 and 2 (serious).</p>
<blockquote><p>#include iostream</p>
<p>using namespace std;</p></blockquote>
<p>C++ has no modularity and no mandatory namespacing. So you can put any macro in header files that changes the entire program. Sometimes programs even demand a specific order of included header files.</p>
<p>With the Wirth languages (and Go) this is simply impossible.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220736">

			<div class="comment by-wael ">

				<p class="commentcredit">

					<span class="commenter">Wael</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220736">
						May 2, 2014 6:12 AM					</a>

				</p>

				<p>@ yesme,<br />
Macros are another problem. In C++, macros are hardly needed! but I doubt you&#8217;ll see commercial or open source C++ code without macros&#8230;</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220737">

			<div class="comment by-mandy-perkins ">

				<p class="commentcredit">

					<span class="commenter">Mandy Perkins</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220737">
						May 3, 2014 2:03 PM					</a>

				</p>

				<p>Direct link to the report: <a href="http://info.whitehatsec.com/rs/whitehatsecurity/images/statsreport2014-20140410.pdf" rel="nofollow ugc">http://info.whitehatsec.com/rs/whitehatsecurity/images/statsreport2014-20140410.pdf</a></p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220738">

			<div class="comment by-anura ">

				<p class="commentcredit">

					<span class="commenter">Anura</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220738">
						May 7, 2014 7:08 PM					</a>

				</p>

				<p>@Nick P</p>
<blockquote><p>&#8220;That said, .NET websites do have a tendency to be misconfigured to show the exception with the stack trace&#8230; combined with a debug build being deployed and I&#8217;ve seen cases where invalid input prints out the code that builds the SQL; very useful to an attacker.&#8221;</p></blockquote>
<blockquote><p>I&#8217;ve seen that! It was on a major web site whose name I can&#8217;t recall at the moment. I used a form of some type, then saw what looked like a debug dump. I was thinking &#8220;should the *user* be seeing all this crap? Or should it have been emailed to admin or developers?&#8221; Two options, one good &amp; one bad for security, which will .NET choose? Result: &#8220;Doh!&#8221; (Homer Simpson)</p></blockquote>
<p>Well, I have to say that I just got the most detailed error message I have ever seen, on a somewhat major news site. This time it&#8217;s in ColdFusion on Railo+Apache Tomcat, and I have the following:</p>
<p>A structue giving the exact SQL query that errored<br />
The name of the database server<br />
The version of the JDBC driver they are using (10.2.0.5.0)<br />
The version of Oracle they are using (Oracle Database 11g Release 11.1.0.0.0 &#8211; Production)<br />
The full stack trace (281 levels deep!).<br />
Plus, a bunch of other dumps of data structures that I&#8217;m not that interested in.<br />
They also appear to be using something called FusionReactor</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment even thread-even depth-1" id="comment-220739">

			<div class="comment by-nick-p ">

				<p class="commentcredit">

					<span class="commenter">Nick P</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220739">
						May 7, 2014 8:09 PM					</a>

				</p>

				<p>@ Anura</p>
<p>Wow, that is a fail to the next level.</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

		<article class="comment odd alt thread-odd thread-alt depth-1" id="comment-220740">

			<div class="comment by-impulse ">

				<p class="commentcredit">

					<span class="commenter">IMPULSE</span> •

					<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/#comment-220740">
						May 8, 2014 10:04 AM					</a>

				</p>

				<p>EPIC FUCKING FAIL INDEED BURPSUITE GO !!!!! SQL NINJA WILL LOVE THIS DISCOVERY</p>

				
			</div>

		</article>

		</li><!-- #comment-## -->

	<p class="subscribe-comments">
		<a href="https://www.schneier.com/blog/archives/2014/04/the_security_of_8.html/feed/">
			<img alt="Atom Feed" src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/rss.png">
			Subscribe to comments on this entry		</a>
	</p>

		<div id="respond" class="comment-respond">
		<h2 class="comments-open-header">Leave a comment <small><a rel="nofollow" id="cancel-comment-reply-link" href="/blog/archives/2014/04/the_security_of_8.html#respond" style="display:none;">Cancel reply</a></small></h2><form action="https://www.schneier.com/wp-comments-post.php" method="post" id="commentform" class="comment-form" novalidate><a href="https://www.schneier.com/wp-login.php?redirect_to=https%3A%2F%2Fwww.schneier.com%2Fblog%2Farchives%2F2014%2F04%2Fthe_security_of_8.html" title="Login">Login</a><p class="comment-form-author"><label for="author">Name</label> <input id="author" name="author" type="text" value="" size="30" maxlength="245" /></p>
<p class="comment-form-email"><label for="email">Email</label> <input id="email" name="email" type="email" value="" size="30" maxlength="100" /></p>
<p class="comment-form-url"><label for="url">URL:</label> <input id="url" name="url" type="url" value="" size="30" maxlength="200" /></p>
<p class="comment-form-cookies-consent"><input id="wp-comment-cookies-consent" name="wp-comment-cookies-consent" type="checkbox" value="yes" /> <label for="wp-comment-cookies-consent">Remember personal info?</label></p>

<p class="comment-form-author">

	<label for="comm_capt_challenge">
		Fill in the blank: the name of this blog is Schneier on ___________ (required):	</label>

	<input id="comm_capt_challenge" name="comm_capt_challenge" size="30" type="text" />
</p>

<div class="comment-form-comment">

	<label for="comment">Comments:</label>

	<textarea id="comment" name="comment" cols="45" rows="8" maxlength="65525" required="required"></textarea>

	<div id="preview-box" class="preview-box hide"></div>
	<img class="comment-loading hide" src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/loader.gif" />

</div>

<p id="allowed">

	<strong>Allowed HTML</strong>
	&lt;a href=&quot;URL&quot;&gt; &bull; &lt;em&gt; &lt;cite&gt; &lt;i&gt; &bull; &lt;strong&gt; &lt;b&gt; &bull; &lt;sub&gt; &lt;sup&gt; &bull; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &bull; &lt;blockquote&gt; &lt;pre&gt;
	<strong>Markdown Extra</strong> syntax via <a href="https://michelf.ca/projects/php-markdown/extra/">https://michelf.ca/projects/php-markdown/extra/</a>
</p>

<input type="hidden" id="wp_comment_nonce" name="wp_comment_nonce" value="4b1534b792" /><input type="hidden" name="_wp_http_referer" value="/blog/archives/2014/04/the_security_of_8.html" />
<input type="button" id="comment-preview" class="comment-preview comment-actions" value="Preview" />
<input type="button" id="comment-write" class="comment-write comment-actions hide" value="Edit" />

<p class="form-submit"><input name="submit" type="submit" id="submit" class="submit" value="Submit" /> <input type='hidden' name='comment_post_ID' value='5316' id='comment_post_ID' />
<input type='hidden' name='comment_parent' id='comment_parent' value='0' />
</p></form>	</div><!-- #respond -->
	
	<div class="stepthrough">
		<a href="https://www.schneier.com/blog/archives/2014/04/dan_geer_on_hea.html" rel="prev">← Dan Geer on Heartbleed and Software Monocultures</a>		<a href="https://www.schneier.com/blog/archives/2014/04/conversnitch.html" rel="next">Conversnitch →</a>	</div>

	
<p id="powered">Sidebar photo of Bruce Schneier by Joe MacInnis.</p>
		</div>

		
<aside>
	<div class="sidebar" id="sidebar-two">
		<section><div class="sidesection widget widget_schneier_about" id="schneier_about-2"><h3>About Bruce Schneier</h3><img src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2019/10/Bruce-Schneier.jpg" /><p><p class="small">I am a <a href="https://public-interest-tech.com/">public-interest technologist</a>, working at the intersection of security, technology, and people. I've been writing about security issues on my <a href="/">blog</a> since 2004, and in my monthly <a href="/crypto-gram/">newsletter</a> since 1998. I'm a fellow and lecturer at Harvard's <a href="https://www.hks.harvard.edu/faculty/bruce-schneier">Kennedy School</a>, a board member of <a href="https://www.eff.org/">EFF</a>, and the Chief of Security Architecture at <a href="https://inrupt.com/">Inrupt, Inc.</a> This personal website expresses the opinions of none of those organizations.</p>
</p></div></section><section><div class="sidesection widget widget_schneier_related_posts" id="schneier_related_posts-2"><h3>Related Entries</h3>
<ul>

	<li><a href="https://www.schneier.com/blog/archives/2021/03/illegal-content-and-the-blockchain.html">Illegal Content and the Blockchain</a></li><li><a href="https://www.schneier.com/blog/archives/2021/03/national-security-risks-of-late-stage-capitalism.html">National Security Risks of Late-Stage Capitalism</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/weis-2021-call-for-papers.html">WEIS 2021 Call for Papers</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/ransomware-profitability.html">Ransomware Profitability</a></li><li><a href="https://www.schneier.com/blog/archives/2021/02/presidential-cybersecurity-and-pelotons.html">Presidential Cybersecurity and Pelotons</a></li><li><a href="https://www.schneier.com/blog/archives/2021/01/police-have-disrupted-the-emotet-botnet.html">Police Have Disrupted the Emotet Botnet</a></li>
</ul>
</div></section><section><div class="sidesection widget widget_schneier_featured_essays" id="schneier_featured_essays-2"><h3>Featured Essays</h3>
	<ul>
		<li><a href="https://www.schneier.com/essays/archives/2016/04/the_value_of_encrypt.html">The Value of Encryption</a></li><li><a href="https://www.schneier.com/essays/archives/2016/03/data_is_a_toxic_asse.html">Data Is a Toxic Asset, So Why Not Throw It Out?</a></li><li><a href="https://www.schneier.com/essays/archives/2014/01/how_the_nsa_threaten.html">How the NSA Threatens National Security</a></li><li><a href="https://www.schneier.com/essays/archives/2009/01/terrorists_may_use_g.html">Terrorists May Use Google Earth, But Fear Is No Reason to Ban It</a></li><li><a href="https://www.schneier.com/essays/archives/2007/01/in_praise_of_securit.html">In Praise of Security Theater</a></li><li><a href="https://www.schneier.com/essays/archives/2006/08/refuse_to_be_terrori.html">Refuse to be Terrorized</a></li><li><a href="https://www.schneier.com/essays/archives/2006/05/the_eternal_value_of.html">The Eternal Value of Privacy</a></li><li><a href="https://www.schneier.com/essays/archives/2005/09/terrorists_dont_do_m.html">Terrorists Don&#039;t Do Movie Plots</a></li>	</ul>

	<p><a href="https://www.schneier.com/essays/">More Essays</a></p></div></section><section><div class="sidesection widget widget_schneier_archives" id="schneier_archives-2"><h3>Blog Archives</h3>
<ul>

	<li><a href="https://www.schneier.com/blog/calendar.html/">Archive by Month</a></li><li><a href="https://www.schneier.com/blog/newcomments.html/">100 Latest Comments</a></li></ul>

<h4>Blog Tags</h4><ul class="top-tags"><li><a href="https://www.schneier.com/tag/3d-printers/">3d printers</a></li><li><a href="https://www.schneier.com/tag/9-11/">9/11</a></li><li><a href="https://www.schneier.com/tag/aaron-swartz/">Aaron Swartz</a></li><li><a href="https://www.schneier.com/tag/academic/">academic</a></li><li><a href="https://www.schneier.com/tag/academic-papers/">academic papers</a></li><li><a href="https://www.schneier.com/tag/accountability/">accountability</a></li><li><a href="https://www.schneier.com/tag/aclu/">ACLU</a></li><li><a href="https://www.schneier.com/tag/activism/">activism</a></li><li><a href="https://www.schneier.com/tag/adobe/">Adobe</a></li><li><a href="https://www.schneier.com/tag/advanced-persistent-threats/">advanced persistent threats</a></li><li><a href="https://www.schneier.com/tag/adware/">adware</a></li><li><a href="https://www.schneier.com/tag/aes/">AES</a></li><li><a href="https://www.schneier.com/tag/afghanistan/">Afghanistan</a></li><li><a href="https://www.schneier.com/tag/air-marshals/">air marshals</a></li><li><a href="https://www.schneier.com/tag/air-travel/">air travel</a></li><li><a href="https://www.schneier.com/tag/airgaps/">airgaps</a></li><li><a href="https://www.schneier.com/tag/al-qaeda/">al Qaeda</a></li><li><a href="https://www.schneier.com/tag/alarms/">alarms</a></li><li><a href="https://www.schneier.com/tag/algorithms/">algorithms</a></li><li><a href="https://www.schneier.com/tag/alibis/">alibis</a></li><li><a href="https://www.schneier.com/tag/amazon/">Amazon</a></li><li><a href="https://www.schneier.com/tag/android/">Android</a></li><li><a href="https://www.schneier.com/tag/anonymity/">anonymity</a></li><li><a href="https://www.schneier.com/tag/anonymous/">Anonymous</a></li><li><a href="https://www.schneier.com/tag/antivirus/">antivirus</a></li><li><a href="https://www.schneier.com/tag/apache/">Apache</a></li><li><a href="https://www.schneier.com/tag/apple/">Apple</a></li><li><a href="https://www.schneier.com/tag/applied-cryptography/">Applied Cryptography</a></li><li><a href="https://www.schneier.com/tag/artificial-intelligence/">artificial intelligence</a></li><li><a href="https://www.schneier.com/tag/assassinations/">assassinations</a></li></ul><p><a href="https://www.schneier.com/blog/tags.html/">More Tags</a></p></div></section><section><div class="sidesection widget widget_schneier_latest_book" id="schneier_latest_book-3"><h3>Latest Book</h3><a href="https://www.schneier.com/books/click-here/"><img class="sidepic" alt="Click Here to Kill Everybody" src="https://149400697.v2.pressablecdn.com/wp-content/uploads/2018/07/book-ch2-200w.png" /></a><p><a href="https://www.schneier.com/books/">More Books</a></p></div></section><section><div class="sidesection widget widget_schneier_promotion" id="schneier_promotion-2">
<a href="https://www.eff.org/issues/bloggers/legal/join">
	<img src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/join-eff@2x.png" id="effbutton" alt="Support Bloggers' Rights!" title="Support Bloggers' Rights!" /></a>

<a href="https://npo.networkforgood.org/Donate/Donate.aspx?npoSubscriptionId=8252">
	<img src="https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/images/support-epic@2x.png" alt="Defend Privacy--Support Epic" title="Defend Privacy--Support Epic" /></a>
</div></section>	</div>
</aside>

		<footer>
			<nav>
				<div class="nav" id="footer-nav">
					<div class="menu-main-menu-container"><ul id="menu-main-menu-1" class="menu"><li class="menu1 menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-50175 current-menu-item"><a href="https://www.schneier.com">Blog</a></li>
<li class="menu2 menu-item menu-item-type-post_type menu-item-object-page menu-item-50916"><a href="https://www.schneier.com/crypto-gram/">Newsletter</a></li>
<li class="menu3 menu-item menu-item-type-post_type menu-item-object-page menu-item-50166"><a href="https://www.schneier.com/books/">Books</a></li>
<li class="menu4 menu-item menu-item-type-custom menu-item-object-custom menu-item-50169"><a href="https://www.schneier.com/essays/">Essays</a></li>
<li class="menu5 menu-item menu-item-type-custom menu-item-object-custom menu-item-50170"><a href="https://www.schneier.com/news/">News</a></li>
<li class="menu6 menu-item menu-item-type-custom menu-item-object-custom menu-item-50171"><a href="https://www.schneier.com/talks/">Talks</a></li>
<li class="menu7 menu-item menu-item-type-post_type menu-item-object-page menu-item-50167"><a href="https://www.schneier.com/academic/">Academic</a></li>
<li class="menu8 menu-item menu-item-type-post_type menu-item-object-page menu-item-50174"><a href="https://www.schneier.com/blog/about/">About Me</a></li>
</ul></div>				</div>
			</nav>
		</footer>

		</div><!--#main-->
	</div><!--#wrapper-->

		<script type="text/javascript">
		(function () {
			var c = document.body.className;
			c = c.replace(/woocommerce-no-js/, 'woocommerce-js');
			document.body.className = c;
		})();
	</script>
	<script type='text/javascript' src='https://c0.wp.com/p/woocommerce/5.1.0/assets/js/jquery-cookie/jquery.cookie.min.js' id='jquery-cookie-js'></script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/vendor/socialshareprivacy/js/socialshareprivacy.js?ver=1.0.1' id='social-share-privacy-js'></script>
<script type='text/javascript' id='social-share-privacy-icons-js-extra'>
/* <![CDATA[ */
var schneierSocial = {"path":"https:\/\/www.schneier.com\/wp-content\/themes\/schneier\/assets\/vendor\/socialshareprivacy\/"};
/* ]]> */
</script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/vendor/socialshareprivacy/js/icons.js?ver=1.0.0' id='social-share-privacy-icons-js'></script>
<script type='text/javascript' id='schneier-comment-js-extra'>
/* <![CDATA[ */
var schneierComment = {"translateErrorSecurityAnswerWrong":"Your response to the challenge question ('The name of this blog is Schneier on ____') was not correct. Please try again.","ajax_url":"https:\/\/www.schneier.com\/wp-admin\/admin-ajax.php"};
/* ]]> */
</script>
<script type='text/javascript' src='https://149400697.v2.pressablecdn.com/wp-content/themes/schneier/assets/js/comment.js?ver=1.0.1' id='schneier-comment-js'></script>
<script type='text/javascript' src='https://c0.wp.com/c/5.7/wp-includes/js/wp-embed.min.js' id='wp-embed-js'></script>

</body>

</html>
